			COL		150			; Wide listings

			LSTOUT-
#include "msp430.h"
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Macros for obscure instruction sequences
#define Rtos   R7                           // Defined in BytecodeInterpreter2.s43
			LSTOUT+
#include "../common/common.h"				// Common definitions such as IMAGE_START

			NAME	main		; Module name
			PUBLIC	main		; Make the "main" label visible



; Addresses manually imported from the BSL-writer or debugger. Version 6. Keep up to date!
InitRetAddr	EQU		$102E		; Return address when interpretByte is called for initialisation
ReadByte	EQU		$1094		; Calling-address to receive byte in R8
WriteByte	EQU		$10CC		; Calling-address to transmit byte in R8
BSLErase	EQU		$1040		; Jump-in-address for erasing flash and continuing a download
VoltCal		EQU		$10F8		; Address of Voltage scale calibration word
TempCal		EQU		$10FA		; Address of Temperature offset calibration byte
LinkCal		EQU		$10FB		; Address of Link Voltage offset calibration byte
MHz8CalD 	EQU		$10FC		; Frequency calibration
MHz8CalB 	EQU		$10FD		;	for 8 MHz
ID			EQU		$10FE		; Address of this Cell's/BMU's identification byte


; Interpreter Register Usage
;	Registers 0 thru 3 are dedicated machine registers (PC SP SR CG).
#define 	Rip		R5				// Virtual machine instruction pointer
#define 	Rlit	R6				// Holds partial literals
#define 	Rw		R8				// Working register - temporary - anyone can use

; Conditional assembly
#define		WATCHDOG	1			// True if watchdog timer is to be used (only turn off for debugging)
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer

; Constants

; Stress calculations
; Stress set point is intended to be 3.
// OV = Over Voltage: Increase stress by 1 for each 10 mV in excess of 3.500 V, to a max of 15 at >= 3.65 V
OV_ZERO     EQU         3500        ; Threshold in mV between OV stress levels -1 and 0
OV_STEP     EQU         10          ; mV difference between one OV stress level and the next
// UV = Under Voltage: Increase stress by 1 for each 0 mV below 2.500 V, to a maximum of 15 at <= 1.75 V
UV_ZERO     EQU         2500        ; Threshold in mV between UV stress levels -1 and 0
UV_STEP     EQU         50         ; mV difference between one UV stress level and the next
// OT = Over Temperature: Increase stress by 1 for every 1 degree C above 40C, to a max of 15 at >= 55C
OT_ZERO     EQU         40          ; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP     EQU         1           ; Temperature in degrees C between one OT stress level and the next
// UT = Under Temperature: Increase stress by 1 for every 1 degrees C below 9C, to a max of 15 at <= -6C
UT_ZERO     EQU         9           ; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP     EQU         1           ; Temperature in degrees C between one OT stress level and the next
BYPLEV  	EQU			3560		; Bypass level in millivolts
minLEDStress EQU		11			; Minimum stress to light error LED
minAlrmStress EQU		11			; Minimum stress to sound alarm  (not in use yet)

; Status byte bit masks
STRESS_MASK		EQU		$0F
ENC_STRESS_MASK	EQU		$1F

; Port 1 bits
TXDm		EQU		1<<1			; TA0/P1.1
RXD			EQU		1<<2			; Receive data on P1.2 (bit number >3 costs 3 words in BSL)
VREFp		EQU		1<<4			; Analog reference output. Sometimes changed to low digital output
TXDp		EQU		1<<5			; SCLK/P1.5
PIEZO		EQU		1<<0			; Piezo on P1.0
ACTLED		EQU		1<<3			; Actvity LED (blue) inverted on P1.3
; Port 2 bits
BYPASS		EQU		1<<6			; Bypass transistor on pin P2.6
ERRLED		EQU		1<<7			; Error LED (red) on P2.7

; ADC channel numbers
CellVChan	EQU		$7				; ADC channel number for cell voltage
TempChan	EQU		$A				; ADC channel number for temperature
LinkVChan	EQU		$6				; ADC channel number for link voltage
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)

; Serialio definitions
#define		TACCTLr		TACCTL1		// Receive using CCI1 (P1.2)
#define		TACCTLt		TACCTL0		// Transmit (and everything else) using TA0
#define		TACCRt		TACCR0		// Transmit compare register
#define		TACCRr		TACCR1		// Receive capture/compare register

rxsz		EQU		8				; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
txsz		EQU		8				; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute

; The following macro gem is due to Dave Keenan. It is based on a Taylor series expansion.
; It is valid for the domain 1-64, and range 0-6.
; NOTE: it depends on the assembler rounding down on division, even for negative results
; There is a similar simple formula for rounding towards zero
#define LOG2(x) (4 * (x-8) / (x+8) + 3)

;
;			Memory definitions
;
			ORG		$200			; Start of RAM. Ends at $27F
#if	ADCBUF
			ALIGNRAM 1
sampleBuf	DS		2*NumSamples	; ADC sample buffer; 4 or 16 samples
#endif

monFlags		DS		1			; Monitor flags, bitmask definitions follow
bNotSendStatus 	EQU		2			; Zero if sending status bytes at all
bNotMeasureTime EQU		4			; Zero if time to measure

localStatus		DS		1			; Local stress, comms error and bypass status (0-2 stress,
									;	6 comms error, 5 all-in-bypass)
ticksSinceLastRx DS		1			; Timer overflow events since last status received
passWordState	DS		1			; State machine for password recogniser
lastSentStatus	DS		1			; Last sent status byte

; Serialio variables

				ALIGNRAM 1
TXData			DS		2			; Byte to transmit in lower byte; always $FF in high byte
RXData			DS		1			; Received char
BitCntTx		DS		1			; Bit count 10 -> 1
BitCntRx		DS		1			; Bit count 8 -> 1
TXCksum			DS		1			; Transmit checksum

				ALIGNRAM 1
rxbuf			DS		rxsz		; Receive queue buffer
rxwr			DS		1			; Receive queue write index
rxrd			DS		1			; Receive queue read index
txbuf			DS		txsz		; Transmit queue buffer
txwr			DS		1			; Transmit queue write index
txrd			DS		1			; Transmit queue read index

; ByteCodeInterpreter2 variables

RXCksum			DS		1			; Received packet xor checksum
intFlags		DS		1			; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1			; Should numeric output be in hexadecimal, not decimal?
bChecksumming 	EQU		2			; Are we sending checksums and checking received checksums?
bDontInterpret 	EQU		4			; Are we interpreting?

				ALIGNRAM 1
worstStress 		DS		1		; Worst local stress since last resetWorstStatus command
worstStressType 	DS		1		; Character giving type of measurement that caused worst stress
worstStressMeas 	DS		2		; Value of measurement that caused worst stress

				ALIGNRAM 1
ToIN			DS		2			; Pointer to current character being stored in Text Input Buffer
TIB				DS		48			; Text Input Buffer (packet buffer)
TIBEnd
; Must leave room for stack (about 36 bytes)

;-------------------------------------------------------------------------------
				ORG		IMAGE_START	; Reset vector points here
;-------------------------------------------------------------------------------

interpretByte:
main:										; For IAR Embedded Workbench IDE debugger
			mov.w	#$280,SP				; Initialize stackpointer
#if !WATCHDOG
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (bad idea, except while debugging)
#endif
			; Clear all variables in RAM except worstStress (and ToIN/TIB)
			_DO		#worstStress-$200,R8
				clr		$200-2(R8)
			_mLOOP	#2,R8

			; Initialise clocks. SMCLK is only used by comms timer and watchdog timer.
			; DIVS_1 => SMCLK = DCOCLK/2	DIVS_2 -> SMCK = DOCLK/4
			; DIVM_1 => MCLK = DCOCLK/2
			mov.b	#DIVM_1+LOG2(DCOckPerSMck)*DIVS_1, &BCSCTL2
			mov.b	&MHz8CalB,&BCSCTL1		; 8 MHz DCO cal data
			mov.b	&MHz8CalD,&DCOCTL
			; Prepare ACLK for piezo drive -- 3 kHz square wave
			bis.b	#LFXT1S_2,&BCSCTL3		; Select VLOCLK (~12 kHz) as source for ACLK divider

;
;	Initialise timer and interrupt comms
;
			; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
			; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
			; MC: 2 = continuous mode 1 = up mode
			; TAIE = interrupt enable (for timer overflow)
			mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2 + TAIE, &TACTL

			; Set up differential timer outputs for transmit data.
			; Tricky way of getting inverted TA0 to appear on P1.5 automatically
			; when TA0 appears on P1.1.
			; We use the clock inverter in the USI (Universal Serial Interface)
			; to invert TA0 and put it out as SCLK, in SPI master mode.
			; We don't use the shift register of the USI because there is
			; no way to get differential outputs from that without external hardware.
			mov.b	#RXD+TXDm,&P1SEL			; Select timer functions CCI1A and TA0 (not I/O port)
			mov.b	#ACTLED,&P1OUT				; Turn off (inverted) ActLED
			mov.b	#ACTLED+VREFp+TXDp+TXDm+PIEZO,&P1DIR ; Set ActLED, VREFp, TX bits and piezo to output
			mov.b	#0,&P2SEL					; Set BYPASS and ERRLED to not be crystal osc pins
			mov.b	#0,&P2OUT					; Set BYPASS and ERRLED off
			mov.b	#$FF,&P2DIR					; Set BYPASS and ERRLED as outputs

			mov.b	#USIPE5 + USIMST, &USICTL0	; SCLK out on P1.5, SPI Master mode, remove SW Reset
			mov.b	#USIDIV_0 + USISSEL_5 + USICKPL, &USICKCTL ; SCLK source is TA0, div by 1, inverted
			mov.b	#8, &USICNT					; To clear USIIFG so SCLK will not be held

			; Make TA0 (output of Timer-A capture/compare unit 0) appear on P1.1
			; We want to set the CCIFG so that TX_Byte won't think there's an uncompleted stop bit
			; and wait for it to complete.
			mov		&TAR,&TACCRt				; Make an output event
			add		#4,&TACCRt					;	happen in a dozen or so instructions
			; NOTE: the above has to be enough to get past setting of OUTMOD_5 for TACCTLt below
			mov.w	#OUTMOD_0 + OUT, &TACCTLt	; TA0=1 Space; seems necessary to "wake up" SCLK divider
			mov.w	#OUTMOD_5, &TACCTLt			; When the compare happens, set TA0=0 Idle or Mark

			mov.b	#$FF,&TXData+1				; Initialise the top half of TXData to all 1s (stop bit,
												;	idle bit)
			mov.b	#8,&BitCntRx				; Load Bit Counter, 8 data bits
;			clr.b	TXCksum						; Clear the transmit checksum
			mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&TACCTLr	; Falling edge, Input A, Sync, Capture
;			clr.b	&rxwr						; Initialise the TX and RX queue indexes
;			clr.b	&rxrd
;			clr.b	&txwr
;			clr.b	&txrd

;
; Initialise the ADC10
;
			; Enable cell and link analog inputs. Enable ADC function of P1.4 (Vref+ out)
			mov.b		#(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			; Initialise ADC10
			; SREF_1    = +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temp)
			; REFOUT    = connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			mov			#SREF_1+ADC10SHT_3+REFOUT+REFON,&ADC10CTL0
			; Other ADC10 initialisation is done every time "measure" is called, to save code

;
; Initialise the command character (bytecode) interpreter
;
			mov		#TIB,&ToIN				; Packet pointer

;
; Miscellaneous initialisation
;
			mov.b	#4,&passWordState		; Waiting for first byte of ^C ^B ^A ^@ sequence

; Main loop
			_BEGIN
				dint
				;nop							; First instruction after dint not protected
				call	#RX_RawByteNW			; Check if received data
				_IF		_NZ
					eint
					tst.b	R8
					_IF		_NN
						call	#TX_Byte				; Echo the command or password byte
						call	#DoPassword				; Check for password bytes
						call	#ACCEPT					; Process command bytes (could take a long time)
					_ELSE
						call	#DoStatus					; Process status bytes
					_ENDIF
				_ELSE
					bit.b	#bNotMeasureTime,&monFlags	; Check if time to measure
					_IF		_Z							; If not, skip measurement and set/clear of bypass
						eint
						bis.b	#bNotMeasureTime,&monFlags
						call	#measures				; May send status
					_ELSE
						mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer before sleeping CPU
						;eint							; Interrupts are enabled by following bis instr:
						bis		#CPUOFF+GIE,SR			; Turn off CPU, enable interrupts
					_ENDIF
				_ENDIF
#if WATCHDOG
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart Watchdog Timer each time around main loop
#endif
			_AGAIN
; End of main loop


measures:
;
; Regular measurement. Called StatusFreq times per second (4-32 times per second)
;
#define Rmeas R15				// Tentative measurement causing worst stress
#define Rtype R14				// Tentative type of measurement causing worst stress

			inc.b	&ticksSinceLastRx
			_IF		_Z						; Wrapped around to 0?
				mov.b	#$FF,&ticksSinceLastRx	; Yes, saturate at $FF
			_ENDIF

			; Cell voltage measurement
			call	#cellV					; Get cell voltage in mV in R10
			mov		R10,Rmeas				; Tentative measurement causing worst stress
			mov.b	#'V',Rtype				; Tentative type of measurement causing worst stress
			cmp		#BYPLEV,R10				; Compare current cell voltage (R10) to the bypass threshold
			CtoAllBits	R8					; If voltage >= threshold then $FF else $00
			movBits_B	R8,#BYPASS,&P2OUT	; Move only the #BYPASS bit from R8 to &P2OUT. Trashes R8

			; Overvoltage stress: for every OV_STEP mV over OV_ZERO, we add one level of stress
			mov		R10,R9					; Measurement
			sub		#OV_ZERO,R9		        ; Cell voltage - OV_ZERO
			_IF		_L
				clr		R9						; Minimum of zero
			_ENDIF
			push	R10						; Save measurement
			clr		R10						; R10:R9 has meas - OV_ZERO
			mov		#OV_STEP,R8
			call	#UMSlashMod				; (meas - OV_ZERO) / OV_STEP -> R9

			; Undervoltage stress: for every UV_STEP mV below UV_ZERO, we add one level of stress
			pop		R10						; Restore original measurement
			push	R9						; Save stress_so_far
			mov		#UV_ZERO+UV_STEP-1,R9
			sub		R10,R9					; R9 has UV_ZERO - meas plus UV_STEP-1 for rounding
			clr		R10						; R10:R9 has this
			_IF		_L
				clr		R9						; Minimum of zero
			_ENDIF
			mov		#UV_STEP,R8
			call	#UMSlashMod				; (UV_ZERO - meas) / UV_STEP -> R9
			pop		R8						; Restore stress_so_far
			cmp		R8,R9					; Which stress is worse?
			_IF		_LO
				mov		R8,R9				; Worst to R9
			_ENDIF

			; Temperature measurement
			push	R9						; Save stress_so_far
			call	#temp					; Get cell temperature in degrees Celsius in R10
			push	R10						; Save measurement
			; Overtemperature stress: 1 for every OT_STEP degrees over OT_ZERO
            mov     R10,R9
			sub		#OT_ZERO,R9
			_IF		_L
				clr		R9					; Minimum of 0
			_ENDIF
            clr     R10
            mov     #OT_STEP,R8
            call    #UMSlashMod             ; (meas - OT_ZERO) / OT_STEP -> R9
			rra		R10
			pop		R8						; Restore measurement
			pop		R9						; Restore stress_so_far
			cmp		R10,R9					; Is temp stress worse than stress_so_far?
			_IF		_LO
				mov		R10,R9					; Yes, new stress_so_far
				mov		R8,Rmeas				; Tentative measurement causing worst stress
				mov.b	#'T',Rtype				; Tentative type of measurement causing worst stress
			_ENDIF
			; Undertemperature stress: 1 for every UT_STEP degrees below UT_ZERO
			push	R8  					; Save measurement
            push    R9                      ; Save stress_so_far
			mov.b	#UT_ZERO,R9
			sub.b	R10,R9					; UT_ZERO - measurement
			_IF		_L
				clr		R9						; Min of 0
			_ENDIF
            clr     R10
            mov     #UT_STEP,R8
            call    #UMSlashMod             ; (UT_ZERO - meas) / UT_STEP
            pop     R9                      ; Restore stress_so_far
            pop     R10                     ; Restore measurement
			cmp		R8,R9					; Is low temp stress worse than stress_so_far?
			_IF		_LO
				mov		R8,R9					; Yes, new stress_so_far
				mov		R10,Rmeas				; Tentative measurement causing worst stress
				mov		#'t',Rtype				; Low temperature (lower case 't') is type
			_ENDIF

			; Link measurement, if appropriate
			push	R9						; Save stress_so_far
			call	#linkV					; Get link voltage in mV in R10
			cmp		#9999,R10				; Special "invalid" value?
			_IF		_NE						; Only calculate link stress if not this value
				push	R10						; Save linkV measurement
				tst		R10
				_IF		_L						; Get absolute value
					inv		R10
					inc		R10
				_ENDIF
				; Link stress: 1 for every 50 mV over 100 mV
				sub		#100-49,R10
				_IF		_L
					clr		R10						; Minimum of 0
				_ENDIF
				mov		R10,R9
				clr		R10
				mov		#50,R8
				call	#UMSlashMod
				mov		R9,R8					; Link stress in R8
				pop		R10						; Restore linkV measurement
				pop		R9						; Restore stress_so_far
				cmp		R8,R9					; Is stress_so_far less than link stress?
				_IF		_LO
					mov		R8,R9					; Yes, new stress_so_far
					mov		R10,Rmeas				; Tentative measurement causing worst stress
					mov.b	#'L',Rtype				; Tentative type of measurement causing worst bad
				_ENDIF
			_ELSE
				pop		R9						; Restore stress_so_far
			_ENDIF

			cmp		#STRESS_MASK,R9			; Is the stress_so_far worse than we can fit in status byte?
			_IF		_GE
				mov		#STRESS_MASK,R9			; Yes, use maximum we can fit
			_ENDIF

			; Receive (comms) stress: 1 if no status RX for 10 ticks and we are not ID 1
			bit.b	#bNotSendStatus,&monFlags ; Are we sending status?
			_IF		_Z						; If not, there can't be a receive stress
				cmp.b	#10,&ticksSinceLastRx	; Been 10+ ticks since last Rx?
				_IF		_C
					cmp.b	#1,&ID					; Only if ID
					_IF		_NE						;	is not 1 ...
						tst		R9						; Yes, are we at stress zero?
						_IF		_Z
							mov		#1,R9					; Yes, make it 1 for the comms error
							mov.b	&ticksSinceLastRx,Rmeas	; Tentative measurement causing worst stress
							mov.b	#'R',Rtype				; Tentative type of measurement causing worst bad
						_ENDIF
					_ENDIF
				_ENDIF
			_ENDIF

			mov.b	R9,R8					; Local stress
			movBits_B R8,#STRESS_MASK,&localStatus	; Record for later use, preserving bypass bits
			cmp.b	&worstStress,R9
			_IF		_HS						; If localStatus equal or higher than worstStress
                tst.b   R9                      ; and if it's an actual, nonzero error
                _IF     _NZ
				    mov.b	R9,&worstStress			; Update worstStress
				    mov		Rmeas,&worstStressMeas	; Update value of measurement causing worst stress
				    mov.b	Rtype,&worstStressType	; Update type of measurement causing worst stress
                _ENDIF
			_ENDIF

			cmp.b		#minLEDStress,R9	; Turn on the error LED if stress is minLEDStress or more
			CtoAllBits	Rtos
            call        #_errorLed          ; Use this function so it optionally turns on the piezo as well

			bit.b	#bNotSendStatus,&monFlags ; If bNotSendStatus is false
			_IF		_Z
				mov.b	&lastSentStatus,R8		; Get last stress and bypass bits we sent
				and.b	#STRESS_MASK,R8			; Clear other than stress bits
				cmp.b	R9,R8					; Is the current stress worse than the last stress we sent?
				; We could change the jnc below to a jne if we wanted to send out-of-cycle messages
				;	about a new lower stress (as well as higher).
				;	However, it's possible that these messages could overwhelm
				;	the communications system, in the situation of a sudden series of high power pulses.
				jnc		sendStatusNow				; Jump if so to send the stress immediately

				; We don't want to send status unless we are a (temporary) master, and it is time to send.
				; We are a temporary master if there have been 10+ ticks since our last Rx
				cmp.b	#10,&ticksSinceLastRx	; Been 10+ ticks since last Rx?
				_IF		_NC						; If no carry, then no, we are not a master
					ret								; So exit, no send
				_ENDIF
sendStatusNow
				cmp.b	#10,&ticksSinceLastRx	; Been 10+ ticks since last Rx?
				_IF		_C						; If carry, then yes, we are a master
					; Master bypass logic: if we are bypassing, set the all-in-bypass bit
					bit.b	#BYPASS,&P2OUT		; Are we bypassing?
					_IF		_NZ
						bis.b		#1<<5,R9		; Yes, set all-in-bypass bit
					_ENDIF
				_ELSE							; Else, we are not a master
					; Non-master logic: if bypassing, copy all-in-bypass from incoming
					; else (not bypassing) leave all-in-bypass clear
					bit.b		#BYPASS,&P2OUT		; Are we bypassing?
					_IF		_NZ
						bis		#1<<3,R9			; Yes, set some-in-bypass bit
						mov.b	&localStatus,R8		; Incoming bypass bits
						and		#1<<4,R8			; Incoming all-in-bypass bit
						bis		R8,R9				; Copy to R9
					_ENDIF
				_ENDIF
				mov.b	R9,&lastSentStatus		; Update remembered value
				mov.b	R9,R10
				and.b	#STRESS_MASK,R10		; Just stress bits in R10
				mov.b	stressTable(R10),R8		; Encode the present stress and bypass bits in R8
				and.b	#$60,R9					; Just comms error and bypass bits in R9
				bis.b	R9,R8					; Copy comms error and bypass bits to R8
				bis.b	#$80,R8					; Set the high bit to say it's a status byte
				call	#TX_ByteNW
			_ENDIF							; Endif bNotSendStatus is false
			ret
; End of measurement


;
;	Process received status byte in R8. Trashes R9, R10
;	Status byte:
;	 Bit 7: Always 1 for status byte
;	 Bit 6: Comms error: status information is incomplete
;	 Bit 5: All in bypass (will be some in bypass for bottom balancing)
;	 Bits 4-3: check bits
;	 Bits 2-0: stress level 0-7
;
DoStatus:
			clr		&ticksSinceLastRx		; Now no time since last received status
			mov.b	R8,R9					; Copy incoming stress to R9
			mov.b	R8,R10					; And R10
			and		#STRESS_MASK,R10		; Consider only stress bits in R10
			and		#ENC_STRESS_MASK,R8		; Only stress and check bits in R8
			cmp.b	R8,stressTable(R10)		; Is it valid? (Tested after 2 intervening instructions)
			mov.b	&localStatus,R8			; Get local status to R8
			bic.b	#$F8,R8					; Clear off non-stress bits (does not affect flags)
			_IF		_EQ						; If incoming is a valid stress byte
				cmp.b	R10,R8					; Compare incoming stress (R10) to ours (R8)
				_IF		_HS						; If we (R10) are worse than incoming (R8)
			_CS_SWAP						; [ Make the next _ENDIF apply to the _IF _EQ ]
			_ENDIF							; Endif incoming valid
					mov		R8,R10					; Incoming not valid or we are worse; use our stress
				_ENDIF							; Endif we are worse

;
; Process incoming bypass bit
;
			bit.b	#BYPASS,&P2OUT			; Test if we are in bypass now
			_IF		_NZ						; If bit is nonzero (i.e. we are bypassing)
				mov.b	R9,R8					; copy
				and.b	#1<<5,R8				; the all-in-bypass bit from incoming
				bis.b	R8,R10					; to R10
			_ENDIF
;
; Process incoming comms error bit. Since we received a status byte, we are not generating a local
;	comms error, so just copy incoming comms error bit
;
			mov.b	R9,R8
			and.b	#1<<6,R8				; Incoming comms error bit
			bis.b	R8,R10

			mov.b	R10,&lastSentStatus		; Remember that we sent this
			mov.b	R10,R8
			and.b	#STRESS_MASK,R10		; Just stress bits for index
			bis.b	stressTable(R10),R8		; Encode the present stress and bypass bits
			bis.b	#$80,R8					; Set the high bit to say it's a status byte
			call	#TX_ByteNW				; Send this encoded data if buffer not full
			ret

;
; Check for a password character
; After decrementing passWordState below, 3 = waiting for ^C, 2 = waiting for ^B, 1 = waiting for ^A,
; 0 = waiting for ^@ and erase if received. We should not receive any negative value
; Trashes R9
;
DoPassword:
			dec.b	&passWordState
			jn		resetFSM			; This should never happen! Just reset FSM and
										; process as an ordinary command

			; Check for a continuing password match
			mov.b	&passWordState,R9	; Password is ^C ^B ^A ^@
			cmp.b	R9,R8				; Check for a match
			jne		resetFSM			; If mismatch, jump and reset FSM
			tst		R9					; Are we now at state 0?
			jnz		exitOnRx			; If not, this was a valid password byte, but not the last.
										;	Just exit this callback and wait for more
			; Jump to the code in the BSL which will erase main flash memory and wait for more bytes
			;	without using interrupts.
			; May be important: it could be bad to have receive interrupts sending stress bytes after
			;	this last password byte goes out; it could be interpreted as a byte to flash program!
			clr		&TACCTLr			; Clear at least the CCIE RX interrupt enable bit
			; Important: wait for the last password byte to be echoed before disabling interrupts!
			call	#waitTxCmpl

			dint
			clr		&TACTL				; Disable the timer completely; may use less power
			mov.b	#TXDp+ACTLED,&P1OUT	; Set TXD to idle, (inverted) activity LED off
			clr.b	&P2OUT				; Set bypass and error LED off
			clr.b	&P1SEL				; Make P1.1 ordinary I/O now
			bic.b	#USIPE5,&USICTL0	; Make P1.5 ordinary I/O also
			clr		R15					; The BSL uses R15 as its FSM state variable
			mov		#$280,SP			; Give the BSL maximum stack
			br		#BSLErase			; Jump into the BSL to finish the download

resetFSM	mov.b	#4,&passWordState	; No password match; reset state machine

exitOnRx	ret

			EVEN


DELAY_IF_NEEDED MACRO
			; No delay needed
			ENDM

#include "serialio.s43"				// Comms routines
#include "../common/comMisc.s43"	// Miscellaneous common functions
#include "../common/measure.s43"	// Voltage measurement functions
#include "../common/BytecodeInterpreter2.s43" // Cutdown bytecode interpreter. No defs in bytecode
#include "../common/math.s43"		// Multiply and divide routines
#include "monDefinitions.s43"		// Bytecode definitions

			; Encoded stress table. The stress and other information is transmitted in one status byte,
			; with no checksum correction. To counter this, stress is encoded, so that only
			; 16 of the 32 possible stress codes ($00 - $1F) are valid. Other codes
			; are treated as a corrupted attempt to send status information.
			; Current status for this BMU is sent instead.
			; Note that bit 7 is always set for status bytes; bit 6 represents comms error
			; Bit 5 represents all-in-bypass
			; Note that encoded stress values are not monotonic
			; The table is indexed by raw stress values
stressTable	DB		(1<<4) + 0			; Stress 0   $10
			DB		(1<<4) + 1			; Stress 1   $11
			DB		(1<<4) + 2			; Stress 2   $12
			DB		(1<<4) + 3			; Stress 3   $13
			DB		(1<<4) + 4			; Stress 4   $14
			DB		(1<<4) + 5			; Stress 5   $15
			DB		(1<<4) + 6			; Stress 6   $16
			DB		(1<<4) + 7			; Stress 7   $17
			DB		(0<<4) + 8			; Stress 8   $08
			DB		(0<<4) + 9			; Stress 9   $09
			DB		(0<<4) + 10			; Stress 10  $0A
			DB		(0<<4) + 11			; Stress 11  $0B
			DB		(0<<4) + 12			; Stress 12  $0C
			DB		(0<<4) + 13			; Stress 13  $0D
			DB		(0<<4) + 14			; Stress 14  $0E
			DB		(0<<4) + 15			; Stress 15  $0F
			

; The linker puts a checksum of the used code memory in the first available unused space,
; when asked for one.
; To keep our BSL (bootstrap loader) happy we need a simple 1-byte XOR checksum.
; To obtain this we set the IAR Embedded Workbench IDE Project/Options/Linker/Checksum options to:
; Fill unused code memory
; 	Fill pattern: 0xFF
;	Generate checksum
;		Size: 1 byte, Alignment: 1
;		CRC Polynomial: 0x101
; 		Complement: As is
;		Bit order: MSB first, Initial value: 0x10
; The initial value of 0x10 is required because the reset vector of $1000 at $FFFE is not transmitted
; and so the BSL does not include it in its checksum, but the linker does.
; If the reset vector changes, this initial value will need to be changed to keep it as
; the XOR of its two bytes.

; And we set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	monitor.bin
;	Output format: raw-binary

; Some calculations so we can see how much space we have left, by reading the listing.
freespace	EQU		_OPCODETBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/2048)

;-------------------------------------------------------------------------------
;			Interrupt Vectors
;-------------------------------------------------------------------------------
			ORG		0FFF0h				; Timer A Vectors
			DW		RX_TIOV_ISR			; Combined CC1IFG (receive capture/compare) & TAIFG (overflow)
			DW		TX_ISR				; Timer A CC0IFG (transmit compare)


			ORG		$FFF8
jInterpretByte:
            br      #interpretByte      ; BSL will call here expecting interpretByte
			ORG		0FFFEh				; MSP430 RESET Vector
			DW		0x1000				; Reset to BSL in case there is a crash


			END
