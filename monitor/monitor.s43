			COL		154				; Wide listings
;
; Branch: Rev61
; CMUs and IMUs use MSP430G2452 microcontroller, BMUs use MSP430G2553.
; As used in Mike's solar (24 V and 48 V), Helidon off-grid solar power system, Kingscliff Demand
; Charge Management system, Kingscliff off-grid solar power system.
;
; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve calibration data.
;
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Output options to:
;  Allow C-SPY-specific extra output file
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	monitor.bin
;	Output format: raw-binary
;
; This software has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; "Monitor" is the standard electric-vehicle operating software for our Cell Management Unit (CMU)
; and Battery Management Unit (BMU) based on an MSP430 microcontroller.

#define MONITOR					// For some conditional assembly in otherwise common
								// insulation-monitoring code.

#define	G2553		0			// MSP430 model. True for BMUs, false for CMUs and IMUs.
								// You must also set IAR/Project/General Options/Target/Device correctly
			LSTOUT-
#include "msp430.h"							// MSP430 Special Function Register definitions
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Assembler macros for obscure instruction sequences
DELAY_IF_NEEDED MACRO
			; No delay needed
			ENDM
			LSTOUT+
#include "../common/common.h"				// Definitions common to monitor, TestICal and BSL

; Some definitions so the measure.s43 code will work
; TestICal defines these as their RAM counterparts instead of info-flash
VoltCal 	EQU	infoVoltCal
TempCal		EQU	infoTempCal
LinkCal		EQU	infoLinkCal


			NAME	main			; Module name
			PUBLIC	main			; Make the "main" label visible for IAR debugger


ID			EQU		infoID			; We use the info-flash copy of the ID for s, x, prettyPrint
									; commands. TestICal uses the ram copy

; Conditional assembly
#define		WATCHDOG	1			// True if watchdog timer is to be used (only turn off for debuging)
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer.
									// Buffered ADC is mainly useful for debugging.

; Couldn't fit both masterless charging and insulation monitoring in 4k.
#define		MASTERLESS_CHARGING 1	// Can leave out the masterless charging code if not needed.
#if G2553
#define		INSULATION_MONITORING 1	// Can leave out the insulation monitoring code if not needed.
#else
#define		INSULATION_MONITORING 1	// Can leave out the insulation monitoring code if not needed.
#endif

; Constants

; Stress calculations
; The stress set-point for both charger and motor controller back-off is 7.
; This set-point of 7 is implemented in the DCUs.
; So 8 is the lowest dis-stress. Alarm is given at stress 11 or more.
#define WHINGE 0
#if !WHINGE
// OV = Over Voltage: One stress unit for each 20 mV in excess of 3.350 V, to a max of 15 at >= 3.65 V
// OV setpoint is 3.49 to 3.50 V. Alarm at 3.57 V.
OV_ZERO		EQU		3350		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		20			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 80 mV below 3.250 V, to a maximum of 15 at <= 2.05 V
// UV setpoint is 2.69 to 2.61 V. Alarm at 2.37 V.
UV_ZERO		EQU		3250		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-80		; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 40C, to a max of 15 at >= 55degC
// OT setpoint is 47 to 48 degC. Alarm at 51 degC.
OT_ZERO		EQU		40			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		1			; Degrees C difference between one OT stress level and the next
// UT = Under Temperature: One stress unit for every 1 degree C below 11C, to a max of 15 at <= -4degC
// UT setpoint is 4 to 3 degC. Alarm at 0degC.
UT_ZERO		EQU		11			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-1			; Degrees C difference between one UT stress level and the next
// AL = Absolute Link voltage: Disabled because the hardware does not measure it reliably.
// Plan to implement positive and negative bolt voltages in future.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		3000		; mV difference between one AL stress level and the next

#else
// OV = Over Voltage: One stress unit for each 10 mV in excess of 3.500 V, to a max of 15 at >= 3.65 V
// OV setpoint is 3.57 to 3.58 V. Alarm at 3.61 V.
OV_ZERO		EQU		3400		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		10			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 40 mV below 2.500 V, to a maximum of 15 at <= 1.90 V
// UV setpoint is 2.18 to 2.22 V. Alarm at 2.06 V.
UV_ZERO		EQU		3200		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-50			; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 40C, to a max of 15 at >= 55degC
// OT setpoint is 47 to 48 degC. Alarm at 51 degC.
OT_ZERO		EQU		40			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		1			; Degrees C difference between one OT stress level and the next
// UT = Under Temperature: One stress unit for every 1 degree C below 11C, to a max of 15 at <= -4degC
// UT setpoint is 4 to 3 degC. Alarm at 0degC.
UT_ZERO		EQU		11			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-1			; Degrees C difference between one UT stress level and the next
// AL = Absolute Link voltage: One stress unit for every 20 mV above 0 mV, to a max of 15 at >= 300 mV
// AL setpoint is 140 to 160 mV. Alarm at 220 mV.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		3000		; mV difference between one AL stress level and the next
#endif

; FULLLEV	EQU	OV_ZERO+5*OV_STEP	; Considered Full (charge termination and coulomb counter reset)
									;	3450 mV. Stress 4/5 threshold
; BYPLEV	EQU	OV_ZERO+6*OV_STEP	; Bypass threshold 3470 mV. Corresp. to stress 5/6 threshold

MinLEDStress EQU	11			; Minimum stress to light error LED
MinAlrmStress EQU	11			; Minimum stress to sound alarm	(not in use yet)

ComErrTicks	EQU		9			; Minimum ticks without receiving valid status byte before
								;	taking on master duties and reporting comms error (if ID not 1)

; Status byte bit masks - Used for localStatus in RAM as well as RXed and TXed status bytes
COM_ERR		EQU		1<<6			; Communications error
ALL_FULL	EQU		1<<5			; All considered full -- charge termination and DoD counter reset
ENC_STRESS	EQU		$1F				; Encoded stress. Bits 0-4. Bit 4 is a check bit
STRESS		EQU		$0F				; Raw stress. Bits 0-3


;
; RAM allocation
;
				ORG		$200		; Start of RAM. Ends at InitSP-1
; This area is common to both Monitor and TestICal and is not erased on a reset
bsl2state		DS		2			; Password recogniser state for BSL2
resetCounter	DS		2			; Number of resets since the last "^" command
resetBuffer		DS		16			; Circular buffer recording the reason for the last 16 resets
discharge		DS		4			; Accumulator for depth of discharge determination.
									; Unit is 1/5 A for 1/15 s = 1/75 coulomb = 1/270 milliamphour.
									; So 32 bits allows 15,900 Ah, but 24 bits would only allow 62 Ah.
comNoEraseEnd

#if	ADCBUF
				ALIGNRAM 1
sampleBuf		DS		2*NumSamples ; ADC sample buffer; 4 or 16 samples
#endif

monFlags		DS		1			; Monitor flags, bitmask definitions follow
bNotSendStatus	EQU		1<<0		; Zero if sending status bytes at all
bNotMeasureTime EQU		1<<1		; Zero if time to measure
bCharging		EQU		1<<2		; 1 if charging or regen. See 'c' command.
bChargerControl	EQU		1<<3		; 1 in charger control mode (masterless operation). See 'o' command.
bBadInsulation	EQU		1<<4		; 1 if the last insulation test failed. (IMU only)

localStatus		DS		1			; Bits 0-3 stress, 4 check-bit, 5 all-full, 6 comms error
ticksSinceLastRx DS		1			; Timer overflow events since last valid status received
statusFreqCtr	DS		1			; To time various infrequent tasks in DoMeasurement. Allowed to wrap
ticks			DS		1			; To time various medium frequency tasks. Allowed to wrap
passWordState	DS		1			; State machine for password recogniser

; Charger controller variables

chargerTxTimer	DS		1			; To keep charger packet transmission to the minimum required.
				ALIGNRAM 1
chargerVoltLim	DS		2			; Charger voltage limit (tenths of a volt). Set by 'o' command.
chargerCurrLim	DS		2			; Charger current limit (tenths of an amp). Set by 'o' command.
piPrevOutput	DS		2			; State of PI controller
piPrevError		DS		2			; State of PI controller
chargerPrevCurr	DS		2			; Charger previous current (tenths of an amp). Set by PI controller.
BatCapacity		EQU		400			; Battery capacity in tenths of an amp-hour

; Serial-io variables
	; Cell monitoring units comms variables
	; Note that the CMU variables have no prefix while the others have "scu" and "chg".
				ALIGNRAM 1
txBitTime		DS		2			; Determines transmit baud rate for timer-based comms (not UART).
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
txData			DS		2			; Byte to transmit in lower byte; always $FF in high byte
rxData			DS		1			; Received char
bitCntTx		DS		1			; Bit count 10 -> 1
bitCntRx		DS		1			; Bit count 8 -> 1
txCksum			DS		1			; Transmit checksum

RxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
TxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
rxBuf			DS		RxSz		; Receive queue buffer
rxWr			DS		1			; Receive queue write index
rxRd			DS		1			; Receive queue read index
txBuf			DS		RxSz		; Transmit queue buffer
txWr			DS		1			; Transmit queue write index
txRd			DS		1			; Transmit queue read index

#if G2553
	; System control unit comms variables
				ALIGNRAM 1
scuTxBitTime	DS		2			; Determines transmit baud rate. 104 for 9600 baud, 417 for 2400 bd
scuTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
scuRxData		DS		1			; Received char
scuBitCntTx		DS		1			; Bit count 10 -> 1
scuBitCntRx		DS		1			; Bit count 8 -> 1
scuTxCksum		DS		1			; Transmit checksum

ScuRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
ScuTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
scuRxBuf		DS		RxSz		; Receive queue buffer
scuRxWr			DS		1			; Receive queue write index
scuRxRd			DS		1			; Receive queue read index
scuTxBuf		DS		RxSz		; Transmit queue buffer
scuTxWr			DS		1			; Transmit queue write index
scuTxRd			DS		1			; Transmit queue read index

	; Charger/inverter comms variables
				ALIGNRAM 1
chgTxBitTime	DS		2			; Determines transmit baud rate. 104 for 9600 baud, 417 for 2400 bd
chgTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
chgRxData		DS		1			; Received char
chgBitCntTx		DS		1			; Bit count 10 -> 1
chgBitCntRx		DS		1			; Bit count 8 -> 1
chgTxCksum		DS		1			; Transmit checksum

ChgRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
ChgTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
chgRxBuf		DS		RxSz		; Receive queue buffer
chgRxWr			DS		1			; Receive queue write index
chgRxRd			DS		1			; Receive queue read index
chgTxBuf		DS		RxSz		; Transmit queue buffer
chgTxWr			DS		1			; Transmit queue write index
chgTxRd			DS		1			; Transmit queue read index
#endif

; Command Character Interpreter variables

rxCksum			DS		1			; Received packet xor checksum
interpFlags		DS		1			; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1<<0		; Should numeric output be in hexadecimal, not decimal?
bChecksumming	EQU		1<<1		; Are we sending checksums and checking received checksums?
bDontInterpret	EQU		1<<2		; Are we interpreting?
bDontEcho		EQU		1<<3		; Are we echoing at the character level?
bModbusOutput	EQU		1<<4		; Should PrettyPrint output be formatted as a Modbus/ASCII response?
bEchoResponses	EQU		1<<5		; True to echo complete Modbus responses

				ALIGNRAM 1
ovZero			DS		2			; Overvoltage zero, set by 'VP command (param1 - 7 * param2)
ovStep			DS		2			; Overvoltage step, set by 'VP command (param2)

				ALIGNRAM 1			; A kind of trip-meter for this cell's stress
worstStress		DS		1			; Worst local stress since the last resetWorstStress command
worstStressType	DS		1			; Type of measurement that caused worst stress
worstOV			DS		2			; Worst over-voltage since the last resetWorstStress command
worstUV			DS		2			; Worst under-voltage since the last resetWorstStress command
worstOT			DS		2			; Worst over-temperature since the last resetWorstStress command
worstUT			DS		2			; Worst under-temperature since the last resetWorstStress command
worstAL			DS		2			; Worst absolute link voltage since last resetWorstStress command
; The 5 variables above are also treated as an array indexed from worstStress, so order matters

				ALIGNRAM 1
ToIN			DS		2			; Pointer to present character being stored in Text Input Buffer
TIB				DS		48			; Text Input Buffer (packet buffer)
TIBEnd

TxBytePtr		DS		2			; Pointer to TxByte handler. Initially CmuTxByte

; Must leave room for stack (about 36 bytes minimum)
STACKSPACE		EQU		InitSP-$	; Look at listing to see what this is

;-------------------------------------------------------------------------------
				ORG		PROG_START	; In main-flash
;-------------------------------------------------------------------------------

#include "../common/InterruptComms.s43" // Comms routines
#include "../common/ComComms.s43"	// Common comms functions, e.g. TxCksum
#include "../common/measure.s43"	// ADC measurement functions
#include "../common/CmdCharInterpreter.s43" // RPN interpreter with single-character commands
#include "../common/math.s43"		// Multiply and divide routines
#include "monDefinitions.s43"		// Command character definitions

;-------------------------------------------------------------------------------
; InterpretInit
;-------------------------------------------------------------------------------

InterpretInit:                              ; This is called by the BSL, on reset.
InterpretByte:								; Should not be called -- but just in case
main:										; For IAR Embedded Workbench IDE debugger
			ClearWatchdog					; Clear and enable Watchdog Timer 32k cyc. BSL sets 64 cyc.
			mov.w	#InitSP,SP				; Initialize stackpointer

			; Clear all variables in RAM except resetBuffer and IMU/BMU's fuel-gauge dischg accumulator
			; and worstStress (and ToIN/TIB)
			_DO		#worstStress-comNoEraseEnd,R8
				clr		comNoEraseEnd-2(R8)
			_mLOOP	#2,R8

			; LOG2 -- The following preprocessor-macro gem is due to Dave Keenan.
			; It is based on a Taylor series expansion. It is valid for the domain 1-64, and range 0-6.
			; NOTE: It depends on the assembler rounding toward zero (truncated division).
			; There is a similar simple formula for rounding towards neg infinity (floored division).
			#define LOG2(x) (4 * (x-8) / (x+8) + 3)

			; Initialise clocks. SMCLK is only used by comms timer and watchdog timer.
			; DIVS_1 => SMCLK = DCOCLK/2	DIVS_2 -> SMCK = DOCLK/4
			; DIVM_1 => MCLK = DCOCLK/2
			mov.b	#DIVM_1+LOG2(DCOckPerSMck)*DIVS_1, &BCSCTL2
			mov.b	&info8MHzCalB,&BCSCTL1	; 8 MHz DCO cal data
			mov.b	&info8MHzCalD,&DCOCTL

#if G2553
			mov		#CmuTxByte,&TxBytePtr		; By default, TxByte goes to the CMU port

;
;	Initialise io ports
;
			; Initialise port 1
			; Default settings of P1SEL are OK. No UART comms in TestICal. Analog settings done later.
			mov.b	#TxPl,&P1OUT				; Set TxPl high (idle), all other outputs low.
			cmp.b	#255,&ID					; If we're not a BMU
			_IF		_NE
				mov.b	#VrefP|TxPl|TouchV_Byp,&P1DIR ; Set VrefP, Tx bits, bypass as outputs
			_ELSE								; Else
				mov.b	#VrefP|TxPl,&P1DIR			; Set VrefP, Tx bits as outputs
			_ENDIF
			mov.b	#Rx|TxPl,&P1SEL				; Select UART functions for Rx and TxPl pins
			mov.b	#Rx|TxPl,&P1SEL2

			; Initialise port 2
			mov.b	#0,&P2SEL					; Set bits 6, 7 not as xtal pins. No timer comms in TestICal
			mov.b	#0,&P2OUT					; Set all outputs low.
			mov.b	#RelayM|RelayP|TxMiScu|Piezo|ErrLed,&P2DIR ; Set Relays,Tx, Piezo, ErrLed as outputs
			mov.b	#RxScu|TxMiScu,&P2SEL		; Select timer functions for Rx and Tx pins, not piezo
												; Piezo SEL bit is only set by the errorLed function

			; Initialise port 3
			; Default settings of P3SEL are OK. No timer comms in TestICal.
			mov.b	#0,&P3OUT					; Set all outputs low.
			mov.b	#PreCont|BatCont|ChgCont|TxMiChg|DisCont|NrmCont|TxMi,&P3DIR ; Set Txs, conts as out
			mov.b	#RxChg|TxMiChg,&P3SEL		; Select timer functions for Rx and Tx pins except TxMi
			bis.b	#TxMi,&P3SEL				; Select the comparator output function of P3.7

;
;	Initialise timer and interrupt comms
;
			; Use the Analog Comparator to get an inverted version of TxPlIn (P1.3/CA3)
			; (which is the UART TxPl looped back) to appear on TxMi (P3.7/CAOUT).
			mov.b	#CAON|CAREF_2,&CACTL1		; Half-supply to the comparator pos input and turn it on
			mov.b	#P2CA2|P2CA1,&CACTL2		; Feed CA3 to the comparator neg input
			mov.b	#TxPlIn,&CAPD				; Disable the digital input buffer of P1.3

			; Initialise the UART
			bis.b	#UCSWRST,&UCA0CTL1			; Need while initialising other USCI registers
			mov.b	#0,&UCA0CTL0			 	; UART mode, 8 bits, 1 stop bit, no parity
			mov.b	#UCSWRST | UCSSEL_2 ,&UCA0CTL1 ; Use SMCLK
			mov.b	#104,&UCA0BR0 				; Set 9600 baud
			mov.b	#0,&UCA0BR1
			mov.b	#UCBRS_1,&UCA0MCTL
			bis.b	#TxPl,&P1SEL				; Select the UART output function of P1.2
			bis.b	#TxPl,&P1SEL2
			bic.b	#UCSWRST,&UCA0CTL1			; No longer resetting UCSI, clear to run
			bis.b	#UCA0RXIE, &IE2				; Enable UART RX interrupts

			; Initialise the Timers
			; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
			; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
			; MC: 2 = continuous mode 1 = up mode
			; TAIE = interrupt enable (for timer overflow)
			mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2 + TAIE, &TA0CTL
			mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2, &TA1CTL

			mov.w	#OUTMOD_4|CCIE,&PizCCTLp	; Piezo CCR in Compare mode, "toggle" output mode

			mov.w	#OUTMOD_5, &ScuCCTLt		; Initialise transmit capture/compare register
			mov.w	#BitTime96,&scuTxBitTime	; Set the bit time for 9600 baud
			mov.b	#$FF,&scuTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
			mov.b	#8,&scuBitCntRx				; Load Rx bit Counter, 8 data bits
;			clr.b	scuTxCksum					; Clear transmit checksum. Already cleared by loop above
			mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ScuCCTLr	; Falling edge, Input A, Sync, Capture

			mov.w	#OUTMOD_5, &ChgCCTLt		; Initialise transmit capture/compare register
			mov.w	#BitTime96,&chgTxBitTime	; Set the bit time for 9600 baud
			mov.b	#$FF,&chgTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
			mov.b	#8,&chgBitCntRx				; Load Rx bit Counter, 8 data bits
;			clr.b	chgTxCksum					; Clear transmit checksum. Already cleared by loop above
			mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ChgCCTLr	; Falling edge, Input A, Sync, Capture
#else // G2452
;
;	Initialise io ports
;
			mov.b	#TxPl,&P1OUT			; Set TxPl. Short the piezo.
			mov.b	#VrefP|TxPl|TxMi|Piezo,&P1DIR ; Set VrefP, Tx bits and piezo as outputs
			mov.b	#0,&P2SEL					; Set Bypass and ErrLed to not be crystal osc pins
			mov.b	#0,&P2OUT					; Set Bypass and ErrLed off (RLY- and RLY+ if IMU)
			mov.b	#$FF,&P2DIR					; Set Bypass and ErrLed as outputs
;
;	Initialise timer and interrupt comms
;
			mov.b	#Rx+TxMi,&P1SEL				; Select timer functions CCI1A and TA0 (not I/O port)

			; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
			; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
			; MC: 2 = continuous mode 1 = up mode
			; TAIE = interrupt enable (for timer overflow)
			mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2 + TAIE, &TACTL

			; Set up differential timer outputs for transmit data.
			; Tricky way of getting inverted TA0 to appear on P1.5 automatically
			; when TA0 appears on P1.1.
			; We use the clock inverter in the USI (Universal Serial Interface)
			; to invert TA0 and put it out as SCLK, in SPI master mode.
			; We don't use the shift register of the USI because there is
			; no way to get differential outputs from that without external hardware.
			mov.b	#USIPE5 + USIMST, &USICTL0	; SCLK out on P1.5, SPI Master mode, remove SW Reset
			mov.b	#USIDIV_0 + USISSEL_5 + USICKPL, &USICKCTL ; SCLK source is TA0, div by 1, inverted
			mov.b	#8, &USICNT					; To clear USIIFG so SCLK will not be held

			; Make TA0 (output of Timer-A capture/compare unit 0) appear on P1.1
			; We want to set the CCIFG so that TxByte won't think there's an uncompleted stop bit
			; and wait for it to complete.
			mov		&TAR,&CCRt					; Make an output event
			add		#4,&CCRt					;	happen in a dozen or so instructions
			; NOTE: the above has to be enough to get past setting of OUTMOD_5 for CCTLt below
			mov.w	#OUTMOD_0 + OUT, &CCTLt		; TA0=1 Space; seems necessary to "wake up" SCLK divider
			mov.w	#OUTMOD_5, &CCTLt			; When the compare happens, set TA0=0 Idle or Mark

			mov.w	#BitTime96,&txBitTime		; Set the bit time for 9600 baud
			mov.b	#$FF,&txData+1				; Initialise the top half of txData to all 1s (stop bit,
												;	idle bit)
			mov.b	#8,&bitCntRx				; Load Bit Counter, 8 data bits
;			clr.b	txCksum						; Clear transmit checksum. Already cleared by loop above
			mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&CCTLr	; Falling edge, Input A, Sync, Capture

			; Prepare ACLK for piezo drive -- approx 3 kHz square wave
			bis.b	#LFXT1S_2,&BCSCTL3			; Select VLOCLK (~12 kHz) as source for ACLK divider

#endif
			; Already cleared by loop above
;			clr.b	&rxWr						; Initialise the Tx and Rx queue indexes
;			clr.b	&rxRd
;			clr.b	&txWr
;			clr.b	&txRd

;
; Initialise the charger controller
;
			; Already cleared by loop above
;			clr.b	&chargerTxTimer				; Initialise charger transmit timer
;			clr.w	&chargerVoltLim				; Initialise charger voltage limit
;			clr.w	&chargerCurrLim				; Initialise charger current limit
;			clr.w	&piPrevOutput				; Initialise PI controller state
;			clr.w	&piPrevError				;
;			clr.w	&chargerPrevCurr			; Initialise charger current

			mov.w	#OV_ZERO,&ovZero
			mov.w	#OV_STEP,&ovStep

;
; Initialise the ADC10
;
			cmp.b	#0,&ID						; If we're not an IMU (Insulation Monitoring Unit)
			_IF		_NE
				; Enable cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				mov.b		#(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ELSE
				; Enable touchV, cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				mov.b		#(1<<TouchVChan)|(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ENDIF
			; Initialise ADC10
			; SREF_1	= +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temp)
			; REFOUT	= connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			mov			#SREF_1+ADC10SHT_3+REFOUT+REFON,&ADC10CTL0
			; Other ADC10 initialisation is done every time "measure" is called, to save code space

;
; Initialise the command character interpreter
;
			;	Already cleared by loop above
;			clr.b	&rxCksum				; Clear received packet xor checksum
;			clr.b	&interpFlags				; Clear Interpreter flags
;			bic.b	#bHexOutput,&interpFlags	; Default numeric output to be in decimal, not hexadecimal
			bis.b	#bChecksumming,&interpFlags ; Default to sending checksums and checking recved chksums
;			bic.b	#bDontInterpret,&interpFlags ; Do interpret
;			bic.b	#bDontEcho,&interpFlags	; Do echo
			mov		#TIB,&ToIN				; Initialise write pointer into text input buffer

;
; Miscellaneous initialisation
;
			mov.b	#4,&passWordState		; Waiting for first byte of ^G ^F ^E ^D sequence
			eint							; Enable interrupts now that all initialisation is complete

; Main loop
			_BEGIN
				call	#RxByteNoWait			; Check if received data
				_IF		_NZ
					tst.b	R8
					_IF		_NN
						call	#DoEcho					; Echo the command or password byte if required
						call	#DoPassword				; Check for password bytes
						call	#ACCEPT					; Process command bytes (could take a long time)
					_ELSE
						call	#DoStatus				; Forward possibly-updated status bytes
					_ENDIF
				_ELSE
					bit.b	#bNotMeasureTime,&monFlags	; Check if time to measure
					_IF		_Z							; If so, do measurement and set/clear of bypass
						bis.b	#bNotMeasureTime,&monFlags	; Reset the time-to-measure flag
						call	#DoMeasurement			; May transmit status
					_ELSE
						mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer before sleeping CPU
						bis		#CPUOFF+GIE,SR			; Turn off CPU and ensure intrupts still enabled
					_ENDIF
				_ENDIF

			ClearWatchdog				; Clear and restart Watchdog Timer each time around main loop

			_AGAIN
; End of main loop


DoEcho:		_COND							; Begin short circuit conditional
				cmp.b	#$11,R8
			_OR_ELSE	_EQ					; If it's an XON (ctrl-Q) character OR Else
				bit.b	#bDontEcho,&interpFlags
			_OR_IFS		_Z					; Or If the dont-echo flag is clear
				call	#TxByte					; Echo the character
			_ENDIF
			ret
; End of DoEcho


DoMeasurement:
;
; Regular measurement. Called StatusFreq times per second (2-16 times per second, see InterruptComms.s43)
;
#define Rstrs R12				// Worst stress (present, not trip)
#define Rmeas R14				// Measurement causing worst stress
#define Rtype R15				// Type of measurement causing worst stress

			inc.b	&statusFreqCtr			; Used to time various infrequent tasks. Allowed to wrap.
			clr		Rstrs					; Init present stress to zero
			clr		Rmeas					; Init measurement causing zero stress to zero
			clr		Rtype					; Init type of measurement causing zero stress to zero

			inc.b	&ticksSinceLastRx		; Cleared whenever valid stress byte received
			_IF		_C						; If unsigned overflow
				mov.b	#$FF,&ticksSinceLastRx	; Saturate at $FF
			_ENDIF

			; Do cell voltage measurement
			call	#cellV					; Get cell voltage in mV in R10
			push	R10						; Save measurement for undervoltage stress calc

			; Set bypass as required
			cmp.b	#0,&ID					; If we're not an IMU
			_IF		_NE
				mov			&ovStep,R9			; Calc the bypass threshold in R9 = ovZero + 6*ovStep
				rla3		R9
				add			&ovZero,R9
				sub			&ovStep,R9
				sub			&ovStep,R9
				cmp			R9,R10				; Compare present cell voltage (R10) to bypass threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#Bypass,&P2OUT	; Move only the #Bypass bit from R8 to &P2OUT. Trashs R8
				sub			&ovStep,R9			; Calculate the full (charge termination) threshold
												;	One level below bypass (cf. one above for monolith)
				cmp			R9,R10				; Compare cell voltage (R10) to the full threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#ALL_FULL,&localStatus ; Move only #ALL_FULL bit from R8 to &localStatus.
			_ELSE
				bis.b		#ALL_FULL,&localStatus	; IMU must pretend it's full so charge terminates
			_ENDIF

			; Calculate stress due to overvoltage
			push	R10						; Measurement for overvoltage stress calc
			push	&ovStep					; For every ovStep (millivolts)
			push	&ovZero					;	over ovZero, we add one level of stress
			push	#1						; Type of measurement
			call	#DoStress				; Update Rstrs Rmeas Rtype if non-zero stress due to OV

			; Calculate stress due to undervoltage if required
			cmp.b	#0,&ID					; If we're not an IMU
			_IF		_NE
				bit.b	#bCharging,&monFlags	; And we're not charging (including not regen braking)
				_IF		_Z
													; Measurement saved on stack earlier
					push	#UV_STEP				; For every UV_STEP (millivolts)
					push	#UV_ZERO				;	below UV_ZERO, we add one level of stress
					push	#2						; Type of measurement
					call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to UV
				_ELSE
			_END_PRIOR_IF
					pop		R10						; Drop unused voltage measurement off stack
				_ENDIF

			; Do temperature measurement
			call	#temp					; Get temperature in degrees Celsius in R10
			push	R10						; Save measurement for undertemperature stress calc

			; Calculate stress due to overtemperature
			push	R10						; Measurement for overtemperature stress calc
			push	#OT_STEP				; For every OT_STEP (degrees Celsius)
			push	#OT_ZERO				;	over OT_ZERO, we add one level of stress
			push	#3						; Type of measurement
			call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to OT

			; Calculate stress due to undertemperature if required
			bit.b	#bCharging,&monFlags	; If charging (including regen braking)
			_IF		_NZ
												; Measurement saved on stack earlier
				push	#UT_STEP				; For every UT_STEP (degrees Celsius)
				push	#UT_ZERO				;	below UT_ZERO, we add one level of stress
				push	#4						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to UT
			_ELSE	; not charging; temp measurement still on stack
				pop		R10						; Drop unused temp measurement off stack
			_ENDIF

			; Calculate stress due to link voltage (current shunt measurement for an IMU)
			call	#linkV					; Get link voltage in mV in R10
			cmp.b	#0,&ID					; If we're not an IMU
			_IF		_NE
#if 0			// Don't treat link voltage as stress for now, as the circuitry is too noise prone.
				cmp		#9999,R10				; Special "invalid" value?
				_IF		_NE						; Only calculate link stress if not this value
					; Calculate stress due to excessive absolute link voltage
					tst		R10						; Get absolute value of link voltage
					_IF		_L
						inv		R10
						inc		R10
					_ENDIF
					push	R10						; Measurement for absolute link stress calc
					push	#AL_STEP				; For every AL_STEP (millivolts)
					push	#AL_ZERO				;	over AL_ZERO, we add one level of stress
					push	#5						; Type of measurement
					call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to AL
				_ENDIF
#endif
			_ELSE	; IMU
				// Sign extend R10 to 32 bits in R10:R9
				mov		R10,R9						; Make a copy
				rla		R10							; Shift sign bit to carry
				subc	R10,R10						; 0 if R9 is negative, -1 otherwise
				inv		R10							; -1 if R9 is negative, 0 otherwise

				sub		R9,&discharge				; Integrate current in 32-bit discharge accumulator
				subc	R10,&discharge+2			; for fuel gauge
			_ENDIF

			; Update local present stress, and worst stress for trip so far
			mov.b	Rstrs,R8				; Copy stress. movBits_B instruction trashes its source.
			cmp		#STRESS,R8				; If the stress is worse than we can fit in status byte
			_IF		_HS
				mov		#STRESS,R8				; Use the maximum we can fit
			_ENDIF
			mov.b	stressTable(R8),R8		; Encode it with checkbit
			movBits_B R8,#ENC_STRESS,&localStatus ; Record for later use, preserving other status bits.
			cmp.b	&worstStress,Rstrs		; If stress equal or higher than worstStress for trip so far
			_IF		_HS
				tst.b	Rstrs					; and it's an actual, nonzero stress
				_IF	_NZ
					mov.b	Rstrs,&worstStress		; Update worstStress
					mov.b	Rtype,&worstStressType	; Update type of measurement causing worst stress
				_ENDIF
			_ENDIF

			; Update Alarm -- local red LED and piezo
			cmp.b		#MinLEDStress,Rstrs	; Turn on the error LED if stress is MinLEDStress or more
			CtoAllBits	Rtos
			bit.b		#bBadInsulation,&monFlags
			CtoAllBits	R8
			bis			R8,Rtos				; or if the last insulation test failed (IMU only)
			call		#_errorLed			; Use this function so it optionally turns on piezo as well

			; Check for comms error and send local status if required
			bic.b	#COM_ERR,&localStatus	; Clear comms error flag by default. May be set below.
			bit.b	#bNotSendStatus,&monFlags ; If sending status, and so expecting to receive it
			_IF		_Z
				cmp.b	#ComErrTicks,&ticksSinceLastRx ; and too many ticks since last valid status Rx
				_IF		_HS
					; If our ID is not 0 (IMU) or 1 (first CMU), set the comms error bit in local status
					; and send a comment with our ID followed by 'c' for comms error
					; every 256 status bytes (approx every 17 seconds).
					cmp.b	#2,&ID
					_IF		_HS
						bis.b	#COM_ERR,&localStatus
						tst.b	&statusFreqCtr
						_IF	_Z
							call	#_commsError			; Call pretty-printing command
						_ENDIF
					_ENDIF

					; Act as a master -- send our status
					mov.b	&localStatus,R8
					bis.b	#$80,R8					; Set the high bit to say it's a status byte
					call	#SendStatus				; Send status or control a charger
				_ENDIF							; End if too many ticks since last Rx
			_ENDIF							; End if sending status
			ret
; End of DoMeasurement


DoStress:
;
; Called 5 times by DoMeasurement to calculate the various kinds of stress
; and keep track of which is worse.
; It takes 4 parameters on the stack and updates 3 registers as required (Rstrs, Rmeas, Rtype).
;
; Stack offsets for parameters (return address is at offset zero)
type	EQU		2				; The character representing the type of measurement 'v', 't', 'l'
zero	EQU		4				; The measurement corresponding to zero stress
step	EQU		6				; The change in measurement corresp to a change of one stress level
meas	EQU		8				; The measurement

			mov		meas(SP),R9				; Get meas in R9
			mov		type(SP),R10			; Get type * 2 in R10 for use as word index
			rla		R10
			mov		step(SP),R8				; Get step in R8
			tst		R8
			_IF		_GE
				cmp		worstStress(R10),R9
				_IF		_GE						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				sub		zero(SP),R9				; Get meas - zero in R9
			_ELSE
				cmp		worstStress(R10),R9
				_IF		_L						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				inv		R8						; Get absolute value of step in R8
				inc		R8
				mov		zero(SP),R9				; Get zero - meas + step -1 in R9
				sub		meas(SP),R9
				add		step(SP),R9
				sub		#1,R9
			_ENDIF
			_IF		_L
				clr		R9						; Min of 0
			_ENDIF
			clr		R10						; Clear high word of dividend
			call	#UMSlashMod				; R9 = R10:R9 / R8 = (meas - zero) / step
			cmp		R9,Rstrs				; Is this stress worse than present stress calcultd so far?
			_IF		_LO
				mov		R9,Rstrs				; Yes, new present stress
				mov		meas(SP),Rmeas			; Measurement causing present stress
				mov		type(SP),Rtype			; Type of measurement causing present stress
			_ENDIF
			pop		R8						; Pop the return address
			add		#8,SP					; Drop the parameters off the stack
			br		R8						; Return
; End of DoStress


DoStatus:
;
;	Process received status byte in R8. Trashes R9, R10
;	Status byte:
;	Bit 7: Always 1 for status byte
;	Bit 6: Comms error: Means that status information does not represent the whole pack
;	Bit 5: All full (would change to "Some full" if bottom balancing was implemented)
;	Bit 4: Check bit (based on stress level -- typically inverse of stress high bit)
;	Bits 3-0: Stress level 0-15
;
			; Check validity of incoming stress bits
			mov.b	R8,R9					; Copy incoming status to R9
			mov.b	R8,R10					; And R10
			and.b	#STRESS,R9				; Only stress bits in R9
			and.b	#ENC_STRESS,R10			; Only stress and check bits in R10
			cmp.b	R10,stressTable(R9)		; If the incoming status byte has valid encoded stress
			_IF		_EQ
				clr.b	&ticksSinceLastRx		; Now zero time since last received valid status
				; This will eliminate any comms error next time through DoMeasures

				; Check if DoMeasures may have just sent a status byte, due to a comms error
				bit.b	#COM_ERR,&localStatus	; If no comms error
				_IF		_Z

					; Do MAX of local and incoming stress
					mov.b	&localStatus,R10		; Get local status to R10
					and.b	#STRESS,R10				; Extract stress bits
					cmp.b	R10,R9					; Compare incoming stress (R9) to ours (R10)
					_IF		_LO						; If incoming (R9) is less than ours (R10)
						mov.b	stressTable(R10),R10	; Get encoded local stress to R10
						movBits_B	R10,#ENC_STRESS,R8	; Replace incoming encoded stress with ours
					_ENDIF							; Endif we are worse

					; Do AND of local and incoming all_full bits
					mov.b	&localStatus,R10		; Get local status to R10
					bis.b	#~ALL_FULL,R10			; Set all bits other than the all-full bit
					and.b	R10,R8					; AND the all-full bits, others unchanged

					; Process incoming comms error bit.
					; Since we received a valid status byte, there is no local
					;	comms error, so just pass the incoming comms error bit through.

					; Send the possibly-updated status byte. High bit already set.
					call	#SendStatus				; Send status or control a charger
				_ENDIF							; End if no comms error
			_ENDIF							; End if incoming valid
			ret
; End of DoStatus

#if !MASTERLESS_CHARGING

SendStatus:
			br		#TxByte				; Send the status byte. Wait until buffer not full
			;ret						; Tail call above avoids ret

#else // MASTERLESS_CHARGING

SendStatus:
;
; Status byte is in R8. Send it or feed it to a PI controller to control a charger
;
			bit.b	#bChargerControl,&monFlags	; Set by 'o' command
			_IF		_Z							; If we're not in charge control mode
				call	#TxByte					; Send the status byte. Wait until buffer not full
			_ELSE								; Else we're in charger control mode
				bit.b	#bCharging,&monFlags		; Set by '1c' command
				_IF		_NZ							; If we've been told to start charging
					bit		#ALL_FULL,R8
					_IF		_NZ							; If all cells are considered full
						; Send command packet to charger to turn it off
						mov		#0,&chargerPrevCurr			; Set previous charger current to zero
						mov		#1<<15,R8					; Set charger-off bit
						call	#SendChargerPacket			; Send packet. Trashes R8 thru R11
						mov		#0,Rtos						; Tell ourselves we've stopped charging
						call	#_Charging					; Equiv to '0c' command. Clears bCharging
					_ELSE								; Else some are not full, so keep charging
						bit		#COM_ERR,R8
						_IF		_NZ
							mov		#8,R8					; Treat comms error as stress 8
						_ELSE
							and		#STRESS,R8				; Otherwise use the stress value (0-15)
						_ENDIF
						call	#PIController			; Call PI controller with R8 as input and output
						dec		&chargerTxTimer			; Decrement charger transmit timer
						_IF		_NZ						; If 4 seconds not yet passed since last Tx
							cmp		R8,&chargerPrevCurr		; Check if current setpoint has changed.
							mov		R8,&chargerPrevCurr		; Record current setpoint for next time
							_IF		_NE						; If current setpoint has changed,
						_END_PRIOR_IF					; Or 4 seconds has passed
								call	#SendChargerPacket		; Send packet to charger to set current
								mov		#StatusFreq*4,&chargerTxTimer ; Set timer for 4 seconds
							_ENDIF ; Current changed			; Note: TC chargers timeout after 5 s, see
					_ENDIF ; ALL_FULL ; http://www.endless-sphere.com/forums/download/file.php?id=34882
				_ENDIF ; bCharging
			_ENDIF ; bControlCharger
			ret
; End of SendStatus

SendChargerPacket:
;
; Send a charger command packet with fixed voltage, and current from R8 (in tenths of an amp)
; and high bit of R8 as charger-off bit.
;
; Trashes R8 thru R11
;
; Send 18 06 E5 F4 0V VV 0W WW 0X 00 00 00
;	where VVV is the voltage in tenths of a volt,
;	WWW is current limit in tenths of an amp, and
;	X is 0 to turn charger on
			push		R8
			mov			#Preamble,R10
			call		#TxStringCk			; Trashes R8 thru R11
			mov.b		&chargerVoltLim+1,R8 ; High byte of voltage
			call		#TxByte
			mov.b		&chargerVoltLim,R8	; Low byte of voltage
			call		#TxByte
			mov			@SP,R8
			bic			#1<<15,R8			; Clear the high bit
			swpb		R8					; High byte of current
			call		#TxByte
			mov			@SP,R8				; Low byte of current
			call		#TxByte
			pop			R8
			rlc			R8
			rlc			R8
			and.b		#1,R8				; Charger-off bit
			call		#TxByte
			mov			#Postamble,R10
			call		#TxStringCk
			clr			&txCksum			; Checksum not used
			ret
Preamble	DB			4, $18, $06, $E5, $F4		; First byte is length of following string
Postamble	DB			3, $00, $00, $00
			ALIGN		1
; End of SendChargerPacket


PIController:
;
; A PI controller whose input and output are in R8
; Input range is 0 to 15 (stress levels). Setpoint is 7.
; Output range is 0 to chargerCurrLim (tenths of an amp).
;
#define Rerror R10			// Error register
#define Rderiv R9			// Derivative register
#define Routput R8			// Output register
			mov		#7,Rerror				; error = setpoint - measurement
			sub		R8,Rerror
			mov		Rerror,Rderiv			; deriv = error - prev_error
			sub		&piPrevError,Rderiv

			mov		&piPrevOutput,Routput	; output = prev_output + Kp * deriv + Ki * error
			rla		Rderiv					; Kp = 4
			rla		Rderiv
			add		Rderiv,Routput
			add		Rerror,Routput			; Ki = 1

			cmp		#0,Routput				; Clamp output between 0 and charger current limit
			_IF		_L
				mov		#0,Routput
			_ELSE
				cmp		&chargerCurrLim,Routput
				_IF		_GE
					mov		&chargerCurrLim,Routput
				_ENDIF
			_ENDIF

			mov		Rerror,&piPrevError		; prev_error = error
			mov		Routput,&piPrevOutput	; prev_output = output
			ret
; End of PIController
#endif // MASTERLESS_CHARGING

DoPassword:
;
; Check for a password character in R8
; After decrementing passWordState below, 3 = waiting for ^G, 2 = waiting for ^F, 1 = waiting for ^E,
; 0 = waiting for ^D and erase if received. We should not receive any negative value
; Trashes R9
;
			dec.b	&passWordState
			jn		resetFSM			; This should never happen! Just reset FSM and
										; process as an ordinary command

			; Check for a continuing password match
			mov.b	&passWordState,R9	; Password is $07 $06 $05 $04
#if PROG_START_FOR_BSL <= $E000			; Changed password between 4 KiB and 8 KiB images
			add.b	#2,R9				; Expected password char is equal to &passWordState with 2 added
#else									; Assume 4 KiB image
			bis.b	#4,R9				; Expected password char is equal to &passWordState with bit 2 set
#endif
			cmp.b	R9,R8				; Check for a match
			jne		resetFSM			; If mismatch, jump and reset FSM
			tst.b	&passWordState		; Are we now at state 0?
			jnz		exitOnRx			; If not, this was a valid password byte, but not the last.
										;	Just exit this callback and wait for more
			; Jump to the code in the BSL which will erase main flash memory and wait for more bytes
			;	without using interrupts.
			; May be important: it could be bad to have receive interrupts sending stress bytes after
			;	this last password byte goes out; it could be interpreted as a byte to flash program!
#if G2553
			bic.b	#UCA0RXIE | UCA0TXIE,&IE2	; Disable UART interrupts
			clr		&ScuCCTLr			; Clear at least the CCIE RX interrupt enable bit
			clr		&ChgCCTLr			; Clear at least the CCIE RX interrupt enable bit
#else
			clr		&CCTLr				; Clear at least the CCIE RX interrupt enable bit
#endif
			; Important: wait for the last password byte to be echoed before disabling interrupts!
			call	#WaitTxComplete		; Wait for all transmission on all ports to complete

			dint
			clr		&TACTL				; Disable the timer completely; may use less power
			bis.b	#TxPl,&P1OUT		; Set Tx to idle
			bic.b	#TxMi,&TxMiPortOUT
			ActLedOff					; (inverted) activity LED off

#if G2553
			bic.b	#Bypass,&BypPortOUT	; Set Bypass off
			mov.b	#0,Rtos				; Set Error Led and Piezo off
			call	#_errorLed
			bic.b	#Rx|TxPl,&P1SEL		; Restore CMU comms pins to GPIO function
			bic.b	#Rx|TxPl,&P1SEL2
#else
			clr.b	&P2OUT				; Set bypass and error LED off (relays off if IMU)
			clr.b	&P1SEL				; Make Piezo (P1.1) ordinary I/O now
			bic.b	#USIPE5,&USICTL0	; Make TxPl (P1.5) ordinary I/O also
#endif
			clr		&bsl2state			; Set BSL2's state variable as if it has just recognised password
			mov		#InitSP,SP			; Give the BSL maximum stack
			br		#jBSLErase			; Jump into BSL2 to flash erase and continue the download

resetFSM	mov.b	#4,&passWordState	; No password match; reset state machine

exitOnRx	ret
; End of DoPassword

			EVEN


			; Encoded stress table. The stress and other information is transmitted in one status byte,
			; with no checksum correction. To counter this, stress is encoded, so that only
			; 16 of the 32 possible stress codes ($00 - $1F) are valid. Other codes
			; are treated as a corrupted attempt to send status information.
			; Present status for this CMU is sent instead.
			; Note that bit 7 is always set for status bytes; bit 6 represents comms error;
			; bit 5 represents all-full; bit 4 is a check bit, the inverse of the stress high bit.
			; Note that encoded stress values are not monotonic
			; The table is indexed by raw stress values
stressTable	DB		(1<<4) + 0			; Stress 0	$10
			DB		(1<<4) + 1			; Stress 1	$11
			DB		(1<<4) + 2			; Stress 2	$12
			DB		(1<<4) + 3			; Stress 3	$13
			DB		(1<<4) + 4			; Stress 4	$14
			DB		(1<<4) + 5			; Stress 5	$15
			DB		(1<<4) + 6			; Stress 6	$16
			DB		(1<<4) + 7			; Stress 7	$17
			DB		(0<<4) + 8			; Stress 8	$08
			DB		(0<<4) + 9			; Stress 9	$09
			DB		(0<<4) + 10			; Stress 10	$0A
			DB		(0<<4) + 11			; Stress 11	$0B
			DB		(0<<4) + 12			; Stress 12	$0C
			DB		(0<<4) + 13			; Stress 13	$0D
			DB		(0<<4) + 14			; Stress 14	$0E
			DB		(0<<4) + 15			; Stress 15	$0F


; Some calculations so we can see how much space we have left, by reading the listing.
freespace	EQU		_CMDCHRTBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/(_CMDCHRTBL-PROG_START))

;---------------------------------------------------------------------------------
; Interrupt and entry-point jump table at the end of the second-last main-flash segment
;---------------------------------------------------------------------------------
				ORG		$FDDE
CMDCHRTBLEND	EQU		$				; Command character table ends immediately below lowest used
										;  interrupt vector
jInterpretByte	br		#InterpretByte	; A branch to InterpretByte, independent of PROG_START

#if G2553
jUCA0TxIsr		br		#TxIsr			; UART transmit
jUCA0RxIsr		br		#RxIsr			; UART receive
#else
jUCA0TxIsr		reti					; UART transmit not used
				nop
jUCA0RxIsr		reti					; UART receive not used
				nop
#endif

#if G2553
jTA1RxTiovIsr	br		#ScuRxTiovIsr	; Combined TA1 CC1&2IFG (receive capture/compare) & TAIFG (ovf)
jTA1TxIsr		br		#ScuTxIsr		; Timer A1 CC0IFG (transmit compare)
#else
jTA1RxTiovIsr	reti					; TA1 CC1&2 & TAI not used
				nop
jTA1TxIsr		reti					; TA1 CC0 not used
				nop
#endif

jInterpretInit	br		#InterpretInit	; A branch to InterpretInit, independent of PROG_START

#if G2553
jTA0RxTiovIsr	br		#ChgRxTiovIsr	; Combined TA0 CC1&2IFG (receive capture/compare) & TAIFG (ovf)
jTA0TxIsr		br		#ChgTxIsr		; Timer A0 CC0IFG (transmit compare)
#else
jTA0RxTiovIsr	br		#RxTiovIsr		; Combined TA0 CC1&2IFG (receive capture/compare) & TAIFG (ovf)
jTA0TxIsr		br		#TxIsr			; Timer A0 CC0IFG (transmit compare)
#endif
				ORG		$FDFE
ProgPresence	DB		$AA				; For BSL2 to check before calling main program (InterpretByte)
ProgChecksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg

;---------------------------------------------------------------------------------
; Bootstrap loader, in the last main-flash segment
;---------------------------------------------------------------------------------
#include "../common/BSL2.s43"	// Include the macro for the bootstrap-loader and the interrupt vectors
				ORG		$FE00			; Start of last main-flash segment
; Instantiate the BSL2 macro with the standard external labels
				BSL2MACRO	jBSL, jBSLErase, jReadByte, jWriteByte
				ORG		$FFFE			; The reset vector
				DW		jBSL			; Reset to BSL in case there is a crash

				END
