			COL		150			; Wide listings

			LSTOUT-
#include "msp430.h"
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Macros for obscure instruction sequences
			LSTOUT+
		
			NAME	main		; Module name
			PUBLIC	main		; Make the "main" label visible



DATAVERS5	EQU		1			; True if data layout version 5
#if	DATAVERS5
InitRetAddr	EQU		$1022		; Return address when interpretByte is called for initialisation
ReadByte	EQU		$108C		; Calling-address to receive byte in R8
WriteByte	EQU		$10C4		; Calling-address to transmit byte in R8
BSLErase	EQU		$1038		; Jump-in-address for erasing flash and continuing a download
ID			EQU		$10F2		; Address of this Cell's/BMU's identification byte
VoltCalL	EQU		$10F8		; Address of Voltage scale calibration lo byte
VoltCalH	EQU		$10F9		; Address of Voltage scale calibration hi byte
TempCal		EQU		$10FA		; Address of Temperature offset calibration byte
LinkCal		EQU		$10FB		; Address of Link Voltage offset calibration byte
MHz1CalD 	EQU		$10F4		; Frequency calibration
MHz1CalB 	EQU		$10F5		;	for 1 MHz (NO LONGER USED)
MHz4CalD	EQU		$10F6		; Uncompressed 4MHz calibration value for version 5 data layout
MHz4CalB	EQU		$10F7		; Unompressed 4MHz calibration value for version 5 data layout
#else	; Assume data layout version 4
; Addresses manually imported from the BSL-writer. Version 4. Keep up to date!
InitRetAddr	EQU		$1020		; Return address when interpretByte is called for initialisation
ReadByte	EQU		$108A		; Calling-address to receive byte in R8
WriteByte	EQU		$10D2		; Calling-address to transmit byte in R8
BSLErase	EQU		$1036		; Jump-in-address for erasing flash and continuing a download
ID			EQU		$1003		; Address of this Cell's/BMU's identification byte
VoltCalL	EQU		$1009		; Address of Voltage scale calibration lo byte
VoltCalH	EQU		$100F		; Address of Voltage scale calibration hi byte
TempCal		EQU		$10A1		; Address of Temperature offset calibration byte
LinkCal		EQU		$10BF		; Address of Link Voltage offset calibration byte
MHz1CalB 	EQU		$1002		; Frequency calibration
MHz1CalD 	EQU		$1008		;	for 1 MHz
MHz4Cal		EQU		$10D7		; Compressed 4MHz calibration value for version 4 data layout
#endif


; Interpreter Register Usage
;	Registers 0 thru 3 are dedicated machine registers (PC SP SR CG).
#define 	Rip		R5				// Virtual machine instruction pointer
#define 	Rlit	R6				// Holds partial literals
#define 	Rw		R8				// Working register - temporary - anyone can use

#define		LEDWITHTX	1			; True to have LED come on with any transmit byte
#define		ROTATE3		1			; True for later boards that have TXDp, TXDm and BYPASS rotated
minLEDBad	EQU			1			; Minimum badness to light error LED

#if			ROTATE3
TXDm		EQU		1<<1			; TA0/P1.1
TXDp		EQU		1<<5			; SCLK/P1.5
BYPASS		EQU		1<<0			; P1.0
#else
; The below are how things used to be; can't really run this software on that old hardware
TXDm		EQU		1<<0			; Normally 1<<n with n < 4 for compactness (costs 1 word if not)
TXDp		EQU		1<<1			; Code requires TXD+ bit somewhere to left of TXD- bit
BYPASS		EQU		1<<5			; Bypass transistor on pin P1.5
#endif

RXD			EQU		1<<2			; Receive data on P1.2 (bit number >3 costs 3 words in BSL)
LED			EQU		1<<6			; LED on bit 6

; ADC channel numbers
CellVChan	EQU		$7				; ADC channel number for cell voltage
TempChan	EQU		$A				; ADC channel number for temperature
LinkVChan	EQU		$3				; ADC channel number for link voltage
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)
NOBUF		EQU		1				; 1 for no ADC sample buffer; 0 for buffer

; Serialio definitions
#define		TACCTLr		TACCTL1		// Receive using CCI1 (P1.2)
#define		TACCTLt		TACCTL0		// Transmit (and everything else) using TA0
#define		TACCRt		TACCR0		// Transmit compare register
#define		TACCRr		TACCR1		// Receive capture/compare register

rxsz		EQU		4				; Receive queue size. Must be a power of 2 no greater than 256
txsz		EQU		4				; Transmit queue size. Must be a power of 2 no greater than 256

; The following macro gem is due to Dave Keenan. It is based on a Taylor series expansion.
; It is valid for the domain 1-64, and range 0-6.
; NOTE: it depends on the assembler rounding down on division, even for negative results
; There is a similar simple formula for rounding towards zero
#define LOG2(x) (4 * (x-8) / (x+8) + 3)

;
;			Memory definitions
;
			ORG		$200			; Start of RAM. Ends at $27F
#if	!NOBUF
			ALIGNRAM 1
sampleBuf	DS		2*NumSamples	; ADC sample buffer; 4 or 16 samples
#endif
bypassVolts	DS		2				; If non-zero, this is the bypass threshold in mV

; NOTE: Many pairs of byte variables below are initialised as a word to save code space.
; Don't move them or insert new variables without checking.

			ALIGNRAM 1
bNotSendBad	 DS		1				; Zero if sending badness bytes at all
bNotMeasureTime DS	1				; Zero if time to measure
bAlarmForBad DS		1				; A BMU can be told to raise an alarm instead of sending badness on
localBadness DS		1				; Local badness
			ALIGNRAM 1
worstBadMeas DS		2				; Value of measurement that caused worst badness
worstBadUnit DS		1				; Unit character for reason for worst badness
worstBadness DS		1				; Worst local badness since last resetWorstBadness command

ticksSinceLastSend DS 1				; Timer overflow events (~1/4 seconds) since last badness send
ticksSinceLastRx DS	1				; Timer overflow events since last badness received
passWordState DS	1				; State machine for password recogniser
lastSentBad	DS		1				; Last sent badness

; Serialio variables

			ALIGNRAM 1
TXData		DS		2				; Byte to transmit in lower byte; always $FF in high byte
RXData		DS		1				; Received char
BitCntTx	DS		1				; Bit count 10 -> 1
BitCntRx	DS		1				; Bit count 8 -> 1
TXCksum		DS		1				; Transmit checksum

			ALIGNRAM 1
rxbuf		DS		rxsz			; Receive queue buffer
rxwr		DS		1				; Receive queue write index
rxrd		DS		1				; Receive queue read index
txbuf		DS		txsz			; Transmit queue buffer
txwr		DS		1				; Transmit queue write index
txrd		DS		1				; Transmit queue read index

; ByteCodeInterpreter2 variables

			ALIGNRAM 1
base		DS		1				; Number base for output, 10 or 16
CHKSUM		DS		1				; Packet xor checksum
Checksumming DS		1				; Boolean
dontInterpret DS	1				; Boolean
			ALIGNRAM 1
ToIN		DS		2				; Pointer to current character being stored in Text Input Buffer
TIB			DS		1				; Start of Text Input Buffer, grows towards stack
; Don't put anything else in RAM after TIB

;-------------------------------------------------------------------------------
			ORG		$F800					; Reset vector points here
;-------------------------------------------------------------------------------

; Clear all of RAM
			_DO		#$80,R8
				clr		$1FE(R8)
			_mLOOP	#2,R8

main:		mov.w	#$280,SP				; Initialize stackpointer
;			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (bad idea, except while debugging)

;			MOV.B	&CALBC1_1MHZ, &BCSCTL1 ; Set range for 0.54 to 1.06 MHz
;			MOV.B	&CALDCO_1MHZ,&DCOCTL	; Set DCO step + modulation for 1.00 MHz
#if Mfreq = 1000000
			mov.b	&MHz1CalB,&BCSCTL1		; Set range for 0.54 to 1.06 MHz
			mov.b	&MHz1CalD,&DCOCTL		; Set DCO step + modulation for 1.00 MHz
#else										; Else frequency is 4MHz
#if			DATAVERS5
			mov.b	&MHz4CalB,&BCSCTL1		; Version 5: just copy
			mov.b	&MHz4CalD,&DCOCTL		;	the two bytes
#else
			mov.b	&MHz4Cal,R8				; Compressed 4MHz calibration data
			rla		R8						; Uncompress
			bis		#$8A00,R8				; OR in most significant bits
			swpb	R8						; Get MSB (might be important to write first)
			mov.b	R8,&BCSCTL1				; Write MSB
			swpb	R8
			mov.b	R8,&DCOCTL				; and LSB
#endif
#endif

;
;	Initialise timer and interrupt comms
;
			; DIVS_0 => SMCLK = DCOCLK/1	DIVS_1 -> SMCK = DOCLK/2
			; Other zero bits select MCLK = DCOCLK/1
			mov.b		#LOG2(MckPerSMck)*DIVS_1, &BCSCTL2

			; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
			; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
			; MC: 2 = continuous mode 1 = up mode
			; TAIE = interrupt enable (for timer overflow)
			mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2 + TAIE, &TACTL
			
			; Set up differential timer outputs for transmit data.
			; Tricky way of getting inverted TA0 to appear on P1.5 automatically
			; when TA0 appears on P1.1.
			; We use the clock inverter in the USI (Universal Serial Interface)
			; to invert TA0 and put it out as SCLK, in SPI master mode.
			; We don't use the shift register of the USI because there is
			; no way to get differential outputs from that without external hardware.
			mov.b	#RXD+TXDm,&P1SEL			; Select timer functions CCI1A and TA0 (not I/O port)
			bis.b	#TXDp+TXDm+LED+BYPASS,&P1DIR ; TXD, LED and BYPASS are outputs
			clr.b	&P1OUT						; Clear LED and bypass

			mov.b	#USIPE5 + USIMST, &USICTL0	; SCLK out on P1.5, SPI Master mode, remove SW Reset
			mov.b	#USIDIV_0 + USISSEL_5 + USICKPL, &USICKCTL ; SCLK source is TA0, div by 1, inverted
			mov.b	#8, &USICNT					; To clear USIIFG so SCLK will not be held

			; Make TA0 (output of Timer-A capture/compare unit 0) appear on P1.1
			; We want to set the CCIFG so that TX_Byte won't think there's an uncompleted stop bit
			; and wait for it to complete.
			mov		&TAR,&TACCRt				; Make an output event
			add		#4,&TACCRt					;	happen in a dozen or so instructions
			; NOTE: the above has to be enough to get past setting of OUTMOD_5 for TACCTLt below
			mov.w	#OUTMOD_0 + OUT, &TACCTLt	; TA0=1 Space; seems necessary to "wake up" SCLK divider
			mov.w	#OUTMOD_5, &TACCTLt			; When the compare happens, set TA0=0 Idle or Mark

			mov.b	#$FF,&TXData+1				; Initialise the top half of TXData to all 1s (stop bit,
												;	idle bit)
			mov.b	#8,&BitCntRx				; Load Bit Counter, 8 data bits
;			clr.b	TXCksum						; Clear transmit checksum
			mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&TACCTLr	; Falling edge, Input A, Sync, Capture
;			clr.b	&rxwr						; Initialise the TX and RX queue indexes
;			clr.b	&rxrd
;			clr.b	&txwr
;			clr.b	&txrd

;
; Initialise the ADC10
;
			; Enable cell and link analog inputs. Enable ADC function of P1.4 (Vref+ out)
			mov.b		#(1<<CellVChan)+(1<<LinkVChan)+(1<<4),&ADC10AE0
			; Initialise ADC10
			; SREF_1    = +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temp)
			; REFOUT    = connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			; No MSC	= single sample and conversion
			mov			#SREF_1+ADC10SHT_3+REFOUT+REFON,&ADC10CTL0
			; Other ADC10 initialisation is done every time "measure" is called, to save code

;
; Initialise the command character (bytecode) interpreter
;
			mov.b	#10,&base				; Decimal output mode by default
;			clr.b	&CHKSUM					; Clear checksum
;			clr.b	&Checksumming			; Checksumming of packets, off by default
;			clr.b	&dontInterpret			; Interpret
			mov		#TIB,&ToIN				; Packet pointer

;
; Miscellaneous initialisation
;
;			clr		&bypassVolts			; No special bypass voltage as yet
;			clr.b	&bNotSendBad			; Default to sending badness
;			clr.b	&bNotMeasureTime		; Make it measure time immediately
;			clr.b	&bAlarmForBad			; Just pass badness on, don't raise alarm
;			clr.b	&localBadness			; Local badness is none
;			clr		&worstBadMeas			; Value of measurement causing worstBadness is zero
;			clr.b	&worstBadUnit			; Unit of measurement causing worst badness is null
;			clr.b	&worstBadness			; Worst local badness is none
;			clr.b	&ticksSinceLastSend
;			clr.b	&ticksSinceLastRx
			mov.b	#3,&passWordState		; Waiting for first byte of ^B ^A ^D sequence
;			clr.b	&lastSentBad			; Last badness we sent was zero

; Main loop
			_BEGIN
				dint
				;nop							; First instruction after dint not protected
				call	#RX_RawByteNW			; Check if received data
				_IF		_NZ						
					eint
					tst.b	R8
					_IF		_NN
						call	#TX_Byte				; Echo the command or password byte
						call	#DoPassword				; Check for password bytes
						call	#ACCEPT					; Process command bytes (could take a long time)
					_ELSE
						call	#DoBadness				; Process badness bytes
					_ENDIF
				_ELSE
					tst.b	bNotMeasureTime			; Check if time to measure
					_IF		_Z						; If not, skip measurement and set/clear of bypass
						eint
						mov.b	#$FF,bNotMeasureTime
						call	#measures				; May send badness
					_ELSE
						mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer before sleeping CPU
						;eint							; Interrupts are enabled by following bis instr:
						bis		#CPUOFF+GIE,SR			; Turn off CPU, enable interrupts
					_ENDIF
				_ENDIF
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart Watchdog Timer each time around main loop
			_AGAIN
; End of main loop


measures:
;
; Regular measurement. Called BadnessFreq times per second (4-32 times per second)
;
#define Rmeas R15				// Tentative measurement causing worst badness
#define Runit R14				// Tentative unit of measurement causing worst badness

			inc.b	&ticksSinceLastSend		; Increment these counters
			inc.b	&ticksSinceLastRx
			_IF		_Z						; Wrapped around to 0?
				mov.b	#$FF,&ticksSinceLastRx	; Yes, saturate at $FF
			_ENDIF

			; Cell voltage measurement
			call	#cellV					; Get cell voltage in mV in R10
			mov		R10,Rmeas				; Tentative measurement causing worst badness
			mov.b	#'V',Runit				; Tentative unit of measurement causing worst badness
			mov		&bypassVolts,R8			; Get the current bypass threshold, if any
			tst		R8
			_IF		_Z
				mov		#3600,R8				; Default of 3.6 V
			_ENDIF
			cmp		R10,R8					; Compare current cell voltage (R10) to the bypass threshold (R8)
			NCtoAllBits	R8					; If voltage > threshold then $FF else $00
			movBits_B	R8,#BYPASS,&P1OUT	; Move only the #BYPASS bit from R8 to &P1OUT. Trashes R8

			; Overvoltage badness: for every 50 mV over 3.60 V, we add one level of badness, to a maximum of 7 for > 3.95 V
			mov		R10,R9					; Measurement
			sub		#3650-49,R9				; Cell voltage - 3.6 V + 49 mV for rounding
			_IF		_L
				clr		R9						; Minimum of zero
			_ENDIF
			push	R10						; Save measurement
			clr		R10						; R10:R9 has meas - 3.6
			mov		#50,R8
			call	#UMSlashMod				; (meas - 3.6) / 50 -> R9

			; Undervoltage badness: for every 100 mv below 2.5 V, we add one level of badness, to a maximum of 7 for < 1.9 V
			pop		R10						; Restore original measurement
			push	R9						; Save badness_so_far
			mov		#2500+99,R9
			sub		R10,R9					; R9 has 2.5 V - meas plus 99 for rounding
			clr		R10						; R10:R9 has this
			_IF		_L
				clr		R9						; Minimum of zero
			_ENDIF
			mov		#100,R8
			call	#UMSlashMod				; (2.5 V - meas) / 100 -> R9
			pop		R8						; Restore Badness_so_far
			cmp		R8,R9					; Which badness is worse?
			_IF		_LO
				mov		R8,R9				; Worst to R9
			_ENDIF
			
			; Temperature measurement
			push	R9						; Save badness_so_far
			call	#temp					; Get cell temperature in degrees Celsius in R10
			push	R10						; Save measurement
			; Temperature badness: 1 for every 2 degrees over 50
			sub		#50-1,R10				; -1 for rounding
			_IF		_L
				clr		R10					; Minimum of 0
			_ENDIF
			rra		R10
			pop		R8						; Restore measurement
			pop		R9						; Restore badness_so_far
			cmp		R10,R9					; Is temp badness worse than badness_so_far?
			_IF		_LO
				mov		R10,R9					; Yes, new badness_so_far
				mov		R8,Rmeas				; Tentative measurement causing worst badness
				mov.b	#'C',Runit				; Tentative unit of measurement causing worst badness
			_ENDIF

			; Link measurement, if appropriate
			push	R9						; Save badness_so_far
			call	#linkV					; Get link voltage in mV in R10
			cmp		#9999,R10				; Special "invalid" value?
			_IF		_NE						; Only calculate link badness if not this value
				push	R10						; Save linkV measurement
				tst		R10
				_IF		_L						; Get absolute value
					inv		R10
					inc		R10
				_ENDIF
				; Link badness: 1 for every 50 mV over 100 mV
				sub		#100-49,R10
				_IF		_L
					clr		R10						; Minimum of 0
				_ENDIF
				mov		R10,R9
				clr		R10
				mov		#50,R8
				call	#UMSlashMod
				mov		R9,R8					; Link badness in R8
				pop		R10						; Restore linkV measurement
				pop		R9						; Restore badness_so_far
				cmp		R8,R9					; Is badness_so_far less than link badness?
				_IF		_LO
					mov		R8,R9					; Yes, new badness_so_far
					mov		R10,Rmeas				; Tentative measurement causing worst badness
					mov.b	#'m',Runit				; Tentative unit of measurement causing worst bad
				_ENDIF
			_ELSE
				pop		R9						; Restore badness_so_far
			_ENDIF

			cmp		#7,R9					; Is the badness_so_far worse than 7?
			_IF		_GE
				mov		#7,R9					; Yes, use 7
			_ENDIF

			; Comms badness: 1 if no badness RX for 10 ticks and we are not ID 1
			tst.b	bNotSendBad				; Are we sending badness?
			_IF		_Z						; If not, there can't be a comms badness
				cmp.b	#10,&ticksSinceLastRx	; Been 10+ ticks since last Rx?
				_IF		_C
					cmp.b	#1,&ID					; Only if ID
					_IF		_NE						;	is not 1 ...
						tst		R9						; Yes, are we at badness zero?
						_IF		_Z
							mov		#1,R9					; Yes, make it 1 for the comms error
							mov.b	&ticksSinceLastRx,Rmeas	; Tentative measurement causing worst badness
							mov.b	#'t',Runit				; Tentative unit of measurement causing worst bad
						_ENDIF
					_ENDIF
				_ENDIF
			_ENDIF

			mov.b	R9,&localBadness		; Record this for later use
			cmp.b	&worstBadness,R9
			_IF		_HS						; If localBadness equal or higher than worstBadness
				mov.b	R9,&worstBadness		; Update worstBadness
				mov		Rmeas,&worstBadMeas		; Update value of measurement causing worst badness
				mov.b	Runit,&worstBadUnit		; Update unit of measurement causing worst badness
			_ENDIF
			
			cmp.b		#minLEDBad,R9		; Turn on the error LED if badness is minLEDBad or more
			CtoAllBits	R8
			movBits_B	R8,#LED,&P1OUT
			
			tst.b	&bNotSendBad				; If bNotSendBad is false
			_IF		_Z			
				mov.b	badnessTable(R9),R9		; Look up the encoded badness
				cmp.b	R9,&lastSentBad			; Is this worse than the last badness we sent?
				; We could change the jnc below to a jne if we wanted to send out-of-cycle messages
				;	about a new lower badness (as well as higher).
				;	However, it's possible that these messages could overwhelm
				;	the communications system, in the situation of a sudden series of high power pulses.
;				_IF		_C						; [Equiv to jnc below, when _CS_SWAPs and _ENDIF also used]
				jnc		sendBadnessNow			; Jump if so to send the badness immediately
	
					; We don't want to send badness unless we are a (temporary) master.
					; We are a temporary master if there have been 10+ ticks since our last Rx
					cmp.b	#10,&ticksSinceLastRx	; Been 10+ ticks since last Rx?
					_IF		_C
;				_CS_SWAP
						cmp.b	#4,&ticksSinceLastSend
						_IF		_C
;				_CS_SWAP
							; If we don't have ID one, report that we haven't heard from anyone
							cmp.b	#1,&ID
							_IF		_NE
								call	#_RxState
							_ENDIF
;				_ENDIF
sendBadnessNow
							clr.b	&ticksSinceLastSend
							mov.b	R9,&lastSentBad			; Update remembered value
							mov.b	R9,R8
							call	#SendBadness
						_ENDIF							; Endif >= 4 ticks since last send
					_ENDIF							; Endif >= 10 ticks since last Rx
			_ENDIF							; Endif bNotSendBad is false
			ret
; End of measurement


;
;	Callback routine for received badness byte.
;	Process received badness byte in R8. Trashes R9
;
DoBadness:
			clr		&ticksSinceLastRx		; Now no time since last received badness
			mov.b	R8,R9					; Copy incoming badness
			and		#7,R9					; Consider only raw badness bits
			cmp.b	R8,badnessTable(R9)		; Is it valid? (Tested after 2 intervening instructions)
			mov.b	&localBadness,R9		; Current badness into R9
			mov.b	badnessTable(R9),R9		; Present encoded badness
			_IF		_EQ						; If incoming is a valid badness byte
				cmp.b	R8,R9					; Compare incoming badness to ours
				_IF		_HS						; If we (R9) are worse than incoming (R8)
			_CS_SWAP						; [ Make the next _ENDIF apply to the _IF _EQ ]
			_ENDIF							; Endif incoming valid
					mov		R9,R8					; Incoming not valid or we are worse; use our badness
				_ENDIF							; Endif we are worse
			mov.b	R8,&lastSentBad			; Remember that we sent this
			; Fall through to SendBadness

;
;	Send badness byte or BELL character depending on &AlarmForBad.
;	Badness byte in R8. Trashes R9
;
SendBadness:
			tst.b	&bAlarmForBad
			_IF		_NZ						; If told to raise alarm
				cmp.b	#$80,R8
				_IF		_NE						; If nonzero badness
					mov.b	#7,R8					; Send a BELL character
			_CS_SWAP						; [ Make next _ENDIF apply to the _IF _NZ ]
			_ENDIF							; Endif told to raise alarm
					call	#TX_ByteNW				; Send the encoded badness (or BELL) if buffer not full
				_ENDIF							; Endif nonzero badness
			ret
			
			
;
; Check for a password character
; After decrementing passWordState below, 2 = waiting for ^B, 1 = waiting for ^A,
; 0 = waiting for ^D and erase if received. We should not receive any negative value
; Trashes R9
;
DoPassword:
			dec.b	&passWordState
			jn		resetFSM			; This should never happen! Just reset FSM and
										; process as an ordinary command

			; Check for a continuing password match
			mov.b	&passWordState,R9
			cmp.b	PWtable(R9),R8		; Check against table
			jne		resetFSM			; If mismatch, jump and reset FSM
			tst		R9					; Are we now at state 0?
			jnz		exitOnRx			; If not, this was a valid password byte, but not the last.
										;	Just exit this callback and wait for more
			; Jump to the code in the BSL which will erase main flash memory and wait for more bytes
			;	without using interrupts.
			; May be important: it could be bad to have receive interrupts sending badness bytes after
			;	this last password byte goes out; it could be interpreted as a byte to flash program!
			clr		&TACCTLr			; Clear at least the CCIE RX interrupt enable bit
			; Important: wait for the last password byte to be echoed before disabling interrupts!
			call	#waitTxCmpl

			dint
			clr		&TACTL				; Disable the timer completely; may use less power
			mov.b	#TXDp,&P1OUT		; Set TXD to idle, bypass and error LED off
			clr.b	&P1SEL				; Make P1.1 ordinary I/O now
			bic.b	#USIPE5,&USICTL0	; Make P1.5 ordinary I/O also
			clr		R15					; The BSL uses R15 as its FSM state variable
			mov		#$280,SP			; Give the BSL maximum stack
			br		#BSLErase			; Jump into the BSL to finish the download

resetFSM	mov.b	#3,&passWordState	; No password match; reset state machine
	
exitOnRx	ret

PWtable:	db		'd'-$60, 'a'-$60, 'b'-$60	; This is the password in reverse order that the FSM
												;	is looking for
			EVEN


DELAY_IF_NEEDED MACRO		
			; No delay needed
			ENDM

#include "serialio.s43"				// Comms routines
#include "../common/comMisc.s43"	// Miscellaneous common functions
#include "../common/measure.s43"	// Voltage measurement functions
#include "../common/BytecodeInterpreter2.s43" // Cutdown bytecode interpreter. No defs in bytecode
#include "../common/math.s43"		// Multiply and divide routines
#include "monDefinitions.s43"		// Bytecode definitions

; The linker puts a checksum of the used code memory in the first available unused space,
; when asked for one.
; To keep our BSL (bootstrap loader) happy we need a simple 1-byte XOR checksum.
; To obtain this we set the IAR Embedded Workbench IDE Project/Options/Linker/Checksum options to:
; Fill unused code memory
; 	Fill pattern: 0xFF
;	Generate checksum
;		Size: 1 byte, Alignment: 1
;		CRC Polynomial: 0x101
; 		Complement: As is
;		Bit order: MSB first, Initial value: 0x10
; The initial value of 0x10 is required because the reset vector of $1000 at $FFFE is not transmitted
; and so the BSL does not include it in its checksum, but the linker does.

; And we set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	monitor.bin
;	Output format: raw-binary

; Some calculations so we can see how much space we have left, by reading the listing.
freespace	EQU		_OPCODETBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/2048)

;-------------------------------------------------------------------------------
;			Interrupt Vectors
;-------------------------------------------------------------------------------
			ORG		0FFF0h				; Timer A Vectors
			DW		RX_TIOV_ISR			; Combined CC1IFG (receive capture/compare) & TAIFG (overflow)
			DW		TX_ISR				; Timer A CC0IFG (transmit compare)
			
			; Encoded badness table. The badness information is transmitted in one byte,
			; with no checksum correction. To counter this, badness is encoded, so that only
			; eight of the 128 possible raw badness codes ($80 - $FF) are valid. Other codes
			; are treated as a corrupted attempt to send badness information; current badness
			; for this BMU is sent instead.
			; The table is indexed by raw badness value (i.e. the least significant 3 bits of
			; the encoded badness byte).
badnessTable DB		$80					; $80 is least badness
			DB		$91,$A2,$B3,$C4,$D5,$E6
			DB		$F7					; $F7 is the worst badness
			
			ORG		0FFFEh				; MSP430 RESET Vector
			DW		0x1000				; Reset to BSL in case there is a crash


			END
