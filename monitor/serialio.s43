;*******************************************************************************
;	MSP430F20xx Software UART - Timer_A
;
;	Description: Use Timer_A CCR0 hardware output modes and SCCI data latch
;	to implement UART function @ 9600 baud. Software does not directly read and
;	write to RX and TX pins, instead proper use of output modes and SCCI data
;	latch are demonstrated. Use of these hardware features eliminates ISR
;	latency effects as hardware insures that output and input bit latching and
;	timing are perfectly synchronised with Timer_A regardless of other
;	software activity.
;	TACLK = SMCLK/4 = DCOCLK/8/4 = 250 kHz, MCLK = DCOCLK/2 = 4.00 MHz
;
;				MSP430F20xx
;			 ---------------
;		 /|\|				|
;		  | |				|
;		  --|RST			|
;			|				|
;			|		TA0/P1.1|--------> TXDm (mark = low)
;			|	   SCLK P1.5|--------> TXDp (mark = high; via internal inverter from TA0)
;			|				| 9600 8N1 full duplex
;			|	  CCI1A/P1.2|<-------- RXD
;
;
;	September 2010
;	Based on code by:
;	M. Buccini / L. Westlund
;	Texas Instruments Inc.
;	October 2005
;*******************************************************************************

; Timer A overflow is used for the regular processing "tick" or status frequency
; while its capture/compare regs are used for the interrupt-driven software UART
;
;	Conditions for 9600 Baud SW UART
DCOfreq		EQU		8000000				; DCO clock in Hz
DCOckPerMck	EQU		2					; Number of DCO clocks per MCK (CPU, ADC) (allowed values 1,2,4,8)
DCOckPerSMck EQU	8					; Number of DCO clocks per SMCK (Timer) (allowed values 1,2,4,8)
StatusFreq	EQU		16					; Status frequency in hertz (allowed 2, 4, 8 or 16)
SMckPerTAck	EQU		(DCOfreq/DCOckPerSMck/StatusFreq+(1<<15))/(1<<16)
										; Number of SMCK clocks per timer clock (allowed 1,2,4,8)
MckPerTAck	EQU		SMckPerTAck*DCOckPerSMck/DCOckPerMck
TAfreq		EQU		DCOfreq/(DCOckPerSMck*SMckPerTAck)	; Timer frequency in Hertz
BitTime96	EQU		(TAfreq+4800)/9600	; 104.17 us bit length in timer clock periods for 9600 baud
BitTime24	EQU		(TAfreq+1200)/2400	; 416.68 us bit length in timer clock periods for 2400 baud


;-------------------------------------------------------------------------------
; TX_Byte	; Subroutine Transmits Character from R8
			; Trashes R9
;-------------------------------------------------------------------------------

;
; Put the character from R8 into the transmit queue.
; If necessary, wait until the queue is not full.
; Preserves R8, trashes R9.
;
TX_ByteCk:
			xor.b	R8,&TXCksum		; Alternative entry which accumulates checksum
TX_Byte:
			_BEGIN
				call	#TX_ByteNW
			_UNTIL	_NZ
			ret

;
; Attempt to put the character from R8 into the transmit queue.
; If the queue is full, return immediately with the Z status bit set.
; Preserves R8, trashes R9.
;
TX_ByteNW:
			mov.b	&txwr,R9				; Get the write index (not changed by TX_ISR)
			mov.b 	R8,txbuf(R9)			; Tentatively write the character to the transmit queue
											;	there's always at least one free space,
											;	but don't increment the write index yet.
			inc.b	R9						; Increment a copy of the write index
			and.b	#txsz-1,R9				;	modulo the queue size
			cmp.b	&txrd,R9				; If wr+1 mod sz = rd then it's full
			_IF		_NE
				mov.b	R9,&txwr			; Increment write index so char is officially in tx queue

				; If transmit interrupts are disabled, set up the timer for a new start bit
				; and enable transmit compare interrupts.
				bit		#CCIE,&TACCTLt		; Test transmit interrupts enabled bit
				_IF		_Z					; If transmit interrupts disabled
					mov.b	#8,&USICNT			; Load USI counter to keep USIIFG clear so TXDp (SCLK)
												;   will continue to be an inversion of TXDm (TA0).
					mov.b	#10,&BitCntTx		; Load bit transition counter: 10 bits
					; Ensure a predictable delay between reading timer and setting
					; compare time and output mode for a start bit.
					dint
					; We want the max number of clock cycles till TAR and TACCTLt are correctly set up.
					; First number is sum of cycles in paren below. The +MckPerTAck-1 is for rounding up.
					; The +1 is in case the TAR increments just after we read it.
					mov		#((23+MckPerTAck-1)/MckPerTAck)+1,R9 ; R9 := setup time. Not protected by dint
					add		&TAR,R9				; R9 := timer value + setup time
					bit		#CCIFG,&TACCTLt		; (5) Test transmit compare interrupt flag
					_IF		_Z					; (2) If previous stop bit has not completed
						cmp		&TACCRt,R9			; (4) Test (TAR+setup) - TACCRt
						_IF		_NN					; (2) If existing TACCRt AFTER TAR+setup, keep TACCRt
					_END_PRIOR_IF ; _Z			; Endif previous stop bit has not completed
							mov		R9,&TACCRt			; (4) Set the new compare value start-bit
						_ENDIF ; _NN				; Endif existing TACCRt is AFTER TAR+setup
					eint						; (1) Next instruction still protected
					mov		#OUTMOD_1+CCIE,&TACCTLt ; (5) Set out mode for start bit, enable compare ints

					bic.b	#ACTLED,&P1OUT		; Turn on the (inverted) activity LED for visual feedback
				_ENDIF 						; Endif transmit interrupts disabled

				clrz						; Indicate char was accepted
			_ENDIF
			ret

;
; Wait for the transmit queue to empty and last byte to be sent.
; Called by the BSL-password checker in OnRxByte before disabling interrupts and branching to BSLErase.
; Called by SetID.
;
waitTxCmpl:
			_BEGIN						; Begin loop
				bit		#CCIE,&TACCTLt		; Test the transmit interrupts enabled bit
			_UNTIL	_Z					; Until it is cleared
			ret

;-------------------------------------------------------------------------------
TX_ISR:	; Transmit (timer capture/compare 0) interrupt service routine
;-------------------------------------------------------------------------------
; 1st interrupt BitCntTx is 10 (dec to 9), falling edge of start-bit just sent, need to set up for LSB
; 8th interrupt, BitCntTx is 3, just transitioned to data bit 6, need to set up for transition to MSB
; 9th interrupt, BitCntTx is 2, just transitioned to MSB, need to set up for transition to stop bit (1)
; 10th interrupt, BitCntTx is 1 (dec to 0), just transitioned to stop bit,
; need to set up for transition to next start bit if there is another byte in the tx queue
; or disable Tx interrupts if there are no more characters.

; But perhaps we should instead setup for a transition to idle state (same as stop bit)
; if there are no more characters.
; Then we would have an 11th interrupt where stop bit is complete and we disable Tx interrupts.
; But TX_ByteNW would still have to deal specially with the case where the queue becomes non-empty
; before the stop bit has finished. The question is whether it would be less messy than it is now,
; use less code, or not need to disable interrupts for so long. -- DK

											; (6) cycles for interrupt accepted
			add.w	&TxBitTime,&TACCRt		; (6) Set timer compare reg for when next transition is due
			dec.b	&BitCntTx				; (4) Decrement bit counter
			_IF		_NZ						; (2) If not Stop bit initiated

				cmp.b	#9,&BitCntTx			; (5) Test if start bit just started
				_IF		_EQ						; (2) If start bit just started
					push	R9
					mov.b 	&txrd,R9				; Get read index in R9
					mov.b	txbuf(R9),&TXData		; Get next char from queue into TXData
					inc.b 	R9						; Increment the read index
					and.b 	#txsz-1,R9				;	modulo the queue size.
					mov.b 	R9,&txrd				; Update the read index
					pop		R9
					; The below would just waste time and space. We don't need to wake up to do anything
					; in the mainline after taking a byte from the TX queue. -- DK
					; bic		#CPUOFF,0(SP)			; When return, wake CPU if needed
				_ENDIF							; Endif start bit just started
				rra.w	&TXData					; (1) Next bit to C. NOTE: upper byte remains $FF always,
												;	so stop and idle bits are always treated like data 1s
				_IF		_NC						; (2) If bit is 0
					mov		#OUTMOD_1+CCIE,&TACCTLt ; (5) then set TXDm = TA0 output high
				_ELSE							; (2) Else bit is 1
					mov		#OUTMOD_5+CCIE,&TACCTLt	; (5) Else clear TXDm = TA0 output low
				_ENDIF							; Endif bit is 1
			_ELSE							; Else Stop bit initiated
				cmp.b 	&txwr,&txrd				; Test if TX queue is empty
				_IF		_EQ						; If TX queue is empty
					bic.w	#CCIE,&TACCTLt			; (5) Disable Tx interrupts
					bis.b	#ACTLED,&P1OUT			; (5) Turn off activity LED at end of the transmit
				_ELSE							; Else TX queue is not empty
					mov.b	#8,&USICNT				; Load USI counter to keep USIIFG clear so TXDp (SCLK)
													;   will continue to be an inversion of TXDm (TA0).
					mov.b	#10,&BitCntTx			; Load bit transition counter: 10 bits
					mov.w	#OUTMOD_1+CCIE,&TACCTLt ; (5) Set output mode for start bit

					bic.b	#ACTLED,&P1OUT			; Turn on the activity LED for visual feedback.
				_ENDIF							; Endif TX queue is not empty
			_ENDIF							; Endif Stop bit initiated
			reti

;-------------------------------------------------------------------------------
RX_TIOV_ISR:	; Combined Receive (timer capture/compare 1) and timer overflow interrupt service routine
;-------------------------------------------------------------------------------
			; Warning: Do not be tempted to replace the two instructions below: mov &TAIV,R9 ; cmp #2,R9
			; with the single instruction cmp #2,&TAIV. This caused rare dropped bits on receive and
			; it took a lot of effort to trace the problem to this instruction.
			; It appears that despite only reading and not writing to its "destination" operand, the
			; compare instruction is still treated as making _two_ accesses to TAIV, in the sense that
			; it clears not only the interrupt flag being serviced but also any other TAIV interrupt
			; that might be pending, causing it to never be serviced.

											; (6) cycles for interrupt accepted
			push	R9						; (3) Save R9 (needed for queue use on last data bit anyway)
			mov		&TAIV,R9				; (3) Read the Timer-A interrupt sub-vector (one access only!)
			cmp		#2,R9					; (1) Was it a receive interrupt (TACCR1)
			jeq		RX_ISR					; (2) Yes, jump to receive interrupt service routine
			; Otherwise fall thru to timer overflow interrupt service routine
;
;	Regular timer overflow interrupt: Cause the mainline code to measure voltages etc
;
TIOV_ISR:
 			bic.b	#bNotMeasureTime,&monFlags ; Notify mainline that it's time to measure
			jmp		WakeExit				; Arrange to wake CPU, restore R9 and return from interrupt

;
;	Receive interrupt: Handle start-bit timer-capture or data-bit timer-compare
;
RX_ISR:		add		#BitTime96,&TACCRr		; (5) Time to next bit
			bit		#CAP,&TACCTLr			; (5) Capture mode = start bit edge
			_IF		_NZ						; (2) If start bit edge
				bic		#CAP,&TACCTLr		; (5) Switch to compare mode
				add		#BitTime96/2,&TACCRr; (5) First databit 1.5 bits from edge
			_ELSE							; (2) Else data bit sampled
				bit		#SCCI,&TACCTLr			; (4) Sampled bit to carry
				rrc.b	&RXData					; (4) Store received bit
				dec.b	&BitCntRx				; (4) All bits RXed?
				_IF		_Z						; (2) If this is the last data bit
					mov.b	#8,&BitCntRx			; Setup bit counter for next byte
					bis		#CAP,&TACCTLr			; Set back to capture mode

					; Put received data into the queue if there's space, otherwise it's lost
					mov.b	&rxwr,R9				; Get the write index
					mov.b	&RXData,rxbuf(R9)		; Tentatively write the character to the receive queue
													;  there's always at least one free space,
													;  but don't increment the write index yet.
					inc.b	R9						; Increment a copy of the write index
					and.b	#rxsz-1,R9				;  modulo the queue size
					cmp.b	&rxrd,R9				; If wr+1 mod sz = rd then it's full
					_IF		_NE						; If queue not full
						mov.b	R9,&rxwr				; Update write index so char is properly in queue
WakeExit				bic		#CPUOFF,2(SP)			; When return, wake CPU. 2(SP) due to saved R9
					_ENDIF							; Endif queue not full
				_ENDIF							; Endif last data bit
			_ENDIF							; Endif data bit sampled
			pop		R9						; (2) Restore R9
			reti							; (5) Return from interrupt


;--------------------------------------------------
; RX_Byte	; Subroutine Receives Character into R8
;			; Trashes R9
;--------------------------------------------------
#if 0
;
; Get a non-status character from the receive queue into R8.
; If necessary, wait until the queue is not empty.
; Process any Status bytes before returning. Trashes R9.
; NOT USED, and probably never will be
;
RX_Byte:
			_BEGIN
				call	#RX_ByteNW
			_UNTIL	_NZ
			ret
;
; Attempt to get a non-Status character from the receive queue into R8.
; If the queue is empty, return immediately with the Z status bit set.
; Process any Status bytes before returning. Trashes R9
; Currently NOT USED, except by RX_Byte above, which is currently unused
;
RX_ByteNW:
			_BEGIN
				call	#RX_RawByteNW	; This is the test for the pretested loop
				_WHILE	_NZ				; Exit when not _NZ
					tst.b	R8
					_WHILE	_L			; Additional exit when not _L
						call	#DoStatus
			_AGAIN						; For branch back to begin
					_ENDIF
				_ENDIF
			ret
#endif

;
; Attempt to get a character from the receive queue into R8.
; If the queue is empty, return immediately with the Z status bit set.
; Trashes R9
;
RX_RawByteNW:
			mov.b 	&rxrd,R9			; Get the read index into R9
			cmp.b 	&rxwr,R9			; Equal if queue empty
			_IF		_NE
				mov.b	rxbuf(R9),R8	; Read char from queue
				inc.b 	R9				; Increment the read index
				and.b 	#rxsz-1,R9		;	modulo the queue size
				mov.b 	R9,&rxrd		; Update the read index
				clrz					; Indicate char available
			_ENDIF
			ret

