;
; Command character definitions for the monitor
;

#include "../common/comDefinitions.s43"			; Include the definitions common to monitor
												; and TestICal

; checKsumming ( -- )						; Toggle bChecksumming
			; kk to turn checksumming off, k to turn it on (irrespective of current state)
			xCODE	'k',checksumming,_checksumming
			xor.b	#bChecksumming,&intFlags ; Toggle bChecksumming bit in intFlags
			ret

; Kill status sending ( boolean -- )		; 1 for no status, 0 for status
			xCODE	'K',KillStatus,_KillStatus
			allBitsIfNZ	Rtos,Rtos			; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bNotSendStatus,&monFlags ; Move only bNotSendStatus from Rtos to monFlags
			ret

; Freezing is stress ( boolean -- )			; 1 when charging or regenning, 0 when driving
			xCODE	'f',FreezeIsStress,_FreezeIsStress
			allBitsIfZ	Rtos,Rtos			; IF Rtos is zero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bNotFreezeStress,&monFlags ; Move only bNotSendStatus from Rtos to monFlags
			ret

#if PROG_START < $F800		// Commented out if need to save space
; Rx state ( -- )
			xCODE	'r',RxState,_RxState 	; Note: 'r' is read calibration value in TestICal
			mov		#'r',Rthd				; Type is Rx state
			mov.b	&ticksSinceLastRx,Rsec	; Result in ticks
;			mov		#3,Rtos					; Print 3 digits
			jmp		_prettyPrint3			; Tail-call pretty-print of 3 digits and return
#endif

; Stress ( -- )								; Report local stress
			xCODE	'p',Stress,_Stress		; 'p' for pain since we've already used 's' for select
			mov		#'p',Rthd				; Type is stress
			mov.b	&localStatus,Rsec		; Get local status
			and.b	#STRESS,Rsec			; Extract stress level, 0 to 15
;			mov		#3,Rtos					; Print 3 digits
			jmp		_prettyPrint3			; Tail-call pretty-print of 3 digits and return

; Query worst stress ( minStressToShow -- )
			xCODE	'q',queryWorstStress,_queryWorstStress
			cmp.b	Rtos,&worstStress
			_IF		_LO
				ret
			_ENDIF
			mov.b	#'q',Rthd				; Type is worst stress level
			mov.b	&worstStress,Rsec		; Result
			call	#_prettyPrint3			; Pretty-print of 3 digits
	#if WATCHDOG
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart watchdog timer
	#endif
			; Now prettyPrint the reason for the worst stress
			mov.b	&worstStressType,Rthd	; Type of measurement that caused worst stress
			mov		&worstStressMeas,Rsec	; Result
			mov		#4,Rtos					; Print 4 digits
			jmp		_prettyPrint			; Tail-call pretty-print and return

; Reset worst stress ( -- )
			xCODE	'{',resetWorstStress,_resetWorstStress ; Frowny mouth :-{ because irreversible
			clr.b	&worstStress
			mov.b	#' ',&worstStressType
			clr		&worstStressMeas
			ret

; Query reset-log ( maxResetsToShow -- )
			xCODE	'R',queryResetLog,_queryResetLog
			push	Rtos					; Save maxResetsToShow
			mov.b	#'R',Rthd				; Type is reset-log query
			mov.b	&resetCounter,Rsec		; Result
			mov		#5,Rtos					; Print 5 digits
			call	#_prettyPrint			; Pretty-print of 5 digits
	#if WATCHDOG
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart watchdog timer
	#endif

			; Now prettyPrint the reasons for the resets, in hex
			push.b	&intFlags				; Save current number base
			bis.b	#bHexOutput,&intFlags	; Set to hexadecimal output

			pop		R8						; Restore maxResetsToShow
			tst		R8						; Treat zero as infinity
			_IF		_Z
				mov		#$FFFF,R8
			_ENDIF
			cmp		&resetCounter,R8		; Take min of that and resetCounter
			_IF		_HS
				mov		&resetCounter,R8
			_ENDIF
			cmp		#16,R8					; Take min of that and 16
			_IF		_HS
				mov		#16,R8
			_ENDIF

			mov		&resetCounter,R9
			and		#$0F,R9
			add		#resetBuffer,R9

			_BEGIN
			tst		R8
			_WHILE	_NZ
			push	R8
			mov.b	#'R',Rthd				; Type is reset-log query
			dec		R9
			cmp		#resetBuffer,R9
			_IF		_LO
				mov		#resetBuffer+15,R9
			_ENDIF
			mov		@R9,Rsec				; Result
			push	R9
			call	#_prettyPrint3			; Call pretty-print for 3 digits
			pop		R9
	#if WATCHDOG
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart watchdog timer
	#endif
			pop		R8
			dec		R8
			_REPEAT

			pop.b	&intFlags				; Restore number base
			ret

; Reset reset-log ( -- )
			xCODE	'^',resetResetLog,_resetResetLog ; "^" so unlikely to type accidentally
			clr		&resetCounter
			mov		#resetBuffer,R8
			_BEGIN
			clr.b	0(R8)
			inc		R8
			cmp		#resetBuffer+16,R8
			_UNTIL	_EQ
			ret

