;
; Command character definitions for the monitor
;

#include "../common/comDefinitions.s43"			; Include the definitions common to monitor
												; and debugger
;
; Kill badness sending ( boolean -- )	; 1 for no badness, 0 for badness
;
			xCODE	'}',BadnessAutonomy_,_BadnessAutonomy
BadnessAutonomy	EQU		'K'					; Interpreter treats K as synonym for right-curly-brace
			allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bNotSendBad,&monFlags ; Move only bNotSendBad bit from Rtos to monFlags
			ret
		
; checKsumming ( -- )						; Toggle bChecksumming
			; kk to turn checksumming off, k to turn it on (irrespective of current state)
			xCODE	'k',checksumming,_checksumming
			xor.b	#bChecksumming,&intFlags ; Toggle bChecksumming bit in intFlags
			ret
#if 0 // FIXME!!!
; Rx state ( -- )
			xCODE	'r',RxState,_RxState ; Note: 'r' is read calibration value in debugger
			mov		#'R',Rthd				; Type is Rx state
			mov.b	&ticksSinceLastRx,Rsec	; Result in ticks
;			mov		#3,Rtos					; Print 3 digits
			jmp		_prettyPrint3			; Tail-call pretty-print of 3 digits and return
#endif

; Badness ( -- )
			xCODE	'b',Badness,_Badness
			mov		#'B',Rthd				; Type is badness
			mov.b	&localBadness,Rsec		; Result in badness levels, 0 to 7
;			mov		#3,Rtos					; Print 3 digits
			jmp		_prettyPrint3			; Tail-call pretty-print of 3 digits and return

; Query worst badness ( -- )
			xCODE	'q',queryWorstBadness,_queryWorstBadness
			mov.b	#'Q',Rthd				; Type is worst badness level
			mov.b	&worstBadness,Rsec		; Result
		;	mov		#3,Rtos					; Print 3 digits
			call	#_prettyPrint3			; Pretty-print of 3 digits
	#if WATCHDOG
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart watchdog timer
	#endif
			; Now prettyPrint the reason for the worst badness
			mov.b	#EXIT,R8				; Slosh
			call	#TX_ByteCk
			clr		R10
qloop:		mov.b	worstBadMeas(R10),R8	; next char of packet
			call	#TX_ByteCk
			inc		R10
			cmp		#14,R10
			jne		qloop
			
			call	#TX_Cksum				; Transmit checksum if required, then clear checksum.
			mov		#'\r',R8				; Carriage return to R8
			call	#TX_Byte				; Emit

			mov.b	#'X',Rthd				; 'X' for XOR checksum
			mov.b	&worstBadType,Rsec		; Residual checksum
			; mov		#3,Rtos				; Print 3 digits
			jmp		_prettyPrint3			; Tail-call pretty-print and return
//			mov		&worstBadType,Rthd		; Type of measurement that caused worst badness
//			mov		&worstBadMeas,Rsec		; Result
//			mov		#4,Rtos					; Print 4 digits
//			jmp		_prettyPrint			; Tail-call pretty-print and return
		
; Reset worst badness ( -- )
			xCODE	'{',resetWorstBadness,_resetWorstBadness ; Frowny mouth :-{ because irreversible
			clr.b	&worstBadness
//			mov.b	#' ',&worstBadType
//			clr		&worstBadMeas
						clr.b	&worstBadType
						mov		#worstBadMeas,R9
						mov		#7,R10
clrloop					clr.w	0(R9)
						incd	R9
						dec		R10
						jnz		clrloop
			ret
			
#if 0			// FIXME!!!
; Alarm ( boolean -- )
			xCODE	'a',Alarm,_Alarm
	#if 1
			; Relies on bAlarmForBad being in bit 0
		;	allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bAlarmForBad,&monFlags ; Move only bAlarmForBad bit from Rtos to monFlags
	#else								; Trashes Rtos
			tst		Rtos
			_IF		_NZ
				bic.b		#bAlarmForBad,&monFlags
			_ELSE
				bis.b		#bAlarmForBad,&monFlags
			_ENDIF
	#endif
			ret
#endif
