; Suitable usage at appropriate part of assembly file: #include IntMeasure.s43

; MeasureIsr - measurement interrupt service routine.
; Called as a timer compare-register interrupt.
; CMU: TA0CCR2 (ScuRx on BMU), BMU: TA1CCR1 (was SocPWM).
; Perform an analogue measurement 1600 times a second.

; If we need to do an analog SoC meter in future, we can do it at 16 Hz with a resolution of 100
; in this interrupt routine.

MeasureSubIsr:
			push	R8						; (3)
			add		#(TAfreq+800)/1600, &MeasCCRp ; (5) Ensure we are called at close to 1600 Hz

			; Read and accumulate the result from the previous conversion
			add		&ADC10MEM, &partialSum	; (6) Add the conversion result to the partial sum
			bic		#ENC,&ADC10CTL0 		; (4) Must turn off ENC bit before ctl bits can be changed
			mov.b	&sampIndex, R8			; (3) Increment the sample index modulo 16
			inc		R8						; (1)
			and		#$F, R8					; (2)
			mov.b	R8, &sampIndex			; (4)
			_IF		Z						; (2) If the sample index is now zero
				mov.b	&chanIndex, R8			; (3)
				mov		&partialSum, rawMeasures(R8) ; (6) Save the sum as the channel's raw measurement
				clr		&partialSum				; (4) Clear for next set of 16 conversions
				incd	R8						; (1) Increment the channel index modulo 4 words
				and		#$7, R8					; (2)
				mov.b	R8, &chanIndex			; (4)
				mov		chanList(R8), &ADC10CTL1 ; (6) Set the ADC channel number and clock
			_ENDIF

			; Initiate the next conversion
			bis		#ENC|ADC10SC,&ADC10CTL0	; (4) Start conversion. ADC10SC is reset automatically
			pop		R8						; (2)

			ret								; (11 for call and return) Max total 76 cycles (3.2% of CPU)


; Scale
; Input:  R8  = raw measurement in 12.2 fixed-point
; Output: R10 = 12-bit measurement result with scale calibration applied.
; Trashes: R8, R9, R11
;
; Scale the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration scale factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
;
Scale:
			mov.w		&VoltCal,R9				; Get voltage calibration word as multiplicand in R9
												; Multiplier is sum-of-samples, already in R8
			call		#UMStar					; Gives unsigned product in R10 (hi word) and R9 (lo word)
			inc			R10						; For correct rounding
			rra			R10						; Shift product hi word right one bit
			ret									; Finished

BatV:
cellV:
; Trashes: R8, R9, R11
; Output: R10 = calibrated in millivolts, approx range 0 to 4095
			mov		&cellVRaw,R8
			jmp		Scale						; Tail-call Scale and return

CapV:		; When used by (w)monolith to check precharge
ArrayV:
BoltV:
; Trashes: R8, R9, R11
; Output: R10 = calibrated in millivolts, approx range 0 to 4095
			mov		&boltVPlRaw,R8
			jmp		Scale						; Tail-call Scale and return


temp:
; Output: R10 = temperature calibrated in degrees Celsius, approx range ???
; Trashes: R8, R9, R11
			mov		&temperatureRaw,R8
			call	#Scale
			; Scale it back to degrees Celsius. Typically, T = (V-0.986)/.00355
			; But the measurement M is 4092* V/1.5 = 2728*V.
			; So T = (M/2728 - 0.986)*281.7 = M/9.684 - 277.7
			; To divide by 9.684 counts/°C, multiply by 65536/9.684 = 6767, and keep the top half
			mov		R10,R8
			mov		#6767,R9
			call	#UMStar					; R10:R9 = meas*6767 so M/9.684 to R10
			sub		#278,R10				; M/9.684 - 277.7
			mov.b	&TempCal,R8
			sxt		R8
			sub		R8,R10					; R10 has temperature in degrees Celsius
			ret

#ifdef KINGSCLIFF_DCM
extT:	; Temp of external thermistor. Called from 'H' command. Used in white monolith prototype.
; Uses Vishay NTCLE413E2103F102L NTC thermistor (R_25^C = 10k, K = 3435) from Digikey.
; CMU mods are R17 (bottom of divider) = 12k4. R4c (in parallel with thermistor) = 10k5.
; R4b (in series with thermistor) = 11k3. R4a is removed.
; Vcc (2.5 V) from reg is fed into R4b via connected R4a pad. Thermistor is connected across R4c.
; This resistor network is designed to make the thermistor input have a similar V/T relationship to
; the MSP430's internal temperature sensor, within 1^C from 0^C to 55^C,
; within 2^C between -4^C and 57^C, within 3^C between -9^C and 61^C, ignoring component tolerances.
; Output: R10 = temperature in degrees Celsius
; Trashes: R8, R9, R11
			mov		&boltVPlRaw,R8
			call	#Scale
			; Scale it back to degrees Celsius. Typically, T = (V-Voff)/.00355 where Voff = 0.986
			; But the measurement M is 4096* V/1.5 = 2731*V.
			; So T = (M/2731 - Koff1)*281.7 = M/9.694 - Koff2
			; To divide by 9.694 counts/°C, multiply by 65536/9.694 = 6760, and keep the top half
			mov		R10,R8
			mov		#6760,R9
			call	#UMStar					; R10:R9 = meas*6760 so M/9.694 to R10
			sub		#273,R10				; M/9.694 - 273
			mov.b	&ThermCal,R8
			sxt		R8
			sub		R8,R10					; R10 has temperature in degrees Celsius
			ret
#endif


linkV:
; Output: R10 = calibrated in millivolts, approx range -1500 to +1500.
; 9999 means linkV not valid, ignore.
; Trashes: R8, R9, R11
			mov.b		&LinkCal,R8		; Link offset calibration
			cmp.b		#$80,R8			; $80 is a special value representing "calibration failure"
			_IF			EQ				; If link calibration value is $80
				mov		#9999,R10			; then use special value
			_ELSE
				mov			&boltVMiRaw,R8
				call		#Scale
				; Link voltage measurement in mV
				; Circuit has 2:1 voltage divider with Vref at the bottom.
				; So measure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
				; Reading = 2048 + (Vin/2)(4096/1.5)
				; R = 2048 + Vin * 1365.3 (Vin in volts)
				; R = 2048 + Vin * 1.3653 (Vin in mV)
				; Vin = (R - 2048)/1.3653 mV
				; To divide by 1.3653, multiply by 65536/1.3653 = 48001 and keep the top half
				sub			#2048,R10
				mov.b		&LinkCal,R8		; Link offset calibration
				sxt			R8				; Sign extend
				sub			R8,R10
				_IF			NN
					mov			R10,R8
					mov			#48001,R9
					call		#UMStar
					; Most significant half is in R10
				_ELSE
					inv			R10
					inc			R10				; Negate
					mov			R10,R8
					mov			#48001,R9
					call		#UMStar
					inv			R10				; Only interested in top half
					inc			R10				; Negate back
				_ENDIF
			_ENDIF
			ret

#if INSULATION_MONITORING & G2553
touchV:
; Trashes: R8, R9, R11
; Output: R10 = uncalibrated reading (affected by optocoupler CTR), approx range 0 to 4095
			mov		#TouchVChan<<12,R8
			jmp		measAndScale				; Tail-call measAndScale and return
#endif // INSULATION_MONITORING
