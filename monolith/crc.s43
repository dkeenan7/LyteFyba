;  CRC-16-CCITT routines for talking to PIP-4048 inverter/charger
;  Assumes global variable crc_pip

; 	INT16U crc_ta[16]=
;	{
;		0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
;		0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef
;	};
crc_ta		DW		$0000,$1021,$2042,$3063,$4084,$50a5,$60c6,$70e7
			DW		$8108,$9129,$a14a,$b16b,$c18c,$d1ad,$e1ce,$f1ef
#define Rda		R9		// Variable da assigned R9

; Pass char to include into CRC in R8
; Destroys R9-R10, preserves R8
updCRCpip:
			; da=((INT8U)(crc>>8))>>4;
			mov		&crc_pip,Rda
			swpb	Rda
			rra4	Rda
			and.b	#$0F, Rda		; Clean off top byte and effects of arithmetic shift

			; crc<<=4;
			rla4	&crc_pip

			; crc^=crc_ta[da^(*ptr>>4)];
			mov.b	R8, R10
			rra4	R10				; R10 := *ptr >> 4
			and.b	#$0F,R10
			xor.b	R10,R9			; R9 := da ^ (*ptr>>4)
			rla.b	R9				; Double for word index
			xor		crc_ta(R9), &crc_pip

			; da=((INT8U)(crc>>8))>>4;
			mov		&crc_pip,Rda
			swpb	Rda
			rra4	Rda
			and.b	#$0F, Rda		; Clean off top byte and effects of arithmetic shift

			; crc<<=4;
			rla4	&crc_pip

			; crc^=crc_ta[da^(*ptr&0x0f)];
			; Could have used R8 below, but prefer to preserve R8
			mov.b	R8,R10
			and.b	#$0F,R10		; R10 := *ptr & 0xF
			xor.b	R10,R9			; R9 := da ^ (*ptr&0x0f)
			rla.b	R9				; Double for word index
			xor		crc_ta(R9), &crc_pip

			ret

; Send the two CRC bytes, MSB first
; Trashes R8-R9
TX_CRC_pip:
			mov.b	&crc_pip+1,R8	; Get MSB
			cmp.b	#'(',R8			; If CRC byte would be open paren,
			jeq		mod1
			cmp.b	#$0D,R8			;	or CR
			jeq		mod1
			cmp.b	#$0A,R8			;	or LF,
			jne		nomod1
mod1		inc.b	R8				; ... then modify by incrementing that byte
nomod1		call	#TX_Byte			; Send MSB of CRC first
				_DO		#5560,R12			; Delay for approx ...
				_LOOP	R12					;	... 4.16 ms
			mov.b	&crc_pip,R8		; Get LSB of CRC
			cmp.b	#'(',R8			; If CRC byte would be open paren,
			jeq		mod2
			cmp.b	#$0D,R8			;	or CR
			jeq		mod2
			cmp.b	#$0A,R8			;	or LF,
			jne		nomod2
mod2		inc.b	R8				; ... then modify by incrementing that byte
nomod2		call	#TX_Byte		; Send MSB of CRC first
				_DO		#5560,R12			; Delay for approx ...
				_LOOP	R12					;	... 4.16 ms
			ret