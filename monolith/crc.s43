;  CRC-16-CCITT routines for talking to PIP-4048 inverter/charger
;  Assumes global variable crc_pip

; 	INT16U crc_ta[16]=
;	{
;		0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,
;		0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef
;	};
crc_ta		DW		$0000,$1021,$2042,$3063,$4084,$50a5,$60c6,$70e7
			DW		$8108,$9129,$a14a,$b16b,$c18c,$d1ad,$e1ce,$f1ef
#define Rda		R9		// Variable da assigned R9

; Pass char to include into CRC in R8
; Destroys R9-R10, preserves R8
updCRCpip:
			; da=((INT8U)(crc>>8))>>4;
			mov		&crc_pip,R9
			swpb	Rda
			rra4	Rda
			and.b	#$0F, Rda		; Clean off top byte and effects of arithmetic shift

			; crc<<=4;
			rla4	&crc_pip

			; crc^=crc_ta[da^(*ptr>>4)];
			mov.b	R8, R10
			rra4	R10
			and		#$0F, R10		; R10 := *ptr >> 4
			xor		R10,R9			; R9 := da ^ (*ptr>>4)
			xor		crc_ta(R9), &crc_pip

			; da=((INT8U)(crc>>8))>>4;
			mov		&crc_pip,R9
			swpb	Rda
			rra4	Rda
			and.b	#$0F, Rda		; Clean off top byte and effects of arithmetic shift

			; crc<<=4;
			rla4	&crc_pip

			; crc^=crc_ta[da^(*ptr&0x0f)];
			xor		R10,R9			; Restore R9 to be da
			; Could have used R8 below, but prefer to preserve R8
			mov.b	R8,R10
			and		#$0F,R10		; R10 := *ptr & 0xF
			xor		R10,R9			; R9 := da ^ (*ptr>>4)
			xor		crc_ta(R9), &crc_pip

			ret

; Send the two CRC bytes, MSB first
TX_CRC_pip:
			mov		&crc_pip,R9
			mov.b	R9,R8
			swpb	R8
			cmp.b	#'(',R8			; If CRC byte would be open paren,
			jeq		mod1
			cmp.b	#$0D,R8			;	or CR
			jeq		mod1
			cmp.b	#$0A,R8			;	or LF,
			jne		nomod1
mod1:		inc.b	R8				; ... then modify by incrementing that byte
nomod1:		call	TX_Byte			; Send MSB of CRC first
			mov.b	R9,R8
			swpb	R8
			cmp.b	#'(',R8			; If CRC byte would be open paren,
			jeq		mod2
			cmp.b	#$0D,R8			;	or CR
			jeq		mod2
			cmp.b	#$0A,R8			;	or LF,
			jne		nomod2
mod2:		inc.b	R8				; ... then modify by incrementing that byte
nomod2:		call	TX_Byte			; Send MSB of CRC first
			ret