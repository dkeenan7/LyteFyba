			COL		154				; Wide listings
; 14/Dec/2014: split off from monitor.s43

; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve calibration data.
;
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Output options to:
;  Allow C-SPY-specific extra output file
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	monolith.bin
;	Output format: raw-binary
;
; This software has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for solar power systems.
;
; "Monolith" is the standard operating software for our cell-top
; Cell Monitoring Unit (CMU) based on an MSP430 microcontroller.
#define Monolith				// Used for some conditional assembly in otherwise common code

#define REV61	1				// Enable conditional assembly for board rev 61 or later

; Some definitions so the measure.s43 code will work
; TestICal defines these as their ram counterparts instead of info-flash
#define VoltCal infoVoltCal
#define TempCal	infoTempCal
#define LinkCal	infoLinkCal

LSTOUT-
#include "msp430.h"							// MSP430 Special Function Register definitions
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Assembler macros for obscure instruction sequences
			LSTOUT+
#include "../common/common.h"				// Definitions common to monitor, TestICal and BSL

; Some definitions so the measure.s43 code will work
; TestICal defines these as their ram counterparts instead of info-flash
#define VoltCal infoVoltCal
#define TempCal	infoTempCal
#define LinkCal	infoLinkCal


			NAME	main		; Module name
			PUBLIC	main		; Make the "main" label visible for IAR debugger


ID			EQU		infoID			; We use the info-flash copy of the ID for s, x, prettyPrint
									; commands. TestICal uses the ram copy

; Command Character Interpreter Register Usage (defined in CmdCharInterpreter.s43)
;	Registers 0 thru 3 are dedicated machine registers (PC SP SR CG).
#define		Rip		R5				// Interpreter instruction pointer
#define		Rlit	R6				// Holds partial literals
#define		Rtos	R7				// Top of interpreter data stack
#define		Rsec	R4				// Second element from top
#define		Rw		R8				// Working register - temporary - anyone can use

; Conditional assembly
#define		WATCHDOG	1			// True if watchdog timer is to be used (only turn off for debugging)
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer.
									// Buffered ADC is mainly useful for debugging.
#define		MASTERLESS_CHARGING 1	// Can leave out the masterless charging code if not needed.
#define		INSULATION_MONITORING 0	// Can leave out the insulation monitoring code if not needed.
									// Can't fit both of the above in 4k.
; Constants

; Stress calculations
; The stress set-point for charger back-off is 7.
; This set-point of 7 is implemented in the IMU's PI controller.
; So 8 is the lowest dis-stress. Alarm is given at stress 11. Contactor dropout at 12. Shutdown at 15.
#define WHINGE 0
#if !WHINGE
// OV = Over Voltage: One stress unit for each 40 mV in excess of 3.128 V, to a max of 15 at >= 3.728 V
// OV setpoint is 3.408 to 3.448 V. Bypass at 3.368. Alarm at 3.556. Drop out source contactors at 3.608
OV_ZERO		EQU		3128		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		40			; mV difference between one OV stress level and the next
; These were an attempt to float at the 75% step
;// OV = Over Voltage: One stress unit for each 3 mV in excess of 3.332 V, to a max of 15 at >= 3.377 V
;// OV setpoint is 3.353 to 3.356 V. Alarm at 3.365 V. Drop out source contactors at 3.368 V.
;OV_ZERO		EQU		3332		; Threshold in mV between OV stress levels -1 and 0
;OV_STEP		EQU		3			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 20 mV below 3.460 V, to a maximum of 15 at <= 3.16 V
// UV setpoint is 3.32 to 3.12 V. Alarm at 3.24 V. Drop out load contactor at 3.22.
UV_ZERO		EQU		3460		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-20			; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 32C, to a max of 15 at >= 62degC
// OT setpoint is 46 to 48 degC. Alarm at 54 degC. Dropout source contactors at 56 degC.
OT_ZERO		EQU		32			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		2			; Degrees C difference between one OT stress level and the next
// UT = Under Temperature: One stress unit for every 2 degree C below 24C, to a max of 15 at <= -6degC
// UT setpoint is 10 to 8 degC. Alarm at 2 degC. Source contactor dropout at 0 degC.
UT_ZERO		EQU		24			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-2			; Degrees C difference between one UT stress level and the next
// AL = Absolute Link voltage: Disabled because the hardware does not measure it reliably.
// Plan to implement positive and negative bolt voltages in future.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		3000		; mV difference between one AL stress level and the next

#else
// OV = Over Voltage: One stress unit for each 10 mV in excess of 3.500 V, to a max of 15 at >= 3.65 V
// OV setpoint is 3.57 to 3.58 V. Alarm at 3.61 V.
OV_ZERO		EQU		3400		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		10			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 40 mV below 2.500 V, to a maximum of 15 at <= 1.90 V
// UV setpoint is 2.18 to 2.22 V. Alarm at 2.06 V.
UV_ZERO		EQU		3200		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-50			; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 40C, to a max of 15 at >= 55degC
// OT setpoint is 47 to 48 degC. Alarm at 51 degC.
OT_ZERO		EQU		40			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		1			; Degrees C difference between one OT stress level and the next
// UT = Under Temperature: One stress unit for every 1 degree C below 11C, to a max of 15 at <= -4degC
// UT setpoint is 4 to 3 degC. Alarm at 0degC.
UT_ZERO		EQU		11			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-1			; Degrees C difference between one UT stress level and the next
// AL = Absolute Link voltage: One stress unit for every 20 mV above 0 mV, to a max of 15 at >= 300 mV
// AL setpoint is 140 to 160 mV. Alarm at 220 mV.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		3000		; mV difference between one AL stress level and the next
#endif

; FULLLEV	EQU	OV_ZERO+7*OV_STEP	; Considered Full (charge termination and coulomb counter reset)
									;	3408 mV. Stress 6/7 threshold
; BYPLEV	EQU	OV_ZERO+6*OV_STEP	; Bypass threshold 3368 mV. Corresp. to stress 5/6 threshold

MinAlarmStress EQU	11			; Minimum stress to light error LED and beep
MinContStress EQU	12			; Minimum stress to drop out source or load contactors (IMU only)

ComErrTicks	EQU		9			; Minimum ticks without receiving valid status byte before
								;	taking on master duties and reporting comms error (if ID not 1)

; Status byte bit masks - Used for localStatus in RAM as well as RXed and TXed status bytes
COM_ERR		EQU		1<<6			; Communications error
UV_AF		EQU		1<<5			; Stress type is UnderVoltage (ignore on charge) when bit 4 is clear
									;	or cells are All considered Full when bit 4 is set
OV_UT		EQU		1<<4			; Stress type is OverVoltage or UnderTemp (ignore on discharge)
ALL_FULL	EQU		1<<4 | 1<<5		; When both type bits are set it means All considered Full
									;   (reset to 0% DoD) as well as OverVoltage (ignore on discharge)
									; When both type bits are clear it means OverTemp (never ignore)
TYPE		EQU		$30				; Stress type field mask. Bits 4-5
STRESS		EQU		$0F				; Stress level field mask. Bits 0-3

SourceCont	EQU	RELAYm				; Source contactor MOSFET and yellow LED
LoadCont	EQU RELAYp				; Load contactor MOSFET and magenta LED

; ADC channel numbers
CellVChan	EQU		$7				; ADC channel number for cell voltage
TempChan	EQU		$A				; ADC channel number for temperature
LinkVChan	EQU		$6				; ADC channel number for link voltage
TouchVChan	EQU		$3				; ADC channel number for touch voltage (IMUs only)
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)

; Serialio definitions (Here because used in initialisation)
#define		TACCTLr		TACCTL1		// Receive using CCI1 (P1.2)
#define		TACCTLt		TACCTL0		// Transmit (and everything else) using TA0
#define		TACCRt		TACCR0		// Transmit compare register
#define		TACCRr		TACCR1		// Receive capture/compare register

;
; RAM allocation
;
				ORG		$200		; Start of RAM. Ends at $27F
; This area is common to both Monitor and TestICal and is not erased on a reset
bsl2state		DS		2			; Password recogniser state for BSL2
resetCounter	DS		2			; Number of resets since the last "^" command
resetBuffer		DS		16			; Circular buffer recording the reason for the last 16 resets
discharge		DS		4			; Accumulator for depth of discharge determination.
									; Unit is 1/5 A for 8/15 s = 8/75 coulomb = 8/270 milliamphour.
									; So 32 bits allows 127,200 Ah, but 24 bits would only allow 497 Ah.
pwmAdv			DS		2			; Amount to add to TACCTL2 for next compare value
comNoEraseEnd

#if	ADCBUF
				ALIGNRAM 1
sampleBuf		DS		2*NumSamples ; ADC sample buffer; 4 or 16 samples
#endif

monFlags		DS		1			; Monitor flags, bitmask definitions follow
bNotSendStatus	EQU		1<<0		; Zero if sending status bytes at all
bNotMeasureTime EQU		1<<1		; Zero if time to measure
bCharging		EQU		1<<2		; 1 if charging or regen. See 'c' command.
bChargerControl	EQU		1<<3		; 1 in charger control mode (masterless operation). See 'o' command.
bBadInsulation	EQU		1<<4		; 1 if the last insulation test failed. (IMU only)
bDonePipInit	EQU		1<<5		; 1 if have done PIP initialisation

localStatus		DS		1			; Bits 0-3 stress, 4 ignore-on-dis, 5 ignore-on-chg, 6 comms error
ticksSinceLastRx DS		1			; Timer overflow events since last valid status received
statusFreqCtr	DS		1			; To time various infrequent tasks in DoMeasurement. Allowed to wrap
passWordState	DS		1			; State machine for password recogniser

; Charger controller variables

chargerTxTimer	DS		1			; To keep charger packet transmission to the minimum required.
				ALIGNRAM 1
chargerVoltMin	DS		2			; Charger voltage minimum (tenths of a volt). Set by 'o' command.
chargerVoltMax	DS		2			; Charger voltage maximum (tenths of a volt). Set by 'o' command.
piPrevOutput	DS		2			; State of PI controller
piPrevError		DS		2			; State of PI controller
prevBulk		DS		2			; Previous Bulk/Absorb voltage (tenths of a volt) sent to PIP.
prevFloat		DS		2			; Previous Float voltage (tenths of a volt) sent to PIP.
lastWasFloat	DS		2			; True (nonzero) if last voltage command sent to PIP was for float.
uPipInitCtr		DS		2			; Counts timer overflows till the PIP is ready to receive commands
PipWait			EQU		2*StatusFreq ; Number of the above that will be required (2 seconds)
BatCapacity		EQU		1800		; Battery capacity in tenths of an amp-hour
CellResistance	EQU		10			; Cell internal resistance in tenths of a milliohm
AllFullDod		EQU		0			; DoD in tenths of a percent, to reset discharge counter to when all considered full
;AllFullDod		EQU		250			; DoD in tenths of a percent, to reset discharge counter to when all considered full
ChargerVoltMin	EQU		530			; Lower limit of PI controller output. In tenths of a volt.
ChargerVoltMax	EQU		570			; Upper limit of PI controller output. In tenths of a volt.
;ChargerVoltMin	EQU		526			; Lower limit of PI controller output. In tenths of a volt.
;ChargerVoltMax	EQU		546			; Upper limit of PI controller output. In tenths of a volt.
current			DS		2			; Current most recently reported by IMU in tenths of an amp (signed)
smoothStressX4	DS		1			; Moving average of stress used by IMU to control contactors

; Serial-io variables

				ALIGNRAM 1
txBitTime		DS		2			; Determines transmit baud rate. 104 for 9600 baud, 417 for 2400 baud
txData			DS		2			; Byte to transmit in lower byte; always $FF in high byte
rxData			DS		1			; Received char
bitCntTx		DS		1			; Bit count 10 -> 1
bitCntRx		DS		1			; Bit count 8 -> 1
txCksum			DS		1			; Simple xor checksum used on transmit
				ALIGNRAM 1
txCrc			DS		2			; CRC-16-CCITT for transmitting to PIP-4048MS inverter-charger

RxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
TxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
rxBuf			DS		RxSz		; Receive queue buffer
rxWr			DS		1			; Receive queue write index
rxRd			DS		1			; Receive queue read index
txBuf			DS		TxSz		; Transmit queue buffer
txWr			DS		1			; Transmit queue write index
txRd			DS		1			; Transmit queue read index

; Command Character Interpreter variables

rxCksum			DS		1			; Received packet xor checksum
intFlags		DS		1			; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1<<0		; Should numeric output be in hexadecimal, not decimal?
bChecksumming	EQU		1<<1		; Are we sending checksums and checking received checksums?
bDontInterpret	EQU		1<<2		; Are we interpreting?
bDontEcho		EQU		1<<3		; Are we echoing?

				ALIGNRAM 1
ovZero			DS		2			; Overvoltage zero, set by 'VP command (param1 - 7 * param2)
ovStep			DS		2			; Overvoltage step, set by 'VP command (param2)

				ALIGNRAM 1			; A kind of trip-meter for this cell's stress
worstStress		DS		1			; Worst local stress since the last resetWorstStress command
worstStressType	DS		1			; Type of measurement that caused worst stress
worstOV			DS		2			; Worst over-voltage since the last resetWorstStress command
worstUV			DS		2			; Worst under-voltage since the last resetWorstStress command
worstOT			DS		2			; Worst over-temperature since the last resetWorstStress command
worstUT			DS		2			; Worst under-temperature since the last resetWorstStress command
worstAL			DS		2			; Worst absolute link voltage since the last resetWorstStress command
; The 5 variables above are also treated as an array indexed from worstStress, so order matters

				ALIGNRAM 1
ToIN			DS		2			; Pointer to present character being stored in Text Input Buffer
TIB				DS		48			; Text Input Buffer (packet buffer)
TIBEnd
; Must leave room for stack (about 36 bytes minimum)
STACKSPACE		EQU		$300-$		; Look at listing to see what this is

;-------------------------------------------------------------------------------
				ORG		PROG_START
;-------------------------------------------------------------------------------

InterpretByte:
main:										; For IAR Embedded Workbench IDE debugger
			mov.w	#$300,SP				; Initialize stackpointer
#if !WATCHDOG
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (bad idea, except while debugging)
#else
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable Watchdog Timer (32k)
#endif
			; Clear all variables in RAM except resetBuffer and IMU's fuel gauge discharge accumulator
			; and worstStress (and ToIN/TIB)
			_DO		#worstStress-comNoEraseEnd,R8
				clr		comNoEraseEnd-2(R8)
			_mLOOP	#2,R8

			; LOG2 -- The following preprocessor-macro gem is due to Dave Keenan.
			; It is based on a Taylor series expansion. It is valid for the domain 1-64, and range 0-6.
			; NOTE: It depends on the assembler rounding toward zero (truncated division).
			; There is a similar simple formula for rounding towards negative infinity (floored division).
#define LOG2(x) (4 * (x-8) / (x+8) + 3)

			; Initialise clocks. SMCLK is only used by comms timer and watchdog timer.
			; DIVS_1 => SMCLK = DCOCLK/2	DIVS_2 -> SMCK = DOCLK/4
			; DIVM_1 => MCLK = DCOCLK/2
			mov.b	#DIVM_1+LOG2(DCOckPerSMck)*DIVS_1, &BCSCTL2
			mov.b	&info8MHzCalB,&BCSCTL1	; 8 MHz DCO cal data
			mov.b	&info8MHzCalD,&DCOCTL
			; Prepare ACLK for piezo drive -- 3 kHz square wave
			bis.b	#LFXT1S_2,&BCSCTL3		; Select VLOCLK (~12 kHz) as source for ACLK divider

;
;	Initialise timer and interrupt comms
;
			; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
			; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
			; MC: 2 = continuous mode 1 = up mode
			; TAIE = interrupt enable (for timer overflow)
			mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2 + TAIE, &TACTL

			; Initialise IO ports
			mov.b	#RXD+TXDm,&P1SEL			; Select timer functions CCI1A and TA0 (not I/O port)
#if REV61
			clr.b	&P1OUT						; All outputs low on port 1
			mov.b	#VREFp|TXDp|TXDm|PIEZO,&P1DIR ; Set VREFp, TX bits and piezo as outputs
			cmp.b	#255,&ID
			_IF		_EQ
				bis.b	#PWMOUT,&P1DIR				; For IMU only, set P1.3 as an output (SoC PWM)
				mov.w	#CCIE,&TACCTL2				; TACCR2: compare only, enable interrupts (SoC PWM)
			_ENDIF
#else
			mov.b	#ACTLED,&P1OUT				; All outputs low, except (inverted) ActLED, on port 1
			cmp.b	#255,&ID					; If we're not an IMU
			_IF		_NE
				mov.b	#ACTLED|VREFp|TXDp|TXDm|PIEZO,&P1DIR ; Set ACTLED, VREFp, TXs, piezo as outputs
			_ELSE
				mov.b	#VREFp|TXDp|TXDm|PIEZO,&P1DIR ; Set VREFp, TX bits and piezo as outputs
			_ENDIF
#endif
			mov.b	#0,&P2SEL					; Set BYPASS and ERRLED to not be crystal osc pins
			mov.b	#0,&P2OUT					; Set BYPASS and ERRLED off (RLY- and RLY+ if IMU)
			cmp.b	#255,&ID
			_IF		_EQ							; If we're an IMU
				bis.b	#LoadCont,&P2OUT				; Set load contactor on so battery contactor goes on
													; and we stay powered up
			_ENDIF
			mov.b	#$FF,&P2DIR					; Set BYPASS and ERRLED (RLY- and RLY+) as outputs

			; Set up differential timer outputs for transmit data.
			; Tricky way of getting inverted TA0 to appear on P1.5 automatically
			; when TA0 appears on P1.1.
			; We use the clock inverter in the USI (Universal Serial Interface)
			; to invert TA0 and put it out as SCLK, in SPI master mode.
			; We don't use the shift register of the USI because there is
			; no way to get differential outputs from that without external hardware.
			mov.b	#USIPE5 + USIMST, &USICTL0	; SCLK out on P1.5, SPI Master mode, remove SW Reset
			mov.b	#USIDIV_0 + USISSEL_5 + USICKPL, &USICKCTL ; SCLK source is TA0, div by 1, inverted
			mov.b	#8, &USICNT					; To clear USIIFG so SCLK will not be held

			; Make TA0 (output of Timer-A capture/compare unit 0) appear on P1.1
			; We want to set the CCIFG so that TxByte won't think there's an uncompleted stop bit
			; and wait for it to complete.
			mov		&TAR,&TACCRt				; Make an output event
			add		#4,&TACCRt					;	happen in a dozen or so instructions
			; NOTE: the above has to be enough to get past setting of OUTMOD_5 for TACCTLt below
			mov.w	#OUTMOD_0 + OUT, &TACCTLt	; TA0=1 Space; seems necessary to "wake up" SCLK divider
			mov.w	#OUTMOD_5, &TACCTLt			; When the compare happens, set TA0=0 Idle or Mark

			mov.w	#BitTime96,&txBitTime		; Set the bit time for 9600 baud
			mov.b	#$FF,&txData+1				; Initialise the top half of txData to all 1s (stop bit,
												;	idle bit)
			mov.b	#8,&bitCntRx				; Load Bit Counter, 8 data bits
;			clr.b	txCksum						; Clear transmit checksum. Already cleared by loop above
			mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&TACCTLr	; Falling edge, Input A, Sync, Capture
			; Already cleared by loop above
;			clr.b	&rxWr						; Initialise the TX and RX queue indexes
;			clr.b	&rxRd
;			clr.b	&txWr
;			clr.b	&txRd

;
; Initialise the charger controller
;
			; Already cleared by loop above
;			clr.b	&chargerTxTimer				; Initialise charger transmit timer
			cmp.b	#255,&ID					; If we're an IMU (Insulation/current Monitoring Unit)
			_IF		_EQ
				mov.w	#ChargerVoltMin,&chargerVoltMin ; Initialise charger voltage min
				mov.w	#ChargerVoltMax,&chargerVoltMax ; Initialise charger voltage max
				bis.b	#bChargerControl,&monFlags	; Set by o command
				bis.b	#bCharging,&monFlags		; Set by c command
			_ENDIF
;			clr.w	&piPrevOutput				; Initialise PI controller state
;			clr.w	&piPrevError				;
;			clr.w	&chargerPrevCurr			; Initialise charger current


			mov.w	#OV_ZERO,&ovZero
			mov.w	#OV_STEP,&ovStep

;
; Initialise the ADC10
;
			cmp.b	#255,&ID					; If we're not an IMU (Insulation Monitoring Unit)
			_IF		_NE
				; Enable cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				mov.b		#(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ELSE
				; Enable cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				; No longer TouchVChan
				mov.b		#(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ENDIF
			; Initialise ADC10
			; SREF_1	= +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temp)
			; REFOUT	= connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			mov			#SREF_1+ADC10SHT_3+REFOUT+REFON,&ADC10CTL0
			; Other ADC10 initialisation is done every time "measure" is called, to save code space

;
; Initialise the command character interpreter
;
			;	Already cleared by loop above
;			clr.b	&RXCksum				; Clear received packet xor checksum
			cmp.b	#255,&ID					; If we're not an IMU
			_IF		_NE
				mov.b	#bChecksumming,&intFlags ; Default checksumming on
			_ELSE
				mov.b	#bChecksumming | bDontEcho,&intFlags ; IMU is in a comms loop so echo would be bad
			_ENDIF
;			bic.b	#bHexOutput,&intFlags	; Default numeric output to be in decimal, not hexadecimal
;			bic.b	#bDontInterpret,&intFlags ; Do interpret
;			bic.b	#bDontEcho,&intFlags	; Do echo
			mov		#TIB,&ToIN				; Initialise write pointer into text input buffer

; PWM initialisation
			call	#UpdateSoC					; Initialise the pre-computed counter advance value

;
; Miscellaneous initialisation
;
			mov.b	#4,&passWordState		; Waiting for first byte of ^E ^D ^C ^B sequence
			eint							; Enable interrupts now that all initialisation is complete

; If we're an IMU, retrieve the high word of the discharge accumulator from CMU 1

			cmp.b	#255,&ID
			_IF		_EQ
				mov		#SelectCMU1Get,R10		; Transmit "1sG" to select CMU 1 only, and get discharge
				call	#TxStringCk
				call	#TxEndOfPacket
			_ENDIF


; Main loop
			_BEGIN
				call	#RxByteNoWait			; Check if received data
				_IF		_NZ
					call	#Reject2400Baud			; Eliminates $00, $80, $F8 and $78 (lowercase 'x')
				_ENDIF
				_IF		_NZ
					tst.b	R8
					_IF		_NN
						call	#DoEcho					; Echo the command or password byte if required
						call	#DoPassword				; Check for password bytes
						call	#ACCEPT					; Process command bytes (could take a long time)
					_ELSE
						call	#DoStatus				; Forward possibly-updated status bytes
					_ENDIF
				_ELSE
					bit.b	#bNotMeasureTime,&monFlags	; Check if time to measure
					_IF		_Z							; If so, do measurement and set/clear of bypass
						bis.b	#bNotMeasureTime,&monFlags	; Reset the time-to-measure flag
						call	#DoMeasurement			; May transmit status
					_ELSE
						mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer before sleeping CPU
						bis		#CPUOFF+GIE,SR			; Turn off CPU and ensure interrupts still enabled
					_ENDIF
				_ENDIF

			ClearWatchdog				; Clear and restart Watchdog Timer each time around main loop

			_AGAIN
; End of main loop

SelectCMU1Get	DB		3, '1sG'
				ALIGN	1

;
; Initialise the PIP4048MS inverter with various non-default settings
;
InitPip:
			call		#WaitTxComplete		; Wait for transmission to complete
			mov.w		#BitTime24,&txBitTime ; Set the bit time for 2400 baud
			mov			#PipInit,R10		; Point to CR before initialisation strings
			_DO			#15,R8				; Number of initialisation strings,
											; including initial CR and final junk sweeper
				push		R8					; Save loop counter
				push.b		@R10				; Push length byte
				call		#TxString			; Send one command

				; Base the following delay on the length of the preceding command (heuristic)
				pop.b		R8					; Pop length byte
				swpb		R8					; Mult by 256
				rra			R8					; 128 ms per byte
				add			#500,R8				; plus 500 ms
				call		#DelayMs			; Allow time for PIP to Ack or Nak
				pop			R8					; Restore loop counter
			_LOOP		R8

			mov.w		#BitTime96,&txBitTime ; Set the bit time for 9600 baud
			ret

; PIP 4048MS inverter/charger initialisation strings. First byte is length.
; CRCs are precomputed using http://www.lammertbies.nl/comm/info/crc-calculation.html
; CRC-CCITT (XModem), except $0D, $0A and $28 bytes in the CRC must be incremented. See crc.s43.
PipInit: 	DB	1,$0D						; In case PIP has already received junk. Will cause a NAK
;		 	DB	8,'POP00',$C2,$48,$0D		; Utility priority (default)
;		 	DB	8,'POP01',$D2,$69,$0D		; Solar priority
;		 	DB	8,'POP02',$E2,$0B,$0D		; "SBU" (Solar, Bat, Util) priority (for off-grid use)
			DB	6,'PDa',$E3,$41,$0D			; Disable beeper
			DB	6,'PDk',$42,$0B,$0D			; Disable return to default screen
;			DB	6,'PEj',$61,$1B,$0D			; Enable load-sense
			DB	6,'PEu',$82,$C5,$0D			; Enable OL-restart
			DB	6,'PEv',$B2,$A6,$0D			; Enable OT-restart
			DB	6,'PEz',$73,$2A,$0D			; Enable fault-recording
			DB	8,'PBT02',$07,$4C,$0D		; Battery type "User"
;			DB	8,'PGR01',$39,$CA,$0D		; AC input range "UPS" (170 to 280 Vac)
			DB	11,'PSDV48.0',$D4,$D1,$0D	; Battery low cutoff voltage 48 V (3.00 Vpc)
			DB	11,'PBCV51.0',$7B,$AF,$0D	; Start charging from util (if avail) when bat falls to 51 V
			DB	11,'PBDV00.0',$38,$9B,$0D	; Stop charging from utility when "FUL", i.e. float achieved
			DB	11,'PCVV55.2',$66,$C9,$0D	; Set bulk/absorb voltage to 55.2 V (3.45 Vpc)
			DB	11,'PBFT53.8',$93,$45,$0D	; Set float voltage to 53.8 V (3.3625 Vpc)
			DB	13,'MNCHGC0100',$16,$3A,$0D	; Maximum charge current 100 amps (utility plus solar)
			DB	12,'MUCHGC030',$C0,$C0,$0D	; Maximum utility charge current 30 amps
;			DB	12,'MUCHGC040',$59,$57,$0D	; Maximum utility charge current 40 amps
PipJunkSweep:	DB	6,'PExSh('				; All junk between this and a CR or LF will be ACKed.
											; Consists of a harmless enable backlighting command
											; followed by its $5368 CRC and a '(' comment delimiter
			ALIGN		1




Reject2400Baud:
; When receiving 2400 baud characters sent by an IMU (intended for the PIP inverter)
; the only possible characters received at 9600 baud are $00, $78, $80, $F8.
; $00 is a no-op, $80 and $F8 are status bytes.
; $78 is a lowercase 'x', which forces us to use a different character 'W' for the exclusive command.
			cmp.b	#1,&ID
			_IF		_EQ						; If we're the first CMU
				_COND
					cmp.b	#$00,R8
				_OR_ELSE	_EQ					; If char is a null, or else
					cmp.b	#'x',R8
				_OR_ELSE	_EQ					; If char is an 'x', or else
					cmp.b	#$80,R8
				_OR_ELSE	_EQ					; If char is $80, or else
					cmp.b	#$F8,R8
				_OR_IFS		_EQ					; If char is $F8
					setz							; Set the Z flag so char  will be ignored
				_ELSE							; Else
					clrz							; Clear the Z flag so char  will be accepted
				_ENDIF
			_ELSE							; Else not the first CMU
				clrz							; Clear the Z flag so char will be accepted
			_ENDIF
			ret
; End of Reject2400Baud


DoEcho:		_COND							; Begin short circuit conditional
				cmp.b	#$11,R8
			_OR_ELSE	_EQ					; If it's an XON (ctrl-Q) character OR Else
				bit.b	#bDontEcho,&intFlags
			_OR_IFS		_Z					; Or If the dont-echo flag is clear
				call	#TxByte					; Echo the character
			_ENDIF
			ret
; End of DoEcho


DoMeasurement:
;
; Regular measurement. Called StatusFreq times per second (2-16 times per second, see serialio.s43)
;
#define Rstrs R12				// Worst stress (present, not trip)
#define Rmeas R14				// Measurement causing worst stress
#define Rtype R15				// Type of measurement causing worst stress

			inc.b	&statusFreqCtr			; Used to time various infrequent tasks. Allowed to wrap.
			cmp.b	#255,&ID
			_IF		_EQ						; If we're an IMU
				bit.b	#bDonePipInit,&monFlags	; Check if we've already done PIP initialisation
				_IF		_Z
					cmp.w	#PipWait, uPipInitCtr
					_IF		_EQ
						call	#InitPip		; Send the PIP initialisation strings
						bis.b	#bDonePipInit,&monFlags
					_ELSE
						inc		uPipInitCtr		; Wait till the PIP is ready to receive commands
					_ENDIF
				_ENDIF
			_ENDIF

			clr		Rstrs					; Init present stress to zero
			clr		Rmeas					; Init measurement causing zero stress to zero
			clr		Rtype					; Init type of measurement causing zero stress to zero

			inc.b	&ticksSinceLastRx		; Cleared whenever valid stress byte received
			_IF		_C						; If unsigned overflow
				mov.b	#$FF,&ticksSinceLastRx	; Saturate at $FF
			_ENDIF

			; Do cell voltage measurement
			call	#cellV					; Get cell voltage in mV in R10
			cmp.b	#255,&ID				; If we're not an IMU
			_IF		_NE
				; Estimate OCV by subtracting current times internal resistance from measured voltage
			   push	R10							; Save the cell voltage measurement

				; Get the absolute value of the current into R9
				mov		&current,R9				; Current is in tenths of an amp
				abs		R9

				; Get the scaled cell internal resistance into R8.
				; Want 10*I * 10*R * K = 64K * I * R so result >> 16 = I * R (I in amps, R in mR)
				; So 100*K*IR = 64K*IR  or K = 64K/100. Use <<16 to achieve *64K.
				; Want K * (10*R) in R8 = (CellResistance << 16) / 100. Add 100/2=50 for rounding.
				; We rely on the assembler using 32 bits for calculating partial results;
				; it seems to do this at present
				mov		#((CellResistance<<16)+50)/100,R8	; CellResistance is in tenths of a milliohm

				; Multiply them and subtract from measured cell voltage
				ClearWatchdog
				call	#UMStar					; R10:R9 = R8 * R9, resistance * current, clears R11
				mov		R10,R9					; Use only the high word of the result, put into R9
				pop		R10						; Restore the cell voltage measurement to R10
				tst		&current
				_IF		_NN						; If current is not negative (charge)
					sub		R9,R10					; OCV is lower than measured
				_ELSE							; Else charging
					add		R9,R10					; OCV is higher than measured
				_ENDIF							; Endif
			_ENDIF	; not IMU

			; Set bypass as required
			cmp.b	#255,&ID				; If we're not an IMU
			_IF		_NE
				mov			&ovStep,R9			; Calculate the bypass threshold in R9 = ovZero + 6*ovStep
				rla3		R9
				add			&ovZero,R9
				sub			&ovStep,R9
				sub			&ovStep,R9
				cmp			R9,R10				; Compare present cell voltage (R10) to bypass threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#BYPASS,&P2OUT	; Move only the #BYPASS bit from R8 to &P2OUT. Trashes R8
				add			&ovStep,R9			; Calculate the full (coulomb-counter reset) threshold
												;	One level above bypass (cf. one below for monitor)
				cmp			R9,R10				; Compare cell voltage (R10) to the full threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#ALL_FULL,&localStatus ; Move only All-Full bits from R8 to localStatus
			_ELSE
				bis.b		#ALL_FULL,&localStatus	; IMU must pretend it's in bypass so charge terminates
			_ENDIF

			cmp.b	#255,&ID
			_IF		_NE						; If we're not an IMU
				push	R10						; For undervoltage stress calc below
				; Calculate stress due to overvoltage
				push	R10						; OCV for overvoltage stress calc
				push	&ovStep					; For every ovStep (millivolts)
				push	&ovZero					;	over ovZero, we add one level of stress
				push	#1						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if non-zero stress due to OV

				; Calculate stress due to undervoltage
												; OCV for undervoltage stress calc already pushed
				push	#UV_STEP				; For every UV_STEP (millivolts)
				push	#UV_ZERO				;	below UV_ZERO, we add one level of stress
				push	#2						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if non-zero stress due to UV
			_ENDIF	; not an IMU

			; Do temperature measurement
			call	#temp					; Get temperature in degrees Celsius in R10

			cmp.b	#255,&ID
			_IF		_NE						; If we're not an IMU
				push	R10						; Save measurement for undertemperature stress calc
				; Calculate stress due to overtemperature
				push	R10						; Measurement for overtemperature stress calc
				push	#OT_STEP				; For every OT_STEP (degrees Celsius)
				push	#OT_ZERO				;	over OT_ZERO, we add one level of stress
				push	#3						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to OT

				; Calculate stress due to undertemperature
												; Measurement saved on stack earlier
				push	#UT_STEP				; For every UT_STEP (degrees Celsius)
				push	#UT_ZERO				;	below UT_ZERO, we add one level of stress
				push	#4						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to UT
			_ENDIF

			; Calculate stress due to link voltage (current shunt measurement for an IMU)
			call	#linkV					; Get link voltage in mV in R10
			cmp.b	#255,&ID				; If we're not an IMU
			_IF		_NE
#if 0			// Don't treat link voltage as stress for now, as the circuitry is too noise prone.
				cmp		#9999,R10				; Special "invalid" value?
				_IF		_NE						; Only calculate link stress if not this value
					; Calculate stress due to excessive absolute link voltage
					tst		R10						; Get absolute value of link voltage
					_IF		_L
						inv		R10
						inc		R10
					_ENDIF
					push	R10						; Measurement for absolute link stress calc
					push	#AL_STEP				; For every AL_STEP (millivolts)
					push	#AL_ZERO				;	over AL_ZERO, we add one level of stress
					push	#5						; Type of measurement
					call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to AL
				_ENDIF
#endif
			_ELSE	; IMU
				// For an IMU, so-called link-voltage is really shunt current in 1/5ths of an amp.
				// Tell the CMUs what the current is, by sending an 'i' command
				mov		#'\r',R8				; Transmit a carriage return to flush any 2400 baud junk
				call	#TxByte					; Trashes R9 but preserves R10

				rla		R10						; Convert to tenths of an amp
				mov		R10,&current			; Save in RAM variable
				abs		R10						; Take the absolute value of the current in R10
				mov		R10,Rsec
				mov		#4,Rtos					; 4 digit field width
				ClearWatchdog
				call	#_emitNum				; Transmit the number
				ClearWatchdog
				cmp		#0,&current
				_IF		_L						; If current is negative
					mov		#'-',R8					; Transmit a postfix minus sign
					call	#TxByteCk
				_ENDIF
				mov		#'i',R8					; Transmit an "i" for current
				call	#TxByteCk
				call	#TxEndOfPacket

				tst		&current
				_IF		_NN						; If current is not negative
					bis.b	#bCharging,&monFlags	; We're charging
				_ELSE							; Else
					bic.b	#bCharging,&monFlags	; We're not charging
				_ENDIF							; Endif

				; Sign extend current to 32 bits in R10:R9.
				mov		&current,R9					; Get current in R9
				mov		R9,R10						; Make a copy in R10
				rla		R10							; Shift sign bit to carry
				subc	R10,R10						; 0 if R9 is negative, -1 otherwise
				inv		R10							; -1 if R9 is negative, 0 otherwise

				; Do coulomb counting
				sub		R9,&discharge				; Integrate current in 32-bit discharge accumulator
				subc	R10,&discharge+2			; for fuel gauge
				call	#UpdateSoC					; Update the pre-computed SoC timer advance value

				; Send the high word of the discharge counter to safe storage
				tst.b	&statusFreqCtr				; Every 136 seconds
				_IF	_Z
					mov		#SelectCMU1,R10				; Transmit "1s" to select CMU 1 only
					call	#TxStringCk
					ClearWatchdog

					mov		&discharge+2,Rsec
					mov		#5,Rtos						; 5 digit field width
					push.b	&intFlags					; Save number base
					bis.b	#bHexOutput,&intFlags		; Set to hexadecimal output
					call	#_emitNum					; Transmit the number
					pop.b	&intFlags					; Restore number base
					ClearWatchdog

					mov		#'Z',R8						; Transmit a "Z" for ZtoreDischarge
					call	#TxByteCk
					call	#TxEndOfPacket
				_ENDIF ; Every 136 seconds
			_ENDIF ; IMU current measurement

			cmp.b	#255,&ID
			_IF		_NE						; If we're not an IMU
				; Clamp local present stress to a maximum value
				mov		#15,R9					; Default clamp value is 15
				cmp		#4,Rtype
				_IF		_EQ						; If type is undertemperature
					mov		#MinContStress,R9		; Clamp to a max of 12 to avoid masking UV >= 12
				_ENDIF
				mov		Rstrs,R8				; Copy stress. movBits_B macro below trashes its source.
				cmp		R9,R8					; If the stress is not less than the maximum allowed
				_IF		_HS
					mov		R9,R8					; Use the maximum allowed
				_ENDIF

				; Update local present stress
				movBits_B R8,#STRESS,&localStatus ; Record for later use, preserving other status bits.

				; Update local present stress type if not already set to "all considered full" above.
				mov.b	&localStatus,R10
				and		#TYPE,R10
				cmp		#ALL_FULL,R10
				_IF		_NE						; If stress type is not already All considered Full
					cmp		#2,Rtype
					_IF		_EQ						; If stress type is UnderVoltage
						mov		#UV_AF,R8				; Set the UV_AF bit, clear the OV_UT bit
					_ELSE							; Else
						_COND							; Begin short circuit conditional
							cmp		#1,Rtype
						_OR_ELSE _EQ					; If type is OverVoltage, else
							cmp		#4,Rtype
						_OR_IFS	_EQ						; or if type is UnderTemperature
							mov		#OV_UT,R8				; Set the OV_UT bit, clear the UV_AF bit
						_ELSE							; Else
							clr		R8						; Clear both type bits
						_ENDIF
					_ENDIF
					movBits_B R8,#TYPE,&localStatus ; Record type for later, preserving other status bits.
				_ENDIF

				; Update worst stress for trip so far
				cmp.b	&worstStress,Rstrs		; If stress equal or higher than worstStress for trip so far
				_IF		_HS
					tst.b	Rstrs					; and it's an actual, nonzero stress
					_IF	_NZ
						mov.b	Rstrs,&worstStress		; Update worstStress
						mov.b	Rtype,&worstStressType	; Update type of measurement causing worst stress
					_ENDIF
				_ENDIF

				; Update Alarm -- local red LED and piezo
				cmp.b		#MinAlarmStress,Rstrs	; Turn on the error LED if stress is MinAlarmStress or more
				CtoAllBits	Rtos
				bit.b		#bBadInsulation,&monFlags
				CtoAllBits	R8
				bis			R8,Rtos				; or if the last insulation test failed (IMU only)
				call		#_errorLed			; Use this function so it optionally turns on piezo as well
			_ENDIF	; Not an IMU

			; Check for comms error and send local status if required
			bic.b	#COM_ERR,&localStatus	; Clear comms error flag by default. May be set below.
			bit.b	#bNotSendStatus,&monFlags ; If sending status, and so expecting to receive it
			_IF		_Z
				cmp.b	#ComErrTicks,&ticksSinceLastRx ; and too many ticks since last valid status Rx
				_IF		_HS
					; If our ID is not 1 (first CMU), set the comms error bit in local status
					; and send a comment with our ID followed by 'c' for comms error
					; every 256 status bytes (approx every 136 seconds).
					cmp.b	#1,&ID
					_IF		_NE
						bis.b	#COM_ERR,&localStatus
						tst.b	&statusFreqCtr
						_IF	_Z
							call	#_commsError			; Call pretty-printing command
						_ENDIF
					_ENDIF

					; Act as a master -- send our status
					mov.b	&localStatus,R8
					bis.b	#$80,R8					; Set the high bit to say it's a status byte

					; Send status or control a charger
					bit.b	#bChargerControl,&monFlags	; Set by 'o' command. Initialised true for IMU.
					_IF		_Z							; If we're not in charge control mode
						call	#TxByte						; Send the status byte. Wait buffer not full
					_ELSE								; Else we're in charger control mode
						call	#ControlCharger				; Control a charger
					_ENDIF
				_ENDIF							; End if too many ticks since last Rx
			_ENDIF							; End if sending status
			ret
; End of DoMeasurement
SelectCMU1	DB	2, '1s'				; First byte is length of following string
			ALIGN 1

DoStress:
;
; Called 5 times by DoMeasurement to calculate the various kinds of stress
; and keep track of which is worse.
; It takes 4 parameters on the stack and updates 3 registers as required (Rstrs, Rmeas, Rtype).
; Trashes R8 thru R11.
;
; Stack offsets for parameters (return address is at offset zero)
type	EQU		2				; A number representing the type of measurement OV=1 UV=2 OT=3 UT=4 AL=5
zero	EQU		4				; The measurement corresponding to zero stress
step	EQU		6				; The change in measurement corresp to a change of one stress level
meas	EQU		8				; The measurement

			ClearWatchdog
			mov		meas(SP),R9				; Get meas in R9
			mov		type(SP),R10			; Get type * 2 in R10 for use as word index
			rla		R10
			mov		step(SP),R8				; Get step in R8
			tst		R8
			_IF		_GE
				cmp		worstStress(R10),R9
				_IF		_GE						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				sub		zero(SP),R9				; Get meas - zero in R9
			_ELSE
				cmp		worstStress(R10),R9
				_IF		_L						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				inv		R8						; Get absolute value of step in R8
				inc		R8
				mov		zero(SP),R9				; Get zero - meas + step -1 in R9
				sub		meas(SP),R9
				add		step(SP),R9
				sub		#1,R9
			_ENDIF
			_IF		_L
				clr		R9						; Min of 0
			_ENDIF
			clr		R10						; Clear high word of dividend
			call	#UMSlashMod				; R9 = R10:R9 / R8 = (meas - zero) / step, clears R11
			cmp		R9,Rstrs				; Is this stress worse than present stress calculated so far?
			_IF		_LO
				mov		R9,Rstrs				; Yes, new present stress
				mov		meas(SP),Rmeas			; Measurement causing present stress
				mov		type(SP),Rtype			; Type of measurement causing present stress
			_ENDIF
			pop		R8						; Pop the return address
			add		#8,SP					; Drop the parameters off the stack
			br		R8						; Return
; End of DoStress


DoStatus:
;
;	Process received status byte in R8. Trashes R9, R10
;	Status byte:
;	Bit 7: Always 1 for status byte
;	Bit 6: Comms error: Means that status information does not represent the whole pack
;	Bit 5: Ignore on charge (if bit 4 is clear), All considered full (if bit 4 is set)
;	Bit 4: Ignore on discharge
;	Bits 3-0: Stress level 0-15
;
		; Extract the stress bits from the incoming status byte
		mov.b	R8,R9					; Copy incoming status to R9
		and.b	#STRESS,R9				; Only stress bits in R9

		clr.b	&ticksSinceLastRx		; Now zero time since last received valid status
		; This will eliminate any comms error next time through DoMeasures

		; Check if DoMeasures may have just sent a status byte, due to a comms error
		bit.b	#COM_ERR,&localStatus
		_IF		_Z						; If no comms error

			cmp.b	#255,&ID
			_IF		_NE						; If we're a CMU
				; Do MAX of local and incoming stress, and handle stress type and all considered full
				mov.b	&localStatus,R10		; Get local status to R10
				and.b	#STRESS,R10				; Extract stress bits
				cmp.b	R10,R9					; Compare incoming stress (R9) to ours (R10)
				_IF		_LO						; If incoming stress (R9) is less than ours (R10)
					mov		R8,R9					; Make a copy of incoming status for tests below
					mov.b	&localStatus,R10		; Get local status to R10
					movBits_B	R10,#STRESS|TYPE,R8 ; Replace incoming stress and type with ours (trashes R10)
					_COND
						and		#TYPE,R9
						cmp		#ALL_FULL,R9
					_AND_IF	_NE						; If incoming was not all considered full
						mov.b	&localStatus,R10
						and		#TYPE,R10
						cmp		#ALL_FULL,R10
					_AND_IF	_EQ						; and if local is in bypass
						bic		#UV_AF,R8 				; Clear the UV_AF (undervoltage or all considered full) bit
					_ENDIFS
				_ELSE							; Else incoming stress is not less than ours
					_IF		_EQ						; If incoming stress is equal to ours
						mov.b	&localStatus,R10		; Ensure UV trumps other types, particularly UT,
						and		#TYPE,R10				; which won't go away when sources dropped, and
						cmp		#UV_AF,R10				; may mask UV and prevent loads being dropped.
						_IF		_EQ						; If local is undervoltage
							movBits_B	R10,#TYPE,R8		; Replace incoming type with ours (trashes R10)
						_ENDIF
					_ENDIF
					; Incoming stress not less than ours
					mov		R8,R9					; Make a copy of incoming status for tests below
					_COND
						and		#TYPE,R9
						cmp		#ALL_FULL,R9
					_AND_IF	_EQ						; If incoming is all considered full
						mov.b	&localStatus,R10
						and		#TYPE,R10
						cmp		#ALL_FULL,R10
					_AND_IF	_NE						; and if local is not in bypass
						bic		#UV_AF,R8 				; Clear the UV_AF (undervoltage or all considered full) bit
					_ENDIFS
				_ENDIF							; End else incoming stress is not less than ours

				; Process incoming comms error bit.
				; Since we received a valid status byte, there is no local
				;	comms error, so just pass the incoming comms error bit through.

				; Send status or control a charger
				bit.b	#bChargerControl,&monFlags	; Set by 'o' command. Initialised true for monolith.
				_IF		_Z							; If we're not in charge control mode
					call	#TxByte						; Send the status byte. Wait buffer not full
				_ELSE								; Else we're in charger control mode
					call	#ControlCharger				; Control a charger
				_ENDIF
			_ELSE							; Else we're an IMU
				; Process incoming status for IMU. Stress in R9, complete status in R8.
				call	#ControlCharger			; Control PIP charging
			_ENDIF							; End else IMU
		_ENDIF							; End if no comms error
		ret
; End of DoStatus


ControlCharger:
;
; Status byte is in R8. Use it to control contactors, and as input to a PI controller to control charging
;
		push 	R9
		push	R10

		; Treat comms eror as stress 15 for contactor control (will be smoothed)
		mov		R8,R9
		and		#STRESS,R9				; Get stress into R9
		bit		#COM_ERR,R8
		_IF		_NZ						; If the comms error bit is set
			mov		#15,R9					; Treat it as stress 15 for contactor control
		_ENDIF

		; Calculate smoothed stress for controlling contactors
		rla2	R9						; Quadruple the incoming stress
		mov.b	&smoothStressX4,R10		; Get the previous smoothed stress times 4 into R10
		add		R10,R9
		add		R10,R9
		add		R10,R9					; R9 = 4*incoming + 3*4*previous
		incd	R9						; Add 2 for rounding
		rra2	R9						; Divide by 4 to get new smoothed stress times 4
		mov.b	R9,&smoothStressX4		; Save it for next time
		inc		R9						; Add 1 for rounding (don't add 2 or it won't descend fully)
		rra2	R9						; Divide by 4 to get smoothed stress

		cmp.b	#15,R9					; If smoothed stress is extreme
		_IF		_GE
			bic.b	#(SourceCont | LoadCont),P2OUT ; Drop out both source and load contactors
											; and hence also the battery contactor
		_ENDIF							; Endif

		; If not OV_UT && not charging && stress >= 12
		;	turn off discharging/loads contactors
		_COND							; Begin short circuit conditional
			bit		#OV_UT,R8
		_AND_IF	_Z						; If the stress is not due to OverVoltage or UnderTemp
			bit.b	#bCharging,&monFlags
		_AND_IF	_Z						; And if we're not charging
			cmp.b	#MinContStress,R9
		_AND_IF	_GE						; And if incoming stress is alarming
			bic.b	#LoadCont,&P2OUT		; Drop out the load contactor (magenta LED)
		_ENDIFS

		; If stress <= 7
		;	turn on discharging/loads contactors
		cmp.b	#8,R9
		_IF	_L							; If incoming stress is normal
			bis.b	#LoadCont,&P2OUT		; Turn on the load contactor (magenta LED)
		_ENDIF

		; If (not UV && charging && stress >= 12) || (array voltage >= 145 V)
		;	turn off charging/source contactors
		mov		R8,R10					; Make a copy of the status byte in R10
		and		#TYPE,R10				; Extract the two stress type bits
		_COND							; Begin short circuit conditional
			cmp		#UV_AF,R10				; Check for UV = UV_AF and not OV_UT
		_AND_IF	_NE						; If the stress is not due to UnderVoltage
			bit.b	#bCharging,&monFlags
		_AND_IF	_NZ						; And if we're charging
			cmp.b	#MinContStress,R9
		_AND_IF	_GE						; And if incoming stress is alarming
			bic.b	#SourceCont,&P2OUT		; Drop out the source contactor (yellow LED)
		_ELSES							; Else
			push	R8
			call	#cellV					; Get the PV array voltage
			pop		R8
			cmp		#145*10,R10
			_IF		_HS						; If PV array voltage is greater or equal to 145 volts
				bic.b	#SourceCont,&P2OUT		; Drop out the source contactor (yellow LED)
			_ENDIF
		_ENDIF

		; If stress <= 7 && array voltge < 140 V
		;	turn on charging/source contactors
		_COND							; Begin short circuit conditional
			cmp.b	#8,R9
		_AND_IF	_L						; And if incoming stress is normal
			push	R8
			call	#cellV
			pop		R8
			cmp		#140*10,R10
		_AND_IF	_LO						; And if PV array voltage is less than 140 volts
			bis.b	#SourceCont,&P2OUT		; Turn on the source contactor (yellow LED)
		_ENDIFS

		; If all considered full (and no comms error), reset the coulomb counter
		_COND
			bit		#COM_ERR,R8
		_AND_IF	_Z
			mov		R8,R10					; Make a copy of the status byte in R10
			and		#TYPE,R10				; Extract the stress type bits
			cmp		#ALL_FULL,R10
		_AND_IF	_EQ						; If all cells are considered full
			; Set the discharge counter to the required DoD (usually 0).
			; This was to allow for possible floating at the 25.0% DoD point where there is a
			; step in the SoC vs voltage curve for LiFePO4.
			; It performs the inverse calculation to that used in the fuelGauge 'g' command.
			mov		#(((BatCapacity*AllFullDod*StatusFreq)/607)<<10)&$FFFF,&discharge	; Lo word
			mov		#(((BatCapacity*AllFullDod*StatusFreq)/607)>> 6)      ,&discharge+2 ; Hi word
			call	#UpdateSoC			; Update the pre-computed PWM counter advance value
		_ENDIFS ; All Considered Full and no comms error

#if 0	// PI control doesn't work with the MPPT in the PIP-4048MS, only with its AC charger
;		bit.b	#bCharging,&monFlags	; Set by '1c' command
;		_IF		_NZ						; If we've been told to start charging
			ClearWatchdog
			inc.b	&chargerTxTimer			; Increment charger transmit timer
			mov.b	&chargerTxTimer,R9		; Get charger transmit timer
			and.b	#3,R9
			_IF		_Z						; Every fourth tick (every 2 seconds)
				bit		#COM_ERR,R8
				_IF		_NZ						; If the comms error bit is set
					and		#STRESS,R8
					cmp		#8,R8					; Treat it as a minimum of stress 8 for PI control
					_IF		_LO
						mov		#8,R8
					_ENDIF
				_ELSE
					; If stress is due to undervoltage, treat it as stress 0 for charging purposes
					mov		R8,R9					; Make a copy of the status byte in R9
					and		#TYPE,R9				; Extract the stress type bits
					cmp		#UV_AF,R9
					_IF		_EQ						; If stress type is UnderVoltage
						clr		R8						; Treat as a stress of zero for charging
					_ELSE							; Else
						and		#STRESS,R8				; Use the given stress value (0-15)
					_ENDIF
				_ENDIF
				call	#PiController			; Call PI controller with R8 as input and output
				call	#SendChargerPackets		; Send packets to charger to set voltage
				clr.b	&chargerTxTimer 		; Clear timer
			_ENDIF ; Every fourth tick
;		_ENDIF ; bCharging
#endif
		pop		R10
		pop		R9
		ret
; End of ControlCharger


PiController:
;
; A PI controller whose input and output are in R8
; Input range is 0 to 15 (stress levels). Setpoint is 7.
; Output range is chargerVoltMin to chargerVoltMax (tenths of a volt).
;
#define Rerror R10			// Error register
#define Rderiv R9			// Derivative register
#define Routput R8			// Output register
			mov		#7,Rerror				; error = setpoint - measurement
			sub		R8,Rerror
			mov		Rerror,Rderiv			; deriv = error - prev_error
			sub		&piPrevError,Rderiv

			mov		&piPrevOutput,Routput	; output = prev_output + Kp * deriv + Ki * error
			; Insert rla Rderiv here to change Kp
			rla3	Rderiv					; Kp = 4
			add		Rderiv,Routput
			mov		Rerror,R9				; Overwrites unused Rderiv
			; Insert rla R9 here to change Ki
			add		R9,Routput				; Ki = 1

			mov		&chargerVoltMin,R9
			rla2	R9						; The combination of this rla2, the rla2 below,
											; and the rra2 at the end, have the effect of dividing
											; bit Kp and Ki by 4. So they are effectively 1 and 1/4.
			cmp		R9,Routput				; Clamp output between chargerVoltMin and chargerVoltMax
			_IF		_L
				mov		R9,Routput
			_ELSE
				mov		&chargerVoltMax,R9
				rla2	R9						; For effective reduction of Kp and Ki
				cmp		R9,Routput
				_IF		_GE
					mov		R9,Routput
				_ENDIF
			_ENDIF

			mov		Rerror,&piPrevError		; prev_error = error
			mov		Routput,&piPrevOutput	; prev_output = output
			rra2	Routput					; For effective reduction of Kp and Ki
			ret
; End of PiController


SendChargerPackets:
;
; Send charger float and bulk command packets (in the right order)
; with voltage from R8 (in tenths of a volt)
;
; Trashes R8 thru R11
;
; Send PBFTvv.v<crc16><cr> and PCVVww.w<crc16><cr>
;	where vv.v is the Float voltage and ww.w is the Bulk voltage.
; When raising the voltage, bulk will have to be sent before float,
; and when lowering it, float will have to be sent before bulk.
PipCmdDelay	EQU		950					; Delay in ms between PIP commands, so next one not NAKed

			call	#WaitTxComplete		; Wait for 9600 baud transmission to complete
			mov.w	#BitTime24,&txBitTime ; Set the bit time for 2400 baud
			;
			; Although we have waited long enough to send the last 9600 bps character completely, it is
			; possible that this 9600 bps character has triggered a 2400 bps byte, possibly right near
			; the end of the last 9600 bps character. This may interfere with the carriage return we
			; want to send to flush the 9600 bps "junk" from the PIP's buffers.
			; So a delay of one 2400 bps character time (4 ms) should be enough time to guarantee that
			; any 9600 bps junk has passed.
			push	R8
			mov		#4,R8
			call	#DelayMs
			mov		#$0D,R8				; Send a carriage return to the PIP to flush preceding
			call	#TxByte				; 2400 baud junk caused by 9600 baud commands sent to CMUs.
			mov		#PipCmdDelay,R8		; Delay between commands so next one not NAKed
			call	#DelayMs
			pop		R8

			; Compare new requested voltage with previously sent bulk and float voltages
			; to determine whether to send the new voltage as Float or Bulk.
			; This algorithm is optimised for bringing possibly-distressing voltages _down_ as soon
			; as possible, at the expense of small delays in charging due to possibly not putting
			; them up as soon as possible. The PIP gives no way of telling when it is in float mode.
			_COND
				cmp		&prevFloat,R8
			_AND_IF		_EQ
				cmp		&prevBulk,R8
			_AND_IF		_EQ
				tst		&lastWasFloat
				_IF		_NZ
					mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
					mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
					mov		#BulkCmd,R10		; Send a Bulk voltage packet
					call	#SendPipPacket		; Trashes R8 thru R11
				_ELSE
					mov		R8,&prevFloat		; Record float voltage setpoint for next time
					mov		#-1,&lastWasFloat	; Record that the last sent was a Float
					mov		#FloatCmd,R10		; Send a Float voltage packet
					call	#SendPipPacket		; Trashes R8 thru R11
				_ENDIF
			_ELSES
				_COND
					cmp		&prevFloat,R8
				_OR_ELSE	_LO
					cmp		R8,&prevBulk
				_OR_IFS		_LO
					tst		&lastWasFloat
					_IF		_NZ
						cmp		&prevFloat,R8
						_IF		_LO
							mov		&prevFloat,R8
						_ENDIF
						mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
						mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
						mov		#BulkCmd,R10		; Send a Bulk voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ELSE
						cmp		R8,&prevBulk
						_IF		_LO
							mov		&prevBulk,R8
						_ENDIF
						mov		R8,&prevFloat		; Record float voltage setpoint for next time
						mov		#-1,&lastWasFloat	; Record that the last sent was a Float
						mov		#FloatCmd,R10		; Send a Float voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ENDIF
				_ELSE
					cmp		&prevBulk,R8
					_IF		_EQ					; If equal to previous bulk voltage
						mov		R8,&prevFloat		; Record float voltage setpoint for next time
						mov		#-1,&lastWasFloat	; Record that the last sent was a Float
						mov		#FloatCmd,R10		; Send a Float voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ELSE						; Else
						mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
						mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
						mov		#BulkCmd,R10		; Send a Bulk voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ENDIF						; End sending Float or Bulk voltage
				_ENDIF
			_ENDIF

			mov		#PipCmdDelay,R8		; Delay between commands so next one not NAKed
			call	#DelayMs

			mov		#PipJunkSweep,R10	; Send 'PExSh(' so the following 2400 baud junk, caused
			call	#TxString			; by 9600 baud commands sent to CMUs, will be ACKed by the PIP.
			call	#WaitTxComplete		; Wait for 2400 baud transmission to complete
			mov.w	#BitTime96,&txBitTime ; Set the bit time for 9600 baud

			ret

FloatCmd	DB			4, 'PBFT'		; First byte is length of following string
BulkCmd		DB			4, 'PCVV'		; 48.0 to 58.4 V
			ALIGN		1
; End of SendChargerPackets


SendPipPacket:
;
; Send a PIP command packet`
; with command string pointed to by R10
; and voltage in R8 (in tenths of a volt)
;
; Trashes R8 thru R11
;
			; Send the PIP command
			push		R8					; Save the voltage (in tenths of a volt) on the stack

			call		#TxStringCrc		; Send string pointed to by R10. Trashes R8 thru R11

			ClearWatchdog

			mov			#0,R10
			pop			R9					; Pop voltage to R9
			mov			#100,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov			R9,R8
			add			#'0',R8
			call		#TxByteCrc			; Send the tens digit of voltage (trashes R8 thru R10)

			mov			R10,R9
			mov			#0,R10
			mov			#10,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov.b		R9,R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the units digit of voltage (trashes R8 thru R10)

			mov.b		#'.',R8
			call		#TxByteCrc			; Send the decimal point (trashes R8 thru R10)

			ClearWatchdog

			mov.b		R10,R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the tenths digit of voltage (trashes R8 thru R10)

			call		#TxCrc				; Send the two bytes of CRC and clear it
			mov.b		#$0D,R8
			call		#TxByte				; Send the carriage return without accumulating CRC

			ClearWatchdog

			ret

;
; Update the SoC meter's advance value (so the SoC meter will reflect a change made to the discharge
; counter)
; Preserves R8 and R9, trashes R10, clears R11
;
UpdateSoC:
MinAdvance	EQU			20					; To avoid timer compare wraparound
			push		R8
			push		R9
			; Although we use DoD here, the PWM interrupt routine inverts the output so it represents SoC
			call		#DepthOfDischarge	; Get DoD as value 0-1000 (0 to 100.0%)
			cmp			#MinAdvance,R9		; Compare with minimum value
			_IF			_LO					; If lower,
				mov			#MinAdvance,R9		; Enforce minimum value to avoid timer compare wrap
			_ENDIF
			cmp			#1000-MinAdvance,R9	; Compare with maximum value
			_IF			_HS					; If higher or same,
				mov			#1000-MinAdvance,R9	; Enforce maximum value to avoid timer compare wrap
			_ENDIF
			mov			R9,&pwmAdv			; Save in the pre-computed advance variable
			pop			R9
			pop			R8
			ret


DoPassword:
;
; Check for a password character
; After decrementing passWordState below, 3 = waiting for first byte, 2 = waiting for second,
; 0 = waiting for last and erase if received. We should not receive any negative value
; Trashes R9
;
			dec.b	&passWordState
			jn		resetFSM			; This should never happen! Just reset FSM and
										; process as an ordinary command

			; Check for a continuing password match
			mov.b	&passWordState,R9	; Password is $05 $04 $03 $02 or $07 $06 $05 $04
#if PROG_START_FOR_BSL == $E000			; Changed password for 8 KiB image
			add.b	#2,R9				; Expected password char is equal to &passWordState with 2 added
#else									; Assume non 8 KiB image
			bis.b	#4,R9				; Expected password char is equal to &passWordState with bit 2 set
#endif
			cmp.b	R9,R8				; Check for a match
			jne		resetFSM			; If mismatch, jump and reset FSM
			tst.b	&passWordState		; Are we now at state 0?
			jnz		exitOnRx			; If not, this was a valid password byte, but not the last.
										;	Just exit this callback and wait for more
			; Jump to the code in the BSL which will erase main flash memory and wait for more bytes
			;	without using interrupts.
			; May be important: it could be bad to have receive interrupts sending stress bytes after
			;	this last password byte goes out; it could be interpreted as a byte to flash program!
			clr		&TACCTLr			; Clear at least the CCIE RX interrupt enable bit
			; Important: wait for the last password byte to be echoed before disabling interrupts!
			call	#WaitTxComplete

			dint
			clr		&TACTL				; Disable the timer completely; may use less power
#if REV61
			mov.b	#TXDp,&P1OUT		; Set TXD to idle
			ActLedOff					; (inverted) activity LED off
#else
			mov.b	#TXDp+ACTLED,&P1OUT	; Set TXD to idle, (inverted) activity LED off
#endif
			cmp.b	#255,&ID
			_IF		_NE
				clr.b	&P2OUT				; Set bypass and error LED off (relays off if IMU)
			_ENDIF
			clr.b	&P1SEL				; Make P1.1 ordinary I/O now
			bic.b	#USIPE5,&USICTL0	; Make P1.5 ordinary I/O also
			clr		&bsl2state			; Set BSL2's state variable as if it has just recognised password
			mov		#$300,SP			; Give the BSL maximum stack
			br		#BSLErase2			; Jump into BSL2 to flash erase and continue the download

resetFSM	mov.b	#4,&passWordState	; No password match; reset state machine

exitOnRx	ret
; End of DoPassword

			EVEN


DELAY_IF_NEEDED MACRO
			; No delay needed
			ENDM

#include "../common/serialio.s43"	// Comms routines
#include "../common/comMisc.s43"	// Miscellaneous common functions
#include "../common/measure.s43"	// Voltage measurement functions
#include "../common/CmdCharInterpreter.s43" // RPN interpreter with single-character commands
#include "../common/math.s43"		// Multiply and divide routines
#include "crc.s43"					// CRC calculation routines
#include "monoDefinitions.s43"		// Command character definitions


; Some calculations so we can see how much space we have left, by reading the listing.
freespace	EQU		_CMDCHRTBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/(_CMDCHRTBL-PROG_START))

;---------------------------------------------------------------------------------
; Interrupt and entry-point jump table at the end of the second-last main-flash segment
;---------------------------------------------------------------------------------
				ORG		$FDF2
jInterpretByte	br		#InterpretByte	; A branch to InterpretByte, independent of PROG_START
jRxTiovIsr		br		#RxTiovIsr		; Combined CC1IFG (receive capture/compare) & TAIFG (overflow)
jTxIsr			br		#TxIsr			; Timer A CC0IFG (transmit compare)

				ORG		$FDFE
ProgPresence	DB		$AA				; For BSL2 to check before calling main program (InterpretByte)
ProgChecksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg


;---------------------------------------------------------------------------------
; Second bootstrap loader, in the last main-flash segment
;---------------------------------------------------------------------------------
#include "../common/BSL2.s43"	// Include the macro for second bootstrap-loader and the interrupt vectors
				ORG		$FE00			; Start of last main-flash segment
; Instantiate the BSL2 macro with the standard external labels
BSL2:			BSL2MACRO	initRetAddr2, BSLErase2, ReadByte, WriteByte
				ORG		$FFFE			; The reset vector
				DW		BSL2			; Reset to BSL2 in case there is a crash

				END
