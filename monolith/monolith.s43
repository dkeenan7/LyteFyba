			COL		154			; Wide listings
; 14/Dec/2014: split off from monitor.s43

; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve calibration data.
;
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Output options to:
;  Allow C-SPY-specific extra output file
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	monolith.bin
;	Output format: raw-binary
;
; This software has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for solar power systems.
;
; "Monolith" is the standard solar power system operating software for our Cell Management Unit (CMU)
; and Battery Management Unit (BMU) based on an MSP430 microcontroller.
;
; Aspirational register-use policy:
; R8 thru R12 should be caller save (callee trashable)

;-------------------------------------------------------------------------------------------------------
; Commonly changed conditional assembly -- defaults are for Eddie
#define		CONFIG			OFF_GRID 	// Options: OFF_GRID (default), ON_GRID_SMALL, ON_GRID_LARGE
#define		QUIET			0			// 0 (default), 1 for BMU to tell CMUs not to beep
#define 	LOW_LOW_CUTOFF	1			// 1 (default) for 2.8 V (2% SoC), 0 for 3.08 V (5% SoC)
#define		chargerCurrMax	80			// 80 (default) or 60 A charger limit, depends on PIP-4048 model
;-------------------------------------------------------------------------------------------------------

#define MONOLITH				// For some conditional assembly in otherwise common code.
								// Changes StatusFreq from 16 Hz to 2 Hz.
								// Enables SoC meter PWM.
								// Causes ID 255 (instead of ID 0) to respond to fuel gauge commands
								// 'f' (SoC) and 'g' (DoD).

ShutdownTime	EQU		15*StatusFreq	; Shut down after approx 15 seconds of stress 15.

			LSTOUT-
#include "msp430.h"							// MSP430 Special Function Register definitions
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Assembler macros for obscure instruction sequences
#include "../common/common.h"				// Definitions common to monitor, TestICal and BSL
			LSTOUT+

; Some definitions so the IntMeasure.s43 code will work
; TestICal defines these as their RAM counterparts instead of info-flash
CellCal 	EQU	infoCellCal
CellOff		EQU infoCellOff
BoltPlCal 	EQU	infoBoltPlCal
BoltPlOff	EQU infoBoltPlOff
BoltMiCal	EQU	infoBoltMiCal
BoltMiOff	EQU	infoBoltMiOff
TempSlope	EQU	infoTempSlope
TempOff		EQU	infoTempOff
AdcTimIdx	EQU	infoAdcTimIdx


			NAME	main			; Module name
			PUBLIC	main			; Make the "main" label visible for IAR debugger

ProductCode	EQU		'L'				; T for TestICal, R for monitoR, L for monoLith, W for Wmonolith

ID			EQU		infoID			; We use the info-flash copy of the ID for s, x, prettyPrint
									; commands. TestICal uses the ram copy

; Conditional assembly
#define		WATCHDOG	1			// True if watchdog timer is to be used (only turn off for debugging
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer.
									// Buffered ADC is mainly useful for debugging.

; Constants

; For stress calculations
; Stress 7 is the set point for control loops.
; Stress 8 is the lowest dis-stress. Alarm is given at stress 12.
; Source or load contactors drop out at 12 if enabled.
; Battery contactor drops out at 15.
/*
Str- High Low  High Low  Link
ess  volt volt temp temp volt
     (mV) (mV) (°C) (°C) (mV)
-----------------------------------
 0
     3168 3360  35   22    0
 1
     3208 3320  37   20    8
 2
     3248 3280  39   18   16
 3
     3288 3240  41   16   24
 4
     3328 3200  43   14   32
 5
     3368 3160  45   12   40
 6
     3408 3120  47   10   48
 7 bypass - setpoint for control loops
     3448 3080  49    8   56
 8 full - warning
     3488 3040  51    6   64
 9
     3528 3000  53    4   72
10
     3568 2960  55    2   80
11
     3608 2920  57    0   88
12 alarm - disconnect if it persists for more than a few seconds
     3648 2880  59   -2   96
13
     3688 2840  61   -4  104
14
     3728 2800  63   -6  112
15 shutdown - immediate disconnect
*/

#define WHINGE 0
#if !WHINGE
// OV = Over Voltage: One stress unit for each 40 mV in excess of 3.128 V, to a max of 15 at >= 3.728 V
// OV setpoint is 3.408 to 3.448 V. Bypass at 3.408. Alarm at 3.608. Drop out source contactors at 3.608
// Drop out battery cont at 3.728 V.
OV_ZERO		EQU		3128		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		40			; mV difference between one OV stress level and the next
; These were an attempt to float at the 75% step
;// OV = Over Voltage: One stress unit for each 3 mV in excess of 3.332 V, to a max of 15 at >= 3.377 V
;// OV setpoint is 3.353 to 3.356 V. Alarm at 3.365 V. Drop out source contactors at 3.368 V.
;OV_ZERO		EQU		3332		; Threshold in mV between OV stress levels -1 and 0
;OV_STEP		EQU		3			; mV difference between one OV stress level and the next
#if LOW_LOW_CUTOFF			// 2.8 V cutoff for Greg -- about 2% SoC
// UV = Under Voltage: One stress unit for each 40 mV below 3.40 V, to a maximum of 15 at <= 2.80 V
// UV setpoint is 3.080 to 3.120 V (around 5% SoC). Alarm at 2.92 V. Drop out bat contactor at 2.80.
UV_ZERO		EQU		3400		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-40			; mV difference between one UV stress level and the next
#else 						// 3.08 V cutoff for the rest of us -- about 5% SoC
// UV = Under Voltage: One stress unit for each 20 mV below 3.380 V, to a maximum of 15 at <= 3.08 V
// UV setpoint is 3.24 to 3.22 V (around 20% SoC). Alarm at 3.14 V. Drop out bat contactor at 3.08.
UV_ZERO		EQU		3380		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-20			; mV difference between one UV stress level and the next
#endif
// OT = Over Temperature: One stress unit for every 2 degrees C above 33C, to a max of 15 at >= 63 degC
// OT setpoint is 47 to 49 degC. Alarm at 55 degC. Dropout bat contactors at 63 degC.
OT_ZERO		EQU		33			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		2			; Degrees C difference between one OT stress level and the next
BypTempQuota EQU	15			; Degrees C subtracted when bypassing in past 5 minutes
// UT = Under Temperature: One stress unit for every 2 degree C below 24C, to a max of 15 at <= -6 degC
// UT setpoint is 10 to 8 degC. Alarm at 0 degC. Bat contactor dropout at -6 degC.
UT_ZERO		EQU		24			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-2			; Degrees C difference between one UT stress level and the next
// AL = Absolute "Link" voltage. Now max of absolute positive and negative bolt voltages.
// One stress unit for every 8 mV above 0 mV, to a max of 15 at >= 120 mV
// AL setpoint is 56 to 64 mV. Alarm at 88 mV.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		8			; mV difference between one AL stress level and the next

#else
// OV = Over Voltage: One stress unit for each 10 mV in excess of 3.500 V, to a max of 15 at >= 3.65 V
// OV setpoint is 3.57 to 3.58 V. Alarm at 3.61 V.
OV_ZERO		EQU		3285		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		5			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 40 mV below 2.500 V, to a maximum of 15 at <= 1.90 V
// UV setpoint is 2.18 to 2.22 V. Alarm at 2.06 V.
UV_ZERO		EQU		3200		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-50			; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 40C, to a max of 15 at >= 55degC
// OT setpoint is 47 to 48 degC. Alarm at 51 degC.
OT_ZERO		EQU		40			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		1			; Degrees C difference between one OT stress level and the next
BypTempQuota EQU	15			; Degrees C subtracted when bypassing in past 5 minutes
// UT = Under Temperature: One stress unit for every 1 degree C below 11C, to a max of 15 at <= -4degC
// UT setpoint is 4 to 3 degC. Alarm at 0degC.
UT_ZERO		EQU		11			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-1			; Degrees C difference between one UT stress level and the next
// AL = Absolute "Link" voltage. Now max of absolute positive and negative bolt voltages.
// One stress unit for every 4 mV above 0 mV, to a max of 15 at >= 60 mV
// AL setpoint is 28 to 32 mV. Alarm at 44 mV.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		4			; mV difference between one AL stress level and the next
#endif

; FULLLEV	EQU	OV_ZERO+8*OV_STEP	; Considered Full (charge termination and coulomb counter reset)
									;	3448 mV. Stress 7/8 threshold
; BYPLEV	EQU	OV_ZERO+7*OV_STEP	; Bypass threshold 3408 mV. Corresp. to stress 6/7 threshold

MinAlarmStress EQU	12			; Minimum stress to light error LED and beep
MinContStress EQU	12			; Minimum stress to drop out source contactors (BMU only)

ComErrTicks	EQU		9			; Minimum ticks without receiving valid status byte before
								;	taking on master duties and reporting comms error (if ID not 1)
ZeroCurrentTicks EQU 9			; Minimum ticks without receiving an 'i' (current) command before
								;	assuming current is zero (if ID not 255)

; Status byte bit masks - Used for localStatus in RAM as well as RXed and TXed status bytes
COM_ERR		EQU		1<<6			; Communications error
UV_AF		EQU		1<<5			; Stress type is UnderVoltage (ignore on charge) when bit 4 is clear
									;	or cells are All considered Full when bit 4 is set
OV_UT		EQU		1<<4			; Stress type is OverVoltage or UnderTemp (ignore on discharge)
ALL_FULL	EQU		1<<4 | 1<<5		; When both type bits are set it means All considered Full
									;   (reset to 0% DoD) as well as OverVoltage (ignore on discharge)
									; When both type bits are clear it means OverTemp (never ignore)
S_TYPE		EQU		$30				; Stress type field mask. Bits 4-5
STRESS		EQU		$0F				; Stress level field mask. Bits 0-3

;
; RAM allocation
;
				ORG		$200		; Start of RAM. Ends at InitSP-1
; This area is common to all main programs and used by the BSL and is not block erased on a reset
bsl2state		DS		2			; Password recogniser state for BSL2
resetCounter	DS		2			; Number of resets since the last "^" command
resetBuffer		DS		16			; Circular buffer recording the reason for the last 16 resets
discharge		DS		4			; Accumulator for depth of discharge determination.
									; Unit is 1/10 A for 1/2 s = 1/20 coulomb = 1/72 milliamphour.
									; So 32 bits allows 60,000 Ah, but 24 bits would only allow 233 Ah.



oldFllTime		DS		2			; Used by Frequency Locked Loop. NOTE: do not put this after
									;	comNoEraseEnd, as it will affect the first FLL interrupt
measureCount	DS		2			; Incremented by FLL interrupt routine, on ACLK rising edge, 4096 Hz
oldMeasureCount DS		2			; Value of measureCount at the last measure
oldRtcMeasCnt	DS		2			; Hi 4 bits of measureCount at the last advance of RTC seconds count

; Command Character Interpreter flags
interpFlags		DS		1			; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1<<0		; Should numeric output be in hexadecimal, not decimal?
bErrorChecking	EQU		1<<1		; Are we sending CRC12s and checking received CRC12s?
bDontInterpret	EQU		1<<2		; Are we interpreting?
bDontEcho		EQU		1<<3		; Are we echoing at the character level?
bModbusOutput	EQU		1<<4		; Should PrettyPrint output be formatted as a Modbus/ASCII response?
bEchoResponses	EQU		1<<5		; True to echo complete Modbus responses
bQuiet			EQU		1<<6		; True to silence piezo

				ALIGNRAM 1
comNoEraseEnd	; End of unerased variables; start of erased variables

#if	ADCBUF
				ALIGNRAM 1
sampleBuf		DS		2*NumSamples ; ADC sample buffer; 4 or 16 samples
#endif

monFlags		DS		1			; Monitor flags, bitmask definitions follow
bNotSendStatus	EQU		1<<0		; Zero if sending status bytes at all
bNotMeasureTime EQU		1<<1		; Zero if time to measure
bCharging		EQU		1<<2		; 1 if charging or regen. See 'c' command.
bChargerControl	EQU		1<<3		; 1 in charger control mode (masterless operation). See 'o' command.
bBadInsulation	EQU		1<<4		; 1 if the last insulation test failed. (BMU only)
bDonePipInit	EQU		1<<5		; 1 if have done PIP initialisation

masterFlags		DS		1			; Master (command injector) flags; bitmask definitions follow
bBlocked		EQU		1<<0		; 1 if blocked.
bSendZ			EQU		1<<1		; 1 if Z command is due to be sent
bSendi			EQU		1<<2		; 1 if 'i' (current) command is due
bSendInit		EQU		1<<3		; 1 if CMU initialisation string should be sent
bTimeout		EQU		1<<4		; 1 if unblocked via timeout; may or may not have to send a CR to
									;	clear a stalled command if we have something to inject (may not
									;	be ready now, hence we need this separate bit)
masterUnblockTicks DS	1			; When the master is blocked, this field indicates what the tick
									; counter will read when the timeout expires
localStatus		DS		1			; Bits 0-3 stress, 4 ignore-on-dis, 5 ignore-on-chg, 6 comms error
globalStatus	DS		1			; BMU only. For SCUs that don't accept status bytes but use 'p' cmd
ticksSinceLastRx DS		1			; Ticks since last valid status received
ticksSinceLastI DS		1			; Ticks since last 'i' (current) command received
ticks			DS		1			; To time various medium frequency tasks. Allowed to wrap
passWordState	DS		1			; State machine for password recogniser

; Charger controller variables

shutdownTimer	DS		1			; To allow time for charging to start, when restarting
									;   after a low voltage shutdown.
				ALIGNRAM 1
pipInitPtr		DS		2			; Pointer to next PIP init string to send, or zero (NULL) if none
chargerVoltMin	DS		2			; Charger voltage minimum (tenths of a volt). Set by 'o' command.
chargerVoltMax	DS		2			; Charger voltage maximum (tenths of a volt). Set by 'o' command.
piPrevOutput	DS		2			; State of PI controller
piPrevError		DS		2			; State of PI controller
prevBulk		DS		2			; Previous Bulk/Absorb voltage (tenths of a volt) sent to PIP.
prevFloat		DS		2			; Previous Float voltage (tenths of a volt) sent to PIP.
;lastWasFloat	DS		2			; True (nonzero) if last voltage command sent to PIP was for float.
pipInitCtr		DS		1			; Counts ticks till the PIP is ready to receive commands
PipWait			EQU		3*StatusFreq ; Number of the above that will be required (3 seconds)
pipCmdCtr		DS		1			; Counts ticks till it's time to send the next init str
PipCmdWait		EQU		2*StatusFreq ; Number of the above that will be required (2 seconds)
AllFullDod		EQU		0			; DoD in tenths of a percent, to reset discharge counter to when all considered full
;AllFullDod		EQU		250			; DoD in tenths of a percent, to reset discharge counter to when all considered full
;ChargerVoltMin	EQU		530			; Lower limit of PI controller output. In tenths of a volt.
;ChargerVoltMax	EQU		570			; Upper limit of PI controller output. In tenths of a volt.
;ChargerVoltMin	EQU		526			; Lower limit of PI controller output. In tenths of a volt.
;ChargerVoltMax	EQU		546			; Upper limit of PI controller output. In tenths of a volt.
CHG_BULK_MIN	EQU		538			; 53.8 Lower limit for bulk charge voltage
CHG_BULK_STD	EQU		552			; 55.2 Set and maximum value for bulk charger voltage
CHG_FLT_MIN		EQU		512			; 51.2 Lower limit for float charge voltage
CHG_FLT_STD		EQU		538			; 53.8 Set and maximum value for float charger voltage

ocCellVoltX256	DS		4			; Smoothed IR-compensated average cell voltage, shifted left 8 bits
restedCounter	DS		2			; Count of measurements since the battery qualified as "rested"
current			DS		2			; Current most recently reported by BMU, in tenths of an amp (signed)
cellTemperature	DS		2			; Cell temp degC (signed). For Rint calc. Not updated when bypassing
smoothStressX4	DS		1			; Low pass filtered stress used by BMU to control contactors
lastChgChanged	DS		1			; True (non zero) if lastBulk or lastFloat changed
chargerTxTimer	DS		1			; To keep charger packet transmission to the minimum required.

; Serial-io variables
	; Cell monitoring units comms variables
	; Note that the CMU variables have no prefix while the others have "scu" and "chg".
				ALIGNRAM 1
txCksum			DS		2			; CRC12 for data transmitted to CMUs/BMU or SCU
txCrc			DS		2			; CRC16 for data transmitted to PIP inverter
txBitTime		DS		2			; Determines transmit baud rate for timer-based comms (not UART).
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
txData			DS		2			; Byte to transmit in lower byte; always $FF in high byte
rxData			DS		1			; Received char
bitCntTx		DS		1			; Bit count 10 -> 1
bitCntRx		DS		1			; Bit count 8 -> 1

RxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
TxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
rxBuf			DS		RxSz		; Receive queue buffer
rxWr			DS		1			; Receive queue write index
rxRd			DS		1			; Receive queue read index
txBuf			DS		TxSz		; Transmit queue buffer
txWr			DS		1			; Transmit queue write index
txRd			DS		1			; Transmit queue read index

	; System control unit comms variables
				ALIGNRAM 1
scuBitTime		DS		2			; Determines bit rate.
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
scuTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
scuRxData		DS		1			; Received char
scuBitCntTx		DS		1			; Bit count 10 -> 1
scuBitCntRx		DS		1			; Bit count 8 -> 1

ScuRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
ScuTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256

				ALIGNRAM 1
scuRxBuf		DS		ScuRxSz		; Receive queue buffer
scuRxWr			DS		1			; Receive queue write index
scuRxRd			DS		1			; Receive queue read index
scuTxBuf		DS		ScuTxSz		; Transmit queue buffer
scuTxWr			DS		1			; Transmit queue write index
scuTxRd			DS		1			; Transmit queue read index

	; Charger/inverter comms variables
				ALIGNRAM 1
chgBitTime		DS		2			; Determines bit rate.
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
chgTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
chgRxData		DS		1			; Received char
chgBitCntTx		DS		1			; Bit count 10 -> 1
chgBitCntRx		DS		1			; Bit count 8 -> 1

ChgRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
ChgTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256

				ALIGNRAM 1
chgRxBuf		DS		ChgRxSz		; Receive queue buffer
chgRxWr			DS		1			; Receive queue write index
chgRxRd			DS		1			; Receive queue read index
chgTxBuf		DS		ChgTxSz		; Transmit queue buffer
chgTxWr			DS		1			; Transmit queue write index
chgTxRd			DS		1			; Transmit queue read index

				ALIGNRAM 1
rxCksum			DS		2			; CRC12 for data received from CMUs/BMU or SCU
prevRxCksum		DS		2			; Previous CRC12
priorRxCksum	DS		2			; Previous previous CRC12
errorRatio		DS		4			; Error ratio

				ALIGNRAM 1
ovZero			DS		2			; Overvoltage zero, set by 'VP command (param1 - 7 * param2)
ovStep			DS		2			; Overvoltage step, set by 'VP command (param2)
ticksSinceLastBypass DS	2			; Ticks since last bypass
beenBypassing	DS		1			; True if we've bypassed in last 5 minutes. Used by OT stress calc

; The following variables are for interrupt driven measurement code
				ALIGNRAM 1
sampIndex   	DS  	1    		; Cycles from 0 to 15
chanIndex   	DS  	1    		; Cycles from 0 to 3
chanList    	DS  	2*4    		; Initialised to channel selections and timing, for ADC10CTL1
partialSum  	DS  	2
rawMeasures							; Raw measurement results (sum of 16 measurements)
boltVPlRaw		DS  	2
boltVMiRaw		DS  	2
cellVRaw		DS  	2
temperatureRaw	DS  	2

				ALIGNRAM 1
eraseEnd							; End of the erased variables

; A kind of trip-meter for this cell's stress
worstStress		DS		1			; Worst local stress since the last resetWorstStress command
worstStressType	DS		1			; Type of measurement that caused worst stress
worstOV			DS		2			; Worst over-voltage since the last resetWorstStress command
worstUV			DS		2			; Worst under-voltage since the last resetWorstStress command
worstOT			DS		2			; Worst over-temperature since the last resetWorstStress command
worstUT			DS		2			; Worst under-temperature since the last resetWorstStress command
worstAL			DS		2			; Worst absolute link voltage since the last resetWorstStress command
; The 5 variables above are also treated as an array indexed from worstStress, so order matters

; Command Character Interpreter variables
				ALIGNRAM 1
ToIN			DS		2			; Pointer to present character being stored in Text Input Buffer
TIB				DS		48			; Text Input Buffer (packet buffer)
TIBEnd

TxBytePtr		DS		2			; Pointer to TxByte handler. Initially CmuTxByte, except for BMUs
									;	which initialise it to ScuTxByte
socPwmAdv		DS		2			; Amount to add to TACCTL2 for next compare value for SoC meter

; "Real time clock"
rtcDay			DS		1			; Day of week 0 = Sunday, 6 = Saturday
rtcHour			DS		1			; Hour (0=midnight, 12 = noon, 23 = 11 pm)
rtcMin			DS		1			; Minute (0-59)
rtcSec			DS		1			; Second (0-59)

; Must leave room for stack (about 36 bytes minimum)
STACKSPACE		EQU		InitSP-$	; Look at listing to see what this is

;-------------------------------------------------------------------------------
				ORG		PROG_START	; In main-flash
;-------------------------------------------------------------------------------

#include "../common/CmdCharInterpreter.s43" // RPN interpreter with one-or-two-character commands
#include "../common/InterruptComms.s43" // Comms routines
#include "../common/ComComms.s43"	// Common comms functions, e.g. TxCksum
#include "IntMeasure.s43"			// Interrupt driven ADC measurement functions
#include "../common/math.s43"		// Multiply and divide routines
#include "../common/Crc12.s43"		// Twoth CRC12 calculation routines
#include "crc.s43"					// PIP CRC16 calculation routines
#include "monoDefinitions.s43"		// Command character definitions
#include "master.s43"				// Master function for injecting commands

;-------------------------------------------------------------------------------
; InterpretInit
;-------------------------------------------------------------------------------

InterpretInit:                              ; This is called by the BSL, on reset.
InterpretByte:								; Should not be called -- but just in case
main:										; For IAR Embedded Workbench IDE debugger
			dint							; Disable interrupts while initialising various things that
											;	will use interrupts. Note that this will temporarily
											;	stop the FLL.
			ClearWatchdog					; Clear and enable Watchdog Timer 32k cyc. BSL sets 64 cyc.
			mov.w	#InitSP,SP				; Initialize stackpointer, likely not necessary

			; Clear all variables in RAM except resetBuffer and BMU's fuel-gauge discharge accumulator
			; and worstStress (and ToIN/TIB)
			; In other words: erase from comNoEraseEnd up to but not including eraseEnd
			_FOR		#eraseEnd-comNoEraseEnd,R8
				clr		comNoEraseEnd-2(R8)
			_NEXT_DECD	R8

			; Don't initialise system clock registers. BSL2 and the FLL have set them.

			cmp.b	#255,&ID					; Is this a BMU?
			_IF		EQ
				mov		#ScuTxByte,&TxBytePtr		; By default, TxByte goes to the SCU port for a BMU
			_ELSE
				mov		#CmuTxByte,&TxBytePtr		; In other cases, particularly CMUs, TxByte goes to
													;	the CMU port
			_ENDIF

;
;	Initialise io ports
;
			; Port 1 already set up by BSL.

			; Initialise port 2
			mov.b	#0,&P2OUT					; Set all outputs low.
			bis.b	#ErrLed,&P2DIR 				; Set ErrLed as output
			bis.b	#TxMiChg_57k6B|TxMiChg2_RlyP_57k6A,&ChgPortDIR ; Set Txs as outputs
												; Do not disturb bits 6, 7 (XIN, XOUT)
			bis.b	#RxChg|TxMiChg_57k6B,&ChgPortSEL	; Select timer functions for Rx and Tx pins
												; Do not disturb bits 6, 7 (XIN, XOUT)
			cmp.b	#255,&ID
			_IF		NE							; If we're not a BMU
				bis.b	#Bypass,&BypPortDIR 		; Set Bypass as output
			_ENDIF

			; Initialise port 3. CMUs don't use this port, but no harm in setting it up.
			; Don't change the state or direction of any BMU contactor outputs or you might cut off
			; power to the BMU.
			cmp.b	#255,&ID
			_IF		NE						; If we're a CMU
				mov.b	#$FF,&P3REN				; Enable pullup/pulldown resistors to save power, for
												;   any pin which may remain a floating input in a CMU.
			_ENDIF
			; Don't change the state of contactor outputs (or SoC) unless this is a power-on reset
			; or you might cut off your own power.
			mov		&resetCounter,R8
			dec		R8
			and		#$0F,R8
			mov.b	resetBuffer(R8),R8
			bit.b	#PORIFG,R8				; Check for power-on reset
			_IF		NZ						; If it was a power-on
				mov.b	#0,&P3OUT				; Turn off all contactors
				; SoC initialisation
				clr		&discharge				; Initialise the SoC to 100%
				clr		&discharge+2			; BMU will retrieve SoC from CMU 1
				call	#UpdateSoC				; Initialise the pre-computed counter advance value
			_ENDIF
			; Set contactor outputs as outputs in case they aren't already.
			mov.b	#PreCtor|BatPosCtor|BatNegCtor|AcLfPvCtor|RtPvCtor,&P3DIR
			bic.b	#TxMiScu,&ScuPortOUT		; Set Tx low
			bis.b	#TxMiScu,&ScuPortDIR		; Set Tx as output
			bis.b	#RxScu|TxMiScu,&ScuPortSEL	; Select timer functions for Rx and Tx pins

;
;	Initialise timer and interrupt comms
;
			; Don't initialise the UART. Everything is already set up from BSL, except for interrupts.
			; But we don't want to enable TX ints before anything is in the circular buffer.
			bis.b		#UCA0RXIE, &IE2			; Enable UART receive interrupts

			; Initialise the Timers
			cmp.b	#255,&ID					; If we're a BMU
			_IF		EQ
				; TA0CTL is set up correctly by the BSL as it is used for the Frequency Locked Loop.
				; Initialise timer TA1
				; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
				; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
				; MC: 2 = continuous mode 1 = up mode
				; TAIE = interrupt enable (for timer overflow)
				mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2, &TA1CTL

				; Initialise TA0 CCRs
				mov.w	#OUTMOD_5, &ScuCCTLt		; Initialise SCU transmit capture/compare register
				mov.w	#BitTime96,&scuBitTime		; Set the SCU bit time for 9600 baud
				mov.b	#$FF,&scuTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
				mov.b	#8,&scuBitCntRx				; Load Rx bit Counter, 8 data bits
				mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ScuCCTLr	; Falling edge, Input A, Sync, Capture

				; Initialise TA1 CCRs
				mov.w	#OUTMOD_5, &ChgCCTLt		; Initialise charger transmit capture/compare register
				mov.w	#BitTime24,&chgBitTime		; Set the charger bit time for 2400 baud
				mov.b	#$FF,&chgTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
				mov.b	#8,&chgBitCntRx				; Load Rx bit Counter, 8 data bits
				mov		#InitialCrc12,&txCksum		; Initialise transmit CRC12.
				mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ChgCCTLr	; Falling edge, Input A, Sync, Capture

				mov.w	#CCIE, &MeasCCTL			; Enable measurement interrupts on a BMU (TA1CCTL0)
			_ELSE									;  in compare mode.
				mov.w	#CCIE, &ScuCCTLr			; Enable measurement interrupts on a CMU (TA0CCTL2)
			_ENDIF									;  in compare mode.

			; Already cleared by loop above
;			clr.b	&rxWr						; Initialise the Tx and Rx queue indexes
;			clr.b	&rxRd
;			clr.b	&txWr
;			clr.b	&txRd

;
; Initialise the charger controller
;
			; Already cleared by loop above
;			clr.b	&shutdownTimer				; Initialise shutdown timer
;			clr.b	&chargerTxTimer				; Initialise charger transmit timer
			cmp.b	#255,&ID					; If we're a BMU
			_IF		EQ
;				mov.w	#ChargerVoltMin,&chargerVoltMin ; Initialise charger voltage min
;				mov.w	#ChargerVoltMax,&chargerVoltMax ; Initialise charger voltage max
				bis.b	#bChargerControl,&monFlags	; Set by o command
				bis.b	#bCharging,&monFlags		; Set by c command
			_ENDIF
;			clr.w	&piPrevOutput				; Initialise PI controller state
;			clr.w	&piPrevError				;
;			clr.w	&chargerPrevCurr			; Initialise charger current

			mov.w	#OV_ZERO,&ovZero
			mov.w	#OV_STEP,&ovStep
			mov.w	#CHG_BULK_STD,&prevBulk
			mov.w	#CHG_FLT_STD,&prevFloat

;
; Initialise the ADC10
;
			; Disconnect digital buffers from analog inputs. Enable ADC function of P1.4 (Vref+ out).
			; BMU TouchVChan is not currently used
			mov.b	#(1<<CellVChan)|(1<<BoltVMiChan)|(1<<BoltVPlChan)|(1<<4),&ADC10AE0
			; Initialise ADC10CTL0
			; SREF_1	= +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temp)
			; REFOUT	= connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			; ADC10ON	= power on the measurement system (now on all the time)
			mov		#SREF_1|ADC10SHT_3|REFOUT+REFON|ADC10ON,&ADC10CTL0
			; We precalculate the values for ADC10CTL1, to save time in the frequently-called
			; interrupt routine.
            ; We need the above maximum sample time of 64 cycles to get the 38 us we need to achieve
			; 12 bit accuracy with the 155 kR impedance of our voltage dividers.
			; ADC adds 2 kR and sampling capacitor is 27 pF.
            ; Temperature measurement also requires 30 us just to get half-degree accuracy.
            ; So ADC clock frequency should not be much greater than 64/38 us = 1.67 MHz.
            ; Datasheet gives 3.7-6.3 MHz range for ADC10OSC but this seems to be reduced to
            ; something like 3.4-5.9 MHz due to Vcc being 2.5 V instead of 3.0 V.
			; For the LSB of each chanList element, see the comments for AdcTimingTbl below.
			mov.b	&AdcTimIdx,R9				; Get the ADC timing index from info-flash
			rra4	R9							; MS nibble is for Monolith. LS nibble is for TestICal
			cmp		#NumAdcClocks+1,R9			; Test the ADC timing index
			_IF		HS							; If not in the range 0 to NumAdcClocks
				clr		R9							; Then use default timing (index = 0)
			_ENDIF
			mov.b	AdcTimingTbl(R9),R9			; Get byte value from table
			mov.b	R9, chanList+0				; Store it for each conversion channel
			mov.b	R9, chanList+2
			mov.b	R9, chanList+4
			mov.b	R9, chanList+6

; MSB of each chanList element must contain the channel number in the INCHx position
			; and have SHSx, ADC10DF and ISSH all set to zero.
			; INCHx		= channel number to convert
			; SHS_0		= enable software starting via the ADC10SC bit
			; &~ADC10DF	= straight binary output, not twos complement.
			; &~ISSH	= the sample input signal is not inverted
			mov.b	#BoltVPlChan<<4,&chanList+1+0
			mov.b	#BoltVMiChan<<4,&chanList+1+2
			mov.b	#CellVChan<<4,	&chanList+1+4
			mov.b	#TempChan<<4,	&chanList+1+6

			mov		&chanList+0, &ADC10CTL1		; Ready for the first conversions
;
; Initialise the command character interpreter
;
			mov		#InitialCrc12,&rxCksum	; Initialise received packet CRC12
			cmp.b	#255,&ID					; If we're not a BMU
			_IF		NE
				mov.b	#bErrorChecking,&interpFlags ; Default error checking on
			_ELSE
				mov.b	#bErrorChecking | bDontEcho | bEchoResponses,&interpFlags ; Don't want to echo
													; command packets, do want to see responses
			_ENDIF
;			bic.b	#bHexOutput,&interpFlags	; Default numeric output to be in decimal, not hexadecimal
;			bic.b	#bDontInterpret,&interpFlags ; Do interpret
;			bic.b	#bDontEcho,&interpFlags	; Do echo
			mov		#TIB,&ToIN				; Initialise write pointer into text input buffer
;
; Miscellaneous initialisation
;
			mov.b	#4,&passWordState		; Waiting for first byte of bootstrap loader password
			mov		#(3300*256)&$FFFF,&ocCellVoltX256	; Initialise the low pass filter for the
			mov		#(3300*256)>>16,&ocCellVoltX256+2	;	average cell voltage to 3300 mV
			mov		#PipInitTbl,&pipInitPtr	; Point to the first init string

			eint							; Enable interrupts now that all initialisation is complete

; Do precharge and get the main contactor on, so we stay powered up
; even when the human lets go of the green button.
			cmp.b	#255,&ID
			_IF		EQ							; If we're a BMU
				call	#DoPrecharge
			_ENDIF

; If we're a BMU, ensure CMUs are using and expecting CRC12s, and sending status bytes,
; then retrieve the high word of the discharge accumulator from CMU 1
; This is now done in Master, using the bSendInit masterFlag.
			cmp.b	#255,&ID
			_IF		EQ
				bis.b	#bSendInit,&masterFlags
			_ENDIF

; Main loop
			_REPEAT
				; If we're a BMU (ID = 255) handle SCU and Charger communication.
				cmp.b	#255,&ID				; Check my ID
				_IF		EQ						; If I'm a BMU
					; Check for a character from the SCU Rx port, and send it to the CMU Tx port.
					; Also pass it to the "Master" function, so it knows when it is safe for it to
					; inject commands such as Z, G and i as required.
					call	#ScuRxByteNW			; Try to read a character from the SCU
					_IF		NZ						; If there was one
						tst.b	R8						; Check if the high bit is set
						_IF		NN						; If the high bit is not set (not a status byte)
							call	#CmuTxByte				; Send it to the CMUs. Preserves R8
							call	#DoPassword				; Check for BSL password bytes from SCU port
						_ENDIF
					_ELSE							; Else there was no character
						clr		R8						; Indicate to Master that no char is avail
					_ENDIF
					call	#Master					; Call the "Master" function, char or not

					; Check for a character from the Chg Rx port, and send it to the SCU Tx port.
					call	#ChgRxByteNW			; Try to read a character from the charger (PIP)
					_IF		NZ						; If there was one
						bic.b	#$80,R8					; Clear hi bit so doesn't look like status byte
						call	#ScuTxByte				; Send it to the SCU
					_ENDIF
				_ENDIF

				; Check for a command or status character from the CMU port
				; For both CMUs and the BMU, read from CMU Rx
				call	#RxByteNoWait			; Check if received CMU data
				_IF		NZ
					tst.b	R8
					_IF		NN						; If an ordinary (non status) char
						call	#DoEcho					; Echo the command or password byte if required
						; Check for a BSL password
						cmp.b	#255,&ID				; Check ID
						_IF		NE						; If I'm not a BMU
							call	#DoPassword				; Check for BSL password bytes from CMU port
						_ENDIF
						call	#ACCEPT					; Process command bytes (could be slow)
					_ELSE							; Else was status byte
						call	#DoStatus				; Forward possibly-updated status bytes
					_ENDIF
				_ELSE
					call	#UpdateRtc					; Update "real time clock" if needed

					; Check if time to measure. The FLL interrupt (happens 4096 times per second) is
					;	incrementing &measureCount. We want to know if this count has advanced by
					;	4096/StatusFreq or more since the last measure (when &measureCount was saved as
					;	&oldMeasureCount)
					mov		&oldMeasureCount,R8
					add		#(4096/StatusFreq),R8		; Where it will be at measure time (minimum)
					sub		&measureCount,R8			; Subtract where it is now
					_IF		NN							; If this is nonnegative, it is not time to measure
				;		mov.w	#WDTPW+WDTHOLD,&WDTCTL		; Stop Watchdog Timer before sleeping CPU
				;		bis		#CPUOFF+GIE,SR				; Turn off CPU and ensure interrupts still enabled
					_ELSE								; Else time to measure
						add		#(4096/StatusFreq),&oldMeasureCount ; Set the count for the next measure
						call	#DoMeasurement			; May transmit status
					_ENDIF
				_ENDIF

			ClearWatchdog				; Clear and restart Watchdog Timer each time around main loop

			_FOREVER
; End of main loop


;
; Call this repeatedly to initialise the PIP4048MS inverter with various non-default settings
;
InitPip:
			mov		&pipInitPtr,R10		; Point to the current initialisation string
			call	#ChgTxString		; Send one command
			mov		R10,&pipInitPtr		; Update the pointer
			tst.b	0(R10)				; Check the next length byte
			_IF		Z					; If it's zero, this is the end of the table
				clr		&pipInitPtr				; For tidiness
				bis.b	#bDonePipInit,&monFlags	; Tell DoMeasurement and ControlContactors that we're done
			_ENDIF
			ret


#define		OFF_GRID 		1
#define		ON_GRID_SMALL	2
#define		ON_GRID_LARGE	3

; PIP 4048MS inverter/charger initialisation strings. First byte is length.
; CRCs are precomputed using http://www.lammertbies.nl/comm/info/crc-calculation.html
; CRC-CCITT (XModem), except $0D, $0A and $28 bytes in the CRC must be incremented. See crc.s43.
PipInitTbl 	DB	1,$0D						; First send a CR in case PIP has already received junk.
											; This will cause an initial NAK.
#if	CONFIG == OFF_GRID
		 	DB	8,'POP00',$C2,$48,$0D		; Utility priority (default) (for off-grid use) (Param 1)
;		 	DB	8,'POP01',$D2,$69,$0D		; Solar priority (Param 1)
#else
			DB	8,'POP02',$E2,$0B,$0D		; "SBU" (Solar, Bat, Util) priority (for on-grid use) (Param 1)
#endif
			DB	6,'PDa',$E3,$41,$0D			; Disable beeper (Param 18)
			DB	6,'PDk',$42,$0B,$0D			; Disable return to default screen (Param 19)
;			DB	6,'PEj',$61,$1B,$0D			; Enable load-sense (Param 4)
			DB	6,'PEu',$82,$C5,$0D			; Enable OL-restart (Param 6)
			DB	6,'PEv',$B2,$A6,$0D			; Enable OT-restart (Param 7)
			DB	6,'PDy',$70,$78,$0D			; Disable beeps when primary charge source interrupted (Param 22)
			DB	6,'PEz',$73,$2A,$0D			; Enable fault info recording; access with QFS
			DB	8,'PBT02',$07,$4C,$0D		; Battery type "User" (Param 5)
;			DB	8,'PGR01',$39,$CA,$0D		; AC input range "UPS" (170 to 280 Vac) Doesn't work with genset (Param 3)
;			DB	11,'PSDV52.0',$65,$A4,$0D	; Battery low cutoff voltage 52.0 V (3.25 Vpc)
;			DB	11,'PSDV51.6',$5C,$32,$0D	; Battery low cutoff voltage 51.6 V (3.225 Vpc)
;			DB	11,'PSDV51.2',$1C,$B6,$0D	; Battery low cutoff voltage 51.2 V (3.20 Vpc)
			DB	11,'PSDV50.8',$8A,$CC,$0D	; Battery low cutoff voltage 50.8 V (3.175 Vpc) (Param 29)
;			DB	11,'PSDV48.0',$D4,$D1,$0D	; Battery low cutoff voltage 48.0 V (3.00 Vpc)
			DB	11,'PBCV51.0',$7B,$AF,$0D	; Start charging from util (if avail) when bat falls to 51 V (Param 12)
#if CONFIG == OFF_GRID
			DB	11,'PBDV00.0',$38,$9B,$0D	; Stop charging from utility when "FUL", i.e. float achieved (Param 13)
											; The $9B above acts as an ESC for TeraTerm so don't be
											; fooled by the fact that you don't see the next 3 commands.
#else
;			DB	11,'PBDV52.0',$EA,$BE,$0D	; Stop charging from utility when bat rises to 52 V (Param 13)
			DB	11,'PBDV53.0',$DD,$8E,$0D	; Stop charging from utility when bat rises to 53 V (Param 13)
#endif
			DB	11,'PCVV55.2',$66,$C9,$0D	; Set bulk/absorb voltage to 55.2 V (3.45 Vpc) (Param 26)
;			DB	11,'PBFT53.8',$93,$45,$0D	; Set float voltage to 53.8 V (3.3625 Vpc)
			DB	11,'PBFT53.7',$62,$AA,$0D	; Set float voltage to 53.7 V (3.35625 Vpc) (Param 27)
#if CONFIG != ON_GRID_LARGE
			DB	13,'MNCHGC0100',$16,$3A,$0D	; Maximum charge current 100 amps (utility plus solar) (Param 2)
#else
			DB	13,'MNCHGC0120',$70,$58,$0D	; Maximum charge current 120 amps (if battery >= 200 Ah; Param 2)
#endif
;			DB	12,'MUCHGC020',$F3,$F1,$0D	; Maximum utility charge current 20 amps (Param 11)
			DB	12,'MUCHGC030',$C0,$C0,$0D	; Maximum utility charge current 30 amps
;			DB	12,'MUCHGC040',$59,$57,$0D	; Maximum utility charge current 40 amps
			DB	0							; Zero length at end of table
			ALIGN		1



DoMeasurement:
;
; Regular measurement. Called StatusFreq times per second (2-16 times per second, see InterruptComms.s43)
;
#define Rstrs R12				// Worst stress (present, not trip)
#define Rmeas R14				// Measurement causing worst stress
#define Rtype R15				// Type of measurement causing worst stress

			inc.b	&ticks					; Used to time various infrequent tasks. Allowed to wrap.
			bit.b	#bDonePipInit,&monFlags	; Check if we've already done PIP initialisation
			_IF		Z
				cmp.b	#PipWait, &pipInitCtr
				_IF		NE
					inc.b	&pipInitCtr				; Wait till the PIP is ready to receive commands
				_ELSE
					mov		#$7FFF,&errorRatio		; Reset errorRatio so we don't count startup junk
					mov		#$0000,&errorRatio+2
					cmp.b	#255,&ID				; Check ID
					_IF		EQ						; If we're a BMU
						cmp.b	#PipCmdWait, &pipCmdCtr
						_IF		NE
							inc.b	&pipCmdCtr			; Wait the delay before each init string
						_ELSE
							clr.b	&pipCmdCtr
							call	#InitPip			; Send the next PIP initialisation string
						_ENDIF
					_ELSE							; Else we're a CMU
						bis.b	#bDonePipInit,&monFlags	; Tell DoMeasurement we're done
					_ENDIF
				_ENDIF
			_ENDIF

			clr		Rstrs					; Init present stress to zero
			clr		Rmeas					; Init measurement causing zero stress to zero
			clr		Rtype					; Init type of measurement causing zero stress to zero

			inc.b	&ticksSinceLastRx		; Cleared whenever valid stress byte received
			_IF		C						; If unsigned overflow
				mov.b	#$FF,&ticksSinceLastRx	; Saturate at $FF
			_ENDIF
			inc.b	&ticksSinceLastI		; Cleared whenever an 'i' (current) command is received
			_IF		C						; If unsigned overflow
				mov.b	#$FF,&ticksSinceLastI	; Saturate at $FF
			_ENDIF

			cmp.b	#255,&ID				; Check ID
			_IF		NE						; If we're not a BMU
				cmp.b	#ZeroCurrentTicks,&ticksSinceLastI ; Check ticks since last 'i' command
				_IF		HS 					; if too many ticks since last 'i' (current) command
					mov		#0,&current				; Assume current is zero
				_ENDIF
			_ENDIF

			; Do cell voltage measurement
			call	#GetCellV				; Get cell voltage in mV in R10
			cmp.b	#255,&ID				; Check ID
			_IF		EQ						; If we're a BMU
				; Multiply by 100/16 to bring the total battery voltage in tenths of a volt to
				;	average cell millivolts. This is to let us use the same IR compensating code that
				;	the CMUs already use.
				; Use shifts and adds to multiply by 25, then divide by 4 at the end. 25 = 16+8+1
				mov		R10,R8					; R8 = 1x
				rla3	R8						; R8 = 8x
				add		R8,R10					; R10 = 9x
				rla		R8						; R8 = 16x
				add		R8,R10					; R10 = 25x
				mov		R10,R8					; Copy to R8
				rra2	R10						; R10 = 6.25x
				and		#2,R8					; Check if rounding needed
				_IF		NZ
					inc		R10						; Round up
				_ENDIF
			_ENDIF
			; Estimate OCV by subtracting current times internal resistance from measured voltage.
			; Shunt must be wired so charge current is positive and discharge current is negative.
			push	R10						; Save the cell voltage measurement

			; We have a 16x16=32-bit multiply, and we want to scale the current and resistance
			; so the high 16 bits of the result is the voltage in millivolts, while ensuring
			; that the scaled current and resistance do not overflow unsigned 16 bits.
			; Also, we want to limit the scaling of the current to binary-shifts since it
			; must be done at runtime, while the scaling of resistance can be more complicated
			; since it can be done at assembly time.
			; We will scale current by >>3 to 1/80ths of an amp, so overflow is at 819.2 A.

			; Get the scaled cell internal resistance into R8.
			; Given that we want the result to be in 1/65536ths of a millivolt, we need to scale
			; resistance to 1/(65536/80) = 1/819.2ths of a milliohm
			; We rely on the fact that the assembler performs 32 bit calculations.
			; HiTempCellRes is in micro-ohms.
			; The +5000 is for correct rounding of the truncating division by 10000.
			mov		&infoCellRes,R10
			clr		R9
			REPT	3
				rra		R10
				rrc		R9
			ENDR
			add		#5000,R9
			adc		R10
			mov		#10000,R8
			call	#UMSlashMod
			mov 	R9,R8
			; Now in 1/819.2ths of a milliohm, so overflow at 80 mR

			; Adjust the internal resistance for temperature using an approx Arrhenius' equation.
			; So the temperature-dependent component doubles for every 10 degC drop in temperature.
			; Assume that the "HiTempCellRes" constant is the fixed or high-temperature component,
			; and that, at 10 degC, the temp-dependent component is equal to the fixed component.
			; So the cell resistance at a given temperature is estimated as
			; CellResistance = HiTempCellRes * [1 + 2^(1-T/10)] where T is the cell temperature.

			; Shift right 3 bits to get the temperature dependent component at 40 degC, in R9.
			add		#4,R9
			rra3	R9

			; For every 6 degrees we are below 40 degC, multiply resistance by 1.5 (approx 2^(6/10))
			; Could mult by 1.25 for every 3 deg, but it would take longer. Accuracy not needed.
			mov		#40-3,R11				; R11 is loop counter, init 40 degC, -3 for rounding
			_DO
				cmp		&cellTemperature,R11
			_WHILE	GE						; While loop counter >= temperature
				mov		R9,R10					; Multiply resistance by 1.5
				rra		R10
				add		R10,R9
				sub		#6,R11					; Decrement loop counter by 6 degC
			_ENDW
			add		R9,R8					; Add the temperature-dependent part to the fixed part

			; Get the scaled absolute value of the current into R9
			mov		&current,R9				; Current is in tenths of an amp
			abs		R9
			rla3	R9						; Now in 1/80ths of an amp, so overflow is at 819.2 A

			; Multiply cell resistance and current, and subtract from measured cell voltage
			ClearWatchdog
			call	#UMStar					; R10:R9 = R8 * R9, resistance * current, clears R11
			mov		R10,R9					; Use only the high word of the result, put into R9
			pop		R10						; Restore the cell voltage measurement to R10
			tst		&current
			_IF		NN						; If current is not negative (i.e. if charging)
				sub		R9,R10					; OCV is lower than measured, when charging
			_ELSE							; Else discharging
				add		R9,R10					; OCV is higher than measured, when discharging
			_ENDIF							; Endif

            ; Calculate the smoothed IR-compensated cell voltage (average if BMU)
            ; Use (255/256) * old + (1/256) * new
            ; = (old << 8 - old + new) >> 8
            ; Label ocCellVoltX256 as 0HML (Zero High Middle Low bytes)
            mov		&ocCellVoltX256  ,R8; Get lower word ML
            mov		&ocCellVoltX256+2,R9; Get upper word 0H
            rra8_l	R9,R8				; Shift right 8 bits with tricky macro
            sub		R8,&ocCellVoltX256	; Ram -= old
            sbc		&ocCellVoltX256+2
            add		R10,&ocCellVoltX256 ; Ram += new
            adc		&ocCellVoltX256+2

            cmp.b	#255,&ID				; If a BMU
			_IF		EQ
				; Check for low rested average cell voltage and update of SoC
				; First check if battery current is "rested"
				_COND
					cmp		#20,&current		; No more than 2.0 A
				_AND_IF	L
					mov		&infoCapacity,R8
					add		#8,R8				; Add half the divisor, for rounding
					rra4	R8					; C/16 in tenths of an amp
					neg		R8
					cmp		R8, &current
				_AND_IF	GE					; No less than -C/16
					mov		&ocCellVoltX256  ,R8; Get lower word ML
					mov		&ocCellVoltX256+2,R9; Get upper word 0H
					rra8_l	R9,R8
					cmp		#3251,R8
				_AND_IF	L					; <= 3.250 V smoothed
					inc		&restedCounter
					cmp		#10*60*StatusFreq,&restedCounter
					_IF		HS				; If counter >= 10 minutes
						clr		&restedCounter
						; Calculate a new SoC based on the rested smoothed average cell voltage that
						;	hasn't been charging for 10 minutes
						; Use SoC = (V-3.15)*300%
						sub		#3150,R8			; R8 = smoothed average cell voltage - 3.150 V
						; Result is 0-100 representing 0-30.0% SoC
						; So the units are 0.3%. Multiply by 3 to bring to tenths of a percent.
						mov		R8,R9				; R9 = 1x
						rla		R8					; R8 = 2x
						add		R8,R9				; R9 = 3x
						call	#SocToDischarge		; Convert to discharge
						mov		R9,&discharge		; Update discharge counter
						mov		R10,&discharge+2
					_ENDIF
				_ELSES
					clr		&restedCounter
				_ENDIF

			_ENDIF	; not BMU

			; Set bypass as required
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		NE
				mov			&ovStep,R9			; Calculate the bypass threshold in R9
				rla3		R9					; = ovZero + 7*ovStep
				add			&ovZero,R9			; = 8*ovStep + ovZero - ovStep
				sub			&ovStep,R9
				cmp			R9,R10				; Compare present cell voltage (R10) to bypass threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00

				; Update the beenBypassing flag used by the OT stress calculation
				_IF		HS						; If bypassing (Note: HS = C)
					clr		&ticksSinceLastBypass	; ticksSinceLastBypass := 0
					mov.b	#1,&beenBypassing		; beenBypassing := TRUE
				_ELSE							; Else not bypassing
					tst.b	&beenBypassing
					_IF		NZ						; If been bypassing in last 5 minutes
						inc		&ticksSinceLastBypass	; ticksSinceLastBypass += 1
						cmp		#5*60*StatusFreq,&ticksSinceLastBypass
						_IF		HS						; If 5 minutes or more since last bypass
							clr.b	&beenBypassing			; beenBypassing := FALSE
						_ENDIF							; End if
					_ENDIF							; End if been bypassing in last 5 minutes
				_ENDIF							; End else not bypassing

				movBits_B	R8,#Bypass,&P2OUT	; Move only the #Bypass bit from R8 to &P2OUT. Trashs R8
				add			&ovStep,R9			; Calculate the full (coulomb-counter reset) threshold
												;	One level above bypass (cf. one below for monitor)
				cmp			R9,R10				; Compare cell voltage (R10) to the full threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#ALL_FULL,&localStatus ; Move only All-Full bits from R8 to localStatus
			_ELSE
				bis.b		#ALL_FULL,&localStatus	; BMU must pretend it's in bypass so charge terminates
			_ENDIF

			cmp.b	#255,&ID
			_IF		NE						; If we're not a BMU
				push	R10						; For undervoltage stress calc below
				; Calculate stress due to overvoltage
				push	R10						; OCV for overvoltage stress calc
				push	&ovStep					; For every ovStep (millivolts)
				push	&ovZero					;	over ovZero, we add one level of stress
				push	#1						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if non-zero stress due to OV

				; Calculate stress due to undervoltage
													; OCV for undervoltage stress calc already pushed
				push	#UV_STEP				; For every UV_STEP (millivolts)
				push	#UV_ZERO				;	below UV_ZERO, we add one level of stress
				push	#2						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress UV
			_ENDIF	; not a BMU

			; Do temperature measurement
			call	#GetTemp				; Get temperature in degrees Celsius in R10

			cmp.b	#255,&ID
			_IF		EQ						; If we're a BMU
				sub		#8,R10					; Subtract 8 kelvin for self-heating
				mov		R10,&cellTemperature	; Save temp for calculation of internal resistance
			_ELSE							; Else we're not a BMU
				push	R10						; Save measurement for undertemperature stress calc
				; Calculate stress due to overtemperature

				; Prevent nuisance alarms/shutdowns when high temp is only due to bypassing
				tst.b	&beenBypassing
				_IF		NZ						; If we've been bypassing in the last 5 minutes
						sub		#BypTempQuota,R10	; Subtract 15 degC from the temp used for OT stress
				_ELSE							; Else only update cellTemperature when not bypassing
						mov		R10,&cellTemperature ; Save temp for calculation of internal resistance
				_ENDIF							; End if

				push	R10						; Measurement for overtemperature stress calc
				push	#OT_STEP				; For every OT_STEP (degrees Celsius)
				push	#OT_ZERO				;	over OT_ZERO, we add one level of stress
				push	#3						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to OT

				; Calculate stress due to undertemperature
												; Measurement saved on stack earlier
				push	#UT_STEP				; For every UT_STEP (degrees Celsius)
				push	#UT_ZERO				;	below UT_ZERO, we add one level of stress
				push	#4						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to UT
			_ENDIF

			; Calculate stress due to link voltage (current shunt measurement for a BMU)
			call	#GetLinkV				; Get worst link voltage in mV in R10
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		NE
				cmp		#9999,R10				; Special "invalid" value?
				_IF		NE						; Only calculate link stress if not this value
					; Calculate stress due to excessive absolute link voltage
					tst		R10						; Get absolute value of link voltage
					_IF		L
						inv		R10
						inc		R10
					_ENDIF
					push	R10						; Measurement for absolute link stress calc
					push	#AL_STEP				; For every AL_STEP (millivolts)
					push	#AL_ZERO				;	over AL_ZERO, we add one level of stress
					push	#5						; Type of measurement
					call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to AL
				_ENDIF
			_ELSE	; BMU
				; We have a 200 A 50 mV shunt,
				; and the diffamp has a gain of 10, so the linkV result should be
				; in units of 0.2 A. So -1500 to 1500 corresp to -300 A to 300 A.

												; Multiply by 2 to
				rla		R10						;  convert to tenths of an amp
												; Note: this means that the unit of current used by CMUs
												;	and the discharge logic is 1/10 A
				mov		R10,&current			; Save in RAM variable
				bis.b	#bSendi,&masterFlags	; Indicate that an 'i' command using &current is due
				ClearWatchdog					; When testing, seem to need this


				tst		&current
				_IF		NN						; If current is not negative
					bis.b	#bCharging,&monFlags	; We're charging
				_ELSE							; Else
					bic.b	#bCharging,&monFlags	; We're not charging
				_ENDIF							; Endif

				; Sign extend current to 32 bits in R10:R9.
				mov		&current,R9					; Get current in R9
				mov		R9,R10						; Make a copy in R10
				rla		R10							; Shift sign bit to carry
				subc	R10,R10						; 0 if R9 is negative, -1 otherwise
				inv		R10							; -1 if R9 is negative, 0 otherwise

				; Do coulomb counting
				sub		R9,&discharge				; Integrate current in 32-bit discharge accumulator
				subc	R10,&discharge+2			; for fuel gauge
				_IF		NN							; Clamp negative values to zero
				_ELSE								; There is no true _IF N with the MSP430
					clr		&discharge
					clr		&discharge+2
				_ENDIF
				call	#UpdateSoC					; Update the pre-computed SoC timer advance value

				; Send the high word of the discharge counter to safe storage
				tst.b	&ticks						; Every 128 seconds
				_IF	Z
					bis.b	#bSendZ,&masterFlags		; Indicate to the master that a Z command is due
				_ENDIF ; Every 128 seconds
			_ENDIF ; BMU current measurement

			cmp.b	#255,&ID
			_IF		NE						; If we're not a BMU
				; Clamp local present stress to a maximum value
				mov		#15,R9					; Default clamp value is 15
				cmp		#4,Rtype
				_IF		EQ						; If type is undertemperature
					mov		#MinContStress,R9		; Clamp to a max of 12 to avoid masking UV >= 12
				_ENDIF
				mov		Rstrs,R8				; Copy stress. movBits_B macro below trashes R8
				cmp		R9,R8					; If the stress is not less than the maximum allowed
				_IF		HS
					mov		R9,R8					; Use the maximum allowed
				_ENDIF

				; Update local present stress
				movBits_B R8,#STRESS,&localStatus ; Record for later use, preserving other status bits.

				; Update local present stress type if not already set to "all considered full" above.
				mov.b	&localStatus,R10
				and		#S_TYPE,R10
				cmp		#ALL_FULL,R10
				_IF		NE						; If stress type is not already All considered Full
					cmp		#2,Rtype
					_IF		EQ						; If stress type is UnderVoltage
						mov		#UV_AF,R8				; Set the UV_AF bit, clear the OV_UT bit
					_ELSE							; Else
						_COND							; Begin short circuit conditional
							cmp		#1,Rtype
						_OR_ELSE EQ					; If type is OverVoltage, else
							cmp		#4,Rtype
						_OR_IFS	EQ						; or if type is UnderTemperature
							mov		#OV_UT,R8				; Set the OV_UT bit, clear the UV_AF bit
						_ELSE							; Else type is OT (3) or AL (5)
							clr		R8						; Clear both type bits (never ignore)
						_ENDIF
					_ENDIF
					movBits_B R8,#S_TYPE,&localStatus ; Record type for later, presrve other status bits
				_ENDIF

				; Update worst stress since last reset thereof
				cmp.b	&worstStress,Rstrs		; If stress high or same as worstStress for trip so far
				_IF		HS
					tst.b	Rstrs					; and it's an actual, nonzero stress
					_IF	NZ
						mov.b	Rstrs,&worstStress		; Update worstStress
						mov.b	Rtype,&worstStressType	; Update type of measurement causing worst stress
					_ENDIF
				_ENDIF

				; Update Alarm -- local red LED and piezo
				cmp.b		#MinAlarmStress,Rstrs ; Turn on error LED if stress is MinAlarmStress or more
				CtoAllBits	Rtos
				bit.b		#bBadInsulation,&monFlags
				CtoAllBits	R8
				bis			R8,Rtos				; or if the last insulation test failed (BMU only)
				cmp			#200/4*16, &cellVRaw
				_IF			LO					; Don't alarm if cell disconnected (approx < 200 mV)
					clr			Rtos					; Actively turn alarm off if already on
				_ENDIF
				call		#ErrorLed			; Use this function so it optionally turns on piezo too
			_ENDIF	; Not a BMU

			; Check for comms error and send local status if required
			bic.b	#COM_ERR,&localStatus	; Clear comms error flag by default. May be set below.
			bit.b	#bNotSendStatus,&monFlags ; If sending status, and so expecting to receive it
			_IF		Z
				cmp.b	#ComErrTicks,&ticksSinceLastRx ; and too many ticks since last valid status Rx
				_IF		HS
					; If our ID is not 1 (first CMU), set the comms error bit in local status
					; and send a comment with our ID followed by 'c' for comms error
					; every 16 status bytes (approx every 8.5 seconds).
					cmp.b	#1,&ID
					_IF		NE
						bis.b	#COM_ERR,&localStatus
						mov.b	&ticks,R8
						and.b	#$F,R8
						_IF	Z
							call	#_commsError			; Call pretty-printing command
						_ENDIF
					_ENDIF

					; Act as a master -- send our status
					mov.b	&localStatus,R8
					bis.b	#$80,R8					; Set the high bit to say it's a status byte

					; Send status or control a charger
					cmp.b	#255,&ID
					_IF		NE						; If we're a CMU
						call	#TxByte					; Send the status byte. Wait buffer not full
					_ELSE							; Else we're a BMU, in charger control mode
						call	#ScuTxByte				; Send status to the SCU. Wait buffer not full
						mov.b	R8,&globalStatus		; '255sp' (or modbus equiv) reads global status
						call	#ControlContactors		; Control contactors
					_ENDIF							; End if
				_ENDIF							; End if too many ticks since last rx
			_ENDIF							; End if sending status
			ret
; End of DoMeasurement


DoStress:
;
; Called 5 times by DoMeasurement to calculate the various kinds of stress
; and keep track of which is worse.
; It takes 4 parameters on the stack and updates 3 registers as required (Rstrs, Rmeas, Rtype).
; Trashes R8 thru R11.
;
; Stack offsets for parameters (return address is at offset zero)
type	EQU		2				; A number representing the type of measurement OV=1 UV=2 OT=3 UT=4 AL=5
zero	EQU		4				; The measurement corresponding to zero stress
step	EQU		6				; The change in measurement corresp to a change of one stress level
meas	EQU		8				; The measurement

			ClearWatchdog
			mov		meas(SP),R9				; Get meas in R9
			mov		type(SP),R10			; Get type * 2 in R10 for use as word index
			rla		R10
			mov		step(SP),R8				; Get step in R8
			tst		R8
			_IF		GE
				cmp		worstStress(R10),R9
				_IF		GE						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				sub		zero(SP),R9				; Get meas - zero in R9
			_ELSE
				cmp		worstStress(R10),R9
				_IF		L						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				inv		R8						; Get absolute value of step in R8
				inc		R8
				mov		zero(SP),R9				; Get zero - meas + step -1 in R9
				sub		meas(SP),R9
				add		step(SP),R9
				sub		#1,R9
			_ENDIF
			_IF		L
				clr		R9						; Min of 0
			_ENDIF
			clr		R10						; Clear high word of dividend
			call	#UMSlashMod				; R9 = R10:R9 / R8 = (meas - zero) / step, clears R11
			cmp		R9,Rstrs
			_IF		LO						; If this stress worse than present stress calculated so far
				mov		R9,Rstrs				; Make it the new present stress
				mov		meas(SP),Rmeas			; Measurement causing present stress
				mov		type(SP),Rtype			; Type of measurement causing present stress
			_ENDIF
			pop		R8						; Pop the return address
			add		#8,SP					; Drop the parameters off the stack
			br		R8						; Return
; End of DoStress


DoStatus:
;
;	Process received status byte in R8. Trashes R9, R10
;	Status byte:
;	Bit 7: Always 1 for status byte
;	Bit 6: Comms error: Means that status information does not represent the whole pack
;	Bit 5: Ignore on charge (if bit 4 is clear), All considered full (if bit 4 is set)
;	Bit 4: Ignore on discharge
;	Bits 3-0: Stress level 0-15
;
		; Extract the stress bits from the incoming status byte
		mov.b	R8,R9					; Copy incoming status to R9
		and.b	#STRESS,R9				; Only stress bits in R9

		clr.b	&ticksSinceLastRx		; Now zero time since last received valid status
		; This will eliminate any comms error next time through DoMeasurement

		; Check if DoMeasurement may have just sent a status byte, due to a comms error
		bit.b	#COM_ERR,&localStatus
		_IF		Z						; If no comms error

			cmp.b	#255,&ID
			_IF		NE						; If we're a CMU
				; Do MAX of local and incoming stress, and handle stress type and all considered full
				mov.b	&localStatus,R10		; Get local status to R10
				and.b	#STRESS,R10				; Extract stress bits
				cmp.b	R10,R9					; Compare incoming stress (R9) to ours (R10)
				_IF		LO						; If incoming stress (R9) is less than ours (R10)
					mov		R8,R9					; Make a copy of incoming status for tests below
					mov.b	&localStatus,R10		; Get local status to R10
					movBits_B	R10,#STRESS|S_TYPE,R8 ; Replace incoming stress and type with ours (trashes R10)
					_COND
						and		#S_TYPE,R9
						cmp		#ALL_FULL,R9
					_AND_IF	NE						; If incoming was not all considered full
						mov.b	&localStatus,R10
						and		#S_TYPE,R10
						cmp		#ALL_FULL,R10
					_AND_IF	EQ						; and if local is in bypass
						bic		#UV_AF,R8 				; Clear the UV_AF (undervoltage or all considered full) bit
					_ENDIFS
				_ELSE							; Else incoming stress is not less than ours
					_IF		EQ						; If incoming stress is equal to ours
						mov.b	&localStatus,R10		; Ensure UV trumps other types, particularly UT,
						and		#S_TYPE,R10				; which won't go away when sources dropped, and
						cmp		#UV_AF,R10				; may mask UV and prevent loads being dropped.
						_IF		EQ						; If local is undervoltage
							movBits_B	R10,#S_TYPE,R8		; Replace incoming type with ours (trashes R10)
						_ENDIF
					_ENDIF
					; Incoming stress not less than ours
					mov		R8,R9					; Make a copy of incoming status for tests below
					_COND
						and		#S_TYPE,R9
						cmp		#ALL_FULL,R9
					_AND_IF	EQ						; If incoming is all considered full
						mov.b	&localStatus,R10
						and		#S_TYPE,R10
						cmp		#ALL_FULL,R10
					_AND_IF	NE						; and if local is not in bypass
						bic		#UV_AF,R8 				; Clear UV_AF (UV or all considered full) bit
					_ENDIFS
				_ENDIF							; End else incoming stress is not less than ours

				; Process incoming comms error bit.
				; Since we received a valid status byte, there is no local
				;	comms error, so just pass the incoming comms error bit through.

				; Send the possibly-updated status byte
				call	#TxByte					; Send the status byte. Wait buffer not full
			_ELSE							; Else we're a BMU
				; Process incoming status for BMU. Stress in R9, complete status in R8.
				mov.b	R8,&globalStatus		; Put it where can be read by '255sp' (or modbus equiv)
				bit.b	#bNotSendStatus,&monFlags
				_IF		Z 						; If sending status, and so expecting to receive it
					call	#ScuTxByte				; Send status byte to the SCU. Wait buffer not full
				_ENDIF

				; If all considered full (and no comms error), reset the coulomb counter
				_COND							; Start short-circuit conditional
					bit		#COM_ERR,R8				; Test the comms error bit
				_AND_IF	Z						; If no comms error
					mov		R8,R10					; Make a copy of the status byte in R10
					and		#S_TYPE,R10				; Extract the stress type bits
					cmp		#ALL_FULL,R10
				_AND_IF	EQ						; And If all cells are considered full
					; Set the discharge counter to a DoD of 0.
					mov		#0,&discharge		; Lo word
					mov		#0,&discharge+2		; Hi word
					call	#UpdateSoC			; Update the pre-computed PWM counter advance value
				_ENDIFS ; All Considered Full and no comms error

				call	#ControlContactors		; Control PIP charging, and shut down if all else fails
			_ENDIF							; End else BMU
		_ENDIF							; End if no comms error
		ret
; End of DoStatus


ControlContactors:
;
; Status byte is in R8. Use it to control contactors
;
		push 	R9
		push	R10

		; Check if the stress type can be ignored, based on the direction of the current.
		; But if the source contactors are off, treat it as if we are charging, and so ignore only
		; undervoltage stress.
		mov		R8,R9					; Take a copy of the status byte in R9
		_COND							; Begin a short-circuit conditional
			cmp		#10,&current			; Check the current, which is in tenths of an amp
		_OR_ELSE	GE						; If there's 1 amp or more of charge current (positive)
			bit.b	#AcLfPvCtor,&CtorPortOUT ; Check the state of the source contactors
		_OR_IFS	Z						; Or if the AC and left PV source contactors are off
			and		#S_TYPE,R9				; Isolate the two stress-type bits
			cmp		#UV_AF,R9				; Check if type of stress is ignore-on-charge
		_ELSE							; Else not charging
			cmp		#-9,&current			; Check the current, which is in tenths of an amp
			_IF		L						; If 1 amp or more of discharge current (negative)
				and		#OV_UT,R9				; Isolate the single overvolt/undertemp stress-type bit
				cmp		#OV_UT,R9				; Check if type of stress is ignore-on-discharge
			_ELSE							; Else current between -1 amp and 1 amp
				clrz							; Ensure stress will not be ignored, by clearing EQ flag
			_ENDIF							; Endif 1 amp discharge
		_ENDIF							; Endif >= 1 amp charge or source contactors off

		; Treat ignorable stress as 6 and comms error as 15, for contactor control (will be smoothed)
		_IF		EQ						; If we can ignore this stress
			mov		#6,R9					; Treat it as stress 6 (< neutral) for contactor control
		_ELSE							; Else can't ignore
			mov		R8,R9
			and		#STRESS,R9				; Get stress into R9
		_ENDIF							; Endif ignore stress
		bit		#COM_ERR,R8
		_IF		NZ						; If the comms error bit is set
			mov		#15,R9					; Treat it as stress 15 for contactor control
		_ENDIF								;   (it will be smoothed)

		; Calculate smoothed stress for controlling contactors and charge voltages
		rla2	R9						; Quadruple the incoming stress
		mov.b	&smoothStressX4,R10		; Get the previous smoothed stress times 4 into R10
		add		R10,R9
		add		R10,R9
		add		R10,R9					; R9 = 4*incoming + 3*4*previous
		incd	R9						; Add 2 for rounding
		rra2	R9						; Divide by 4 to get new smoothed stress times 4
		mov.b	R9,&smoothStressX4		; Save it for next time
		inc		R9						; Add 1 for rounding (don't add 2 or it won't descend fully)
		rra2	R9						; Divide by 4 to get smoothed stress

		cmp.b	#15,R9					; If smoothed stress is extreme
		_IF		GE
			inc.b	&shutdownTimer
			cmp.b	#ShutdownTime,&shutdownTimer
			_IF		HS						; And enough time has passed
				bic.b	#(BatPosCtor|BatNegCtor|AcLfPvCtor|RtPvCtor),CtorPortOUT	; Drop out all battery
																		; contactors, and we die
				; We need an endless loop here in case the BMU doesn't lose power.
				; It may still be powered up by the inverter capacitors, or some charge source.
				; This will require the red button to be pushed to remove power from the BMU
				; to reset it. After which, releasing the red may be sufficient to restart,
				; or you may also have to push the green.
				br		#Halt			; Also check for BSL password
			_ENDIF
		_ELSE							; Else
			clr.b	&shutdownTimer			; Clear the shutdown timer
		_ENDIF							; Endif

		; If (not UV && charging && stress >= 12 && bDonePipInit) || (array voltage >= 145 V)
		;	turn off charging/source contactors
		mov		R8,R10					; Make a copy of the status byte in R10
		and		#S_TYPE,R10				; Extract the two stress-type bits
		_COND							; Begin short circuit conditional
			cmp		#UV_AF,R10				; Check for UV = UV_AF and not OV_UT
		_AND_IF	NE						; If the stress is not due to UnderVoltage
			bit.b	#bCharging,&monFlags
		_AND_IF	NZ						; And if we're charging
			cmp.b	#MinContStress,R9
		_AND_IF	GE						; And if incoming stress is alarming
			bit.b	#bDonePipInit,&monFlags
		_AND_IF	NZ						; And if we haven't just started up (CMU breaks look like stress)
			bic.b	#RtPvCtor|AcLfPvCtor,&CtorPortOUT ; Drop out the source contactors (grn, white LEDs)
		_ELSES							; Else
			push	R8
			push	R9
			call	#GetArrayV				; Get the PV array voltage
			pop		R9
			pop		R8
			cmp		#145*10,R10
			_IF		HS						; If PV array voltage is greater or equal to 145 volts
				bic.b	#RtPvCtor|AcLfPvCtor,&CtorPortOUT ; Drop out the source contactors
			_ENDIF
		_ENDIF

		; If stress <= 6 && array voltage < 140 V
		;	turn on charging/source contactors
		; We need to let it go down to stress 6 so that balancing can occur.
		_COND							; Begin short circuit conditional
			cmp.b	#7,R9
		_AND_IF	L						; And if incoming stress is < 7
			push	R8
			call	#GetCellV
			pop		R8
			cmp		#140*10,R10
		_AND_IF	LO						; And if PV array voltage is less than 140 volts
			; The following test is required to avoid waiting 700 ms every time around the main loop
			; and thereby slowing communications between BMU ports to a crawl.
			; The 140 ms delay before turning the first one back on, was found necessary to avoid
			; overloading the 12 V DC-DC converter and shutting down the whole system, in the case where
			; these contactors had only just been turned off.
			_COND								; Begin short-circuit conditional
				bit.b	#AcLfPvCtor,&CtorPortOUT
			_OR_ELSE	Z						; If the AC and left PV source contactors are off
				bit.b	#RtPvCtor,&CtorPortOUT
			_OR_IFS		Z						; Or the right PV source contactors are off
				mov		#140,R8						; 140 milliseconds
				call	#DelayMs					; Wait in case they have only just been turned off
				bis.b	#AcLfPvCtor,&CtorPortOUT	; Turn on the AC and left PV source contactors
				mov		#560,R8						; 560 milliseconds
				call	#DelayMs					; Wait for last economiser to reduce coil current
				bis.b	#RtPvCtor,&CtorPortOUT		; Turn on the right PV source contactors
			_ENDIF
		_ENDIFS

#if 1
		bit.b	#bCharging,&monFlags	; Set by sign of current in 'i' command
		_IF		NZ						; If we've been told to start charging
			ClearWatchdog
			inc.b	&chargerTxTimer			; Increment charger transmit timer
			mov.b	&chargerTxTimer,R9		; Get charger transmit timer
			and.b	#3,R9
			_IF		Z						; Every fourth tick (every 2 seconds)
				bit		#COM_ERR,R8
				_IF		NZ						; If the comms error bit is set
					and		#STRESS,R8
					cmp		#8,R8					; Treat it as a minimum of stress 8 for chg control
					_IF		LO
						mov		#8,R8
					_ENDIF
				_ELSE
					; If stress is due to undervoltage, treat it as stress 0 for charging purposes
					mov		R8,R9					; Make a copy of the status byte in R9
					and		#S_TYPE,R9				; Extract the stress type bits
					cmp		#UV_AF,R9
					_IF		EQ						; If stress type is UnderVoltage
						clr		R8						; Treat as a stress of zero for charging
					_ELSE							; Else
						and		#STRESS,R8				; Use the given stress value (0-15)
					_ENDIF
				_ENDIF
#if 0			// Untested code
				;call	#ChgController			; Call charger controller with R8 as input
				call	#PiController			; Call PI charger controller with R8 as input
				call	#SendChargerPackets		; Send packets to charger to set voltage
#endif
			_ENDIF ; Every fourth tick
		_ENDIF ; bCharging
#endif
		pop		R10
		pop		R9
		ret
; End of ControlContactors


DoPrecharge:
		; This code is designed to work with a number of different battery contactor
		; arrangements.
		; t0 thru t4 indicate the time order of switching during precharge.
		; P22 thru P26 are the numbers of the BMU connectors that drive the contactor coils.
		; The connector numbers increase as you go away from the BMU's 12 V input connector.
		; These BMU connectors are named respectively PRE BAT CHG DIS NRM in the software and schematic.
		;
		; This is the contactor arrangement for monoliths
		; (apart from #1 at Helidon which is handled by the rev61 branch)
		;           + ___ -
		; Bat+ --+----o o------------------+-- Load +
		;        | t3 BAT+ P23             |
		;        |    ___          ___     |
		;        +----o o---------|___|----+
		;          t2 PRE P22    3R3 100W
		;
		;           + ___ -        ___
		; Bat- -------o o---------|___|------- Load -
		;          t0 BAT- P24  500A 50mV shunt
		;
		;           + ___ -
		;        -----o o------     AC In contactor, left PV+ and delayed left PV- contactors
		;          t4 ACLPV P25
		;
		;           + ___ -
		;        -----o o------     Right PV+ and delayed right PV- contactors
		;          t1 RPV P26
		;
 mov	#200,R8
 call	#DelayMs	; Give power supply time to stabilise before first big load
		; We stagger the turn-on of the contactors so that the DC-DC converter can cope.
		bis.b	#BatNegCtor,&CtorPortOUT 	; Turn on the battery negative contactor
		mov		#160,R8						; 160 milliseconds (to allow for GX14 or EV200)
		call	#DelayMs					; Wait for economiser to reduce coil current

		; We may have come here after a bootstrap-load, with all contactors (except precharge) still on.
		; We should only turn on the precharge contactor if the positive contactor isn't already on,
		; because otherwise it may put too much load on the power supply and shut down the Monolith.
		bit.b	#BatPosCtor,&CtorPortOUT	; Check the positive contactor
		_IF		Z							; If the positive contactor is off
			bis.b	#PreCtor,&CtorPortOUT		; Turn on the Precharge contactor
		_ENDIF
		mov		#3*1000/100,R12				; 3 seconds = 30 x 100 ms timeout
		_REPEAT
			mov		#100,R8						; 100 milliseconds; placed at start
			call	#DelayMs					;	of loop to allow ADC system to settle after reset
			call	#GetCapV					; Trashes R8, R9, R11 result in R10
			push	R10							; Save capacitor voltage measurement
			call	#GetBatV					; Trashes R8, R9, R11 result in R10
			pop		R8							; Restore cap voltage to R8
			sub		R8,R10						; R10 = BatV - CapV
			abs		R10							; R10 = Abs(BatV - CapV), allow for CapV > BatV
			cmp		#6*10,R10
			_WHILE	HS							; Wait for less than 6 V across contactor
				dec		R12
		_UNTIL	Z
				mov		#1,Rtos						; Fall thru to here on timeout
				call	#ErrorLed					; We who are about to die beep at you
				bic.b	#PreCtor,&CtorPortOUT		; Turn off the Precharge contactor to save resistor
				bic.b	#BatNegCtor,&CtorPortOUT 	; Turn off the battery negative contactor
				br		#Halt						; Endless loop, but check for BSL password
			_ELSE									; Come here from WHILE, when less than 6 V
				; We stagger the turn-on of the contactors so that the DC-DC converter can cope.
				bis.b	#BatPosCtor,&CtorPortOUT	; Turn on the battery positive contactor
				mov		#160,R8						; 160 milliseconds
				call	#DelayMs					; Wait for economiser to reduce coil current
				bic.b	#PreCtor,&CtorPortOUT		; Turn off the Precharge contactor to save power
				mov		#160,R8						; 160 milliseconds
				call	#DelayMs					; Wait for pre-charge to come off
				; Each source contactor output drives multiple contactors some of which have
				; delay circuit boards preceding them. Their delay is 160 to 400 ms.
				; So we must wait the worst case plus another 160 ms. Total 560 ms.
				bis.b	#AcLfPvCtor,&CtorPortOUT	; Turn on the AC and left PV source contactors
				mov		#560,R8						; 560 milliseconds
				call	#DelayMs					; Wait for last economiser to reduce coil current
				bis.b	#RtPvCtor,&CtorPortOUT		; Turn on the right PV source contactors
				mov		#560,R8						; 560 milliseconds
				call	#DelayMs					; Wait for last economiser to reduce coil current
			_ENDIF
		ret

#if 0
PiController:
;
; A PI voltage controller whose input and output are in R8
; Input range is 0 to 15 (stress levels). Setpoint is 7.
; Output range is chargerVoltMin to chargerVoltMax (tenths of a volt).
;
#define Rerror R10			// Error register
#define Rderiv R9			// Derivative register
#define Routput R8			// Output register
			mov		#7,Rerror				; error = setpoint - measurement
			sub		R8,Rerror
			mov		Rerror,Rderiv			; deriv = error - prev_error
			sub		&piPrevError,Rderiv

			mov		&piPrevOutput,Routput	; output = prev_output + Kp * deriv + Ki * error
			; Insert rla Rderiv here to change Kp
			rla3	Rderiv					; Kp = 4
			add		Rderiv,Routput
			mov		Rerror,R9				; Overwrites unused Rderiv
			; Insert rla R9 here to change Ki
			add		R9,Routput				; Ki = 1

			mov		&chargerVoltMin,R9
			rla2	R9						; The combination of this rla2, the rla2 below,
											; and the rra2 at the end, have the effect of dividing
											; bit Kp and Ki by 4. So they are effectively 1 and 1/4.
			cmp		R9,Routput				; Clamp output between chargerVoltMin and chargerVoltMax
			_IF		L
				mov		R9,Routput
			_ELSE
				mov		&chargerVoltMax,R9
				rla2	R9						; For effective reduction of Kp and Ki
				cmp		R9,Routput
				_IF		GE
					mov		R9,Routput
				_ENDIF
			_ENDIF

			mov		Rerror,&piPrevError		; prev_error = error
			mov		Routput,&piPrevOutput	; prev_output = output
			rra2	Routput					; For effective reduction of Kp and Ki
			ret
; End of PiController
#endif

#if 1
PiController:
;
; A PI curent controller whose input and output are in R8
; Input range is 0 to 15 (stress levels). Setpoint is 7.
; Output range is 0 to #chargerCurrMax (whole amps).
;
#define Rerror R10			// Error register
#define Rderiv R9			// Derivative register
#define Routput R8			// Output register
			mov		#7,Rerror				; error = setpoint - measurement
			sub		R8,Rerror
			mov		Rerror,Rderiv			; deriv = error - prev_error
			sub		&piPrevError,Rderiv

			mov		&piPrevOutput,Routput	; output = prev_output + Kp * deriv + Ki * error
			; Insert rla Rderiv here to change Kp
			rla3	Rderiv					; Kp = 4
			add		Rderiv,Routput
			mov		Rerror,R9				; Overwrites unused Rderiv
			; Insert rla R9 here to change Ki
			add		R9,Routput				; Ki = 1

			mov		#0,R9					; Minimum output current. Keep like the voltage version
			rla2	R9						; The combination of this rla2, the rla2 below,
											; and the rra2 at the end, have the effect of dividing
											; bit Kp and Ki by 4. So they are effectively 1 and 1/4.
			cmp		R9,Routput				; Clamp output between chargerVoltMin and chargerVoltMax
			_IF		L
				mov		R9,Routput
			_ELSE
				mov		#chargerCurrMax,R9
				rla2	R9						; For effective reduction of Kp and Ki
				cmp		R9,Routput
				_IF		GE
					mov		R9,Routput
				_ENDIF
			_ENDIF

			mov		Rerror,&piPrevError		; prev_error = error
			mov		Routput,&piPrevOutput	; prev_output = output
			rra2	Routput					; For effective reduction of Kp and Ki
			ret
; End of PiController
#endif


ChgController:
;
; A simple stress controller. R8 has smoothed stress, zero if due to undervoltage.
; Output stored in prevBulk and prevFloat variables.
;

			clr.b	&lastChgChanged				; Will set later only if bulk or float voltages change
			cmp		#11,R8
			_IF	GE								; If the stress high enough to act
				cmp		#CHG_BULK_MIN,&prevBulk
				_IF		GE							; If the bulk voltage isn't at minimum yet
					dec		&prevBulk					; then decrease the bulk voltage by 0.1 V
					mov.b	#1,&lastChgChanged			; Remember this change
				_ENDIF
				cmp		#CHG_FLT_MIN,&prevFloat		; Same for float voltage
				_IF		GE
					dec		&prevFloat
					mov.b	#1,&lastChgChanged
				_ENDIF
			_ELSE
				; We can't send changes to increase the bulk or float voltages very quickly, because
				; if we're solar charging, every increase will reset the SCC and charge current will
				; go to zero and slowly ramp back
				_COND
					mov.b	&chargerTxTimer,R9
					and		#$7F,R9					; Look at lower 7 bits
				_AND_IF	Z						; Will be zero every 128 ticks
												;	= every 32 seconds
					cmp		#7+1,R8				; If all cells are calm
				_AND_IF		L
					cmp		#CHG_BULK_STD,&prevBulk	; If we have not yet reached the standard bulk voltage
					_IF		L
						inc		&prevBulk				; then slowly work back towards the std voltage
						mov.b	#1,&lastChgChanged
					_ENDIF
					cmp		#CHG_FLT_STD,&prevFloat		; Same for float voltage
					_IF		L
						inc		&prevFloat
						mov.b	#1,&lastChgChanged
					_ENDIF
				_ENDIFS
			_ENDIF
			ret

#if 0			// This is the version that goes with the PI voltage controller
SendChargerPackets:
;
; Send charger float and bulk command packets (in the right order)
; with voltage from R8 (in tenths of a volt)
;
; Trashes R8 thru R11
;
; Send PBFTvv.v<crc16><cr> and PCVVww.w<crc16><cr>
;	where vv.v is the Float voltage and ww.w is the Bulk voltage.
; When raising the voltage, bulk will have to be sent before float,
; and when lowering it, float will have to be sent before bulk.
PipCmdDelay	EQU		950					; Delay in ms between PIP commands, so next one not NAKed

			;
			; Although we have waited long enough to send the last 9600 bps character completely, it is
			; possible that this 9600 bps character has triggered a 2400 bps byte, possibly right near
			; the end of the last 9600 bps character. This may interfere with the carriage return we
			; want to send to flush the 9600 bps "junk" from the PIP's buffers.
			; So a delay of one 2400 bps character time (4 ms) should be enough time to guarantee that
			; any 9600 bps junk has passed.
			push	R8
			mov		#4,R8
			call	#DelayMs
			mov		#$0D,R8				; Send a carriage return to the PIP to flush preceding
			call	#TxByte				; 2400 baud junk caused by 9600 baud commands sent to CMUs.
			mov		#PipCmdDelay,R8		; Delay between commands so next one not NAKed
			call	#DelayMs
			pop		R8

			; Compare new requested voltage with previously sent bulk and float voltages
			; to determine whether to send the new voltage as Float or Bulk.
			; This algorithm is optimised for bringing possibly-distressing voltages _down_ as soon
			; as possible, at the expense of small delays in charging due to possibly not putting
			; them up as soon as possible. The PIP gives no way of telling when it is in float mode.
			_COND
				cmp		&prevFloat,R8
			_AND_IF		EQ
				cmp		&prevBulk,R8
			_AND_IF		EQ
				tst		&lastWasFloat
				_IF		NZ
					mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
					mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
					mov		#BulkCmd,R10		; Send a Bulk voltage packet
					call	#SendPipPacket		; Trashes R8 thru R11
				_ELSE
					mov		R8,&prevFloat		; Record float voltage setpoint for next time
					mov		#-1,&lastWasFloat	; Record that the last sent was a Float
					mov		#FloatCmd,R10		; Send a Float voltage packet
					call	#SendPipPacket		; Trashes R8 thru R11
				_ENDIF
			_ELSES
				_COND
					cmp		&prevFloat,R8
				_OR_ELSE	LO
					cmp		R8,&prevBulk
				_OR_IFS		LO
					tst		&lastWasFloat
					_IF		NZ
						cmp		&prevFloat,R8
						_IF		LO
							mov		&prevFloat,R8
						_ENDIF
						mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
						mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
						mov		#BulkCmd,R10		; Send a Bulk voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ELSE
						cmp		R8,&prevBulk
						_IF		LO
							mov		&prevBulk,R8
						_ENDIF
						mov		R8,&prevFloat		; Record float voltage setpoint for next time
						mov		#-1,&lastWasFloat	; Record that the last sent was a Float
						mov		#FloatCmd,R10		; Send a Float voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ENDIF
				_ELSE
					cmp		&prevBulk,R8
					_IF		EQ					; If equal to previous bulk voltage
						mov		R8,&prevFloat		; Record float voltage setpoint for next time
						mov		#-1,&lastWasFloat	; Record that the last sent was a Float
						mov		#FloatCmd,R10		; Send a Float voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ELSE						; Else
						mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
						mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
						mov		#BulkCmd,R10		; Send a Bulk voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ENDIF						; End sending Float or Bulk voltage
				_ENDIF
			_ENDIF

			mov		#PipCmdDelay,R8		; Delay between commands so next one not NAKed
			call	#DelayMs

			ret
; End of SendChargerPackets

SendChargerPackets:
			tst.b	&lastChgChanged
			_IF		NZ					; Only if the last bulk or float value changed
				push	&TxBytePtr			; Save the present Tx pointer
				mov		#ChgTxByte,&TxBytePtr ; Point the Tx pointer at the charge ports
				mov		#BulkCmd,R10		; Send a bulk voltage packet
				mov		&prevBulk,R8
				call	#SendPipPacket		; Trashes R8 thru R11
				mov		#500,R8
				call	#DelayMs			; Allow time for this to be processed and Ack'd
				mov		#FloatCmd,R10		; Send a float voltage packet
				mov		&prevFloat,R8
				call	#SendPipPacket		; Trashes R8 thru R11
				pop		&TxBytePtr
			_ENDIF
			ret

FloatCmd	DB			4, 'PBFT'		; First byte is length of following string
BulkCmd		DB			4, 'PCVV'		; 48.0 to 58.4 V
			ALIGN		1


; Needed by the PI voltage controller
SendPipPacket:
;
; Send a PIP command packet`
; with command string pointed to by R10
; and voltage in R8 (in tenths of a volt)
;
; Trashes R8 thru R11
;
			; Send the PIP command
			push		R8					; Save the voltage (in tenths of a volt) on the stack

			call		#TxStringCrc		; Send string pointed to by R10. Trashes R8 thru R11

			ClearWatchdog

			mov			#0,R10
			pop			R9					; Pop voltage to R9
			mov			#100,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov			R9,R8
			add			#'0',R8
			call		#TxByteCrc			; Send the tens digit of voltage (trashes R8 thru R10)

			mov			R10,R9
			mov			#0,R10
			mov			#10,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov.b		R9,R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the units digit of voltage (trashes R8 thru R10)

			mov.b		#'.',R8
			call		#TxByteCrc			; Send the decimal point (trashes R8 thru R10)

			ClearWatchdog

			mov.b		R10,R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the tenths digit of voltage (trashes R8 thru R10)

			call		#TxCrc				; Send the two bytes of CRC and clear it
			mov.b		#$0D,R8
			call		#TxByte				; Send the carriage return without accumulating CRC

			ClearWatchdog

			ret


#endif

#if 1			// This is the version that goes with the PI current controller
SendChargerPackets:
;
; Send charger dynamic MNCHGC command packets
; with current from R8 (in whole amps)
;
; Trashes R8 thru R11
;
; Send PBFTvv.v<crc16><cr> and PCVVww.w<crc16><cr>
;	where vv.v is the Float voltage and ww.w is the Bulk voltage.
; Send PBFT0ccc<crc16><cr> where ccc is the desired current plus 500

			mov			#MunchCmd,R10		; Send a MNCHGC current packet
			; Send the PIP command
			push		R8					; Save the current (in whole amps) on the stack
			call		#TxStringCrc		; Send string pointed to by R10. Trashes R8 thru R11

			ClearWatchdog

			mov			#0,R10
			pop			R9					; Pop current to R9
			add			#500, R9			; Add 500 to make it dynamic
			mov			#100,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov			R9,R8
			add			#'0',R8
			push		R10					; Save remainder
			call		#TxByteCrc			; Send the hundreds digit of argument (trashes R8 thru R10)

			pop			R9					; Remainder to R9
			mov			#0,R10
			mov			#10,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov.b		R9,R8
			add.b		#'0',R8
			push		R10					; Save remainder
			call		#TxByteCrc			; Send the tens digit of argument (trashes R8 thru R10)

			ClearWatchdog

			pop			R8					; Remainder to R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the units digit of argument (trashes R8 thru R10)

			call		#TxCrc				; Send the two bytes of CRC and clear it
			mov.b		#$0D,R8
			call		#TxByte				; Send the carriage return without accumulating CRC

			ClearWatchdog

			ret

MunchCmd	db			7, 'MNCHGC0'		; Always send to the master for now

; End of SendChargerPackets
#endif


;
; Update the SoC meter's advance value (so the SoC meter will reflect a change made to the discharge
; counter)
; Preserves R8 and R9, trashes R10, clears R11
;
UpdateSoC:
MinAdvance	EQU			20					; To avoid timer compare wraparound
			push		R8
			push		R9
			; Though we use DoD here, the PWM interrupt routine inverts the output so it represents SoC
			call		#DepthOfDischarge	; Get DoD as value 0-1000 (0 to 100.0%)
			cmp			#MinAdvance,R9		; Compare with minimum value
			_IF			LO					; If lower,
				mov			#MinAdvance,R9		; Enforce minimum value to avoid timer compare wrap
			_ENDIF
			cmp			#1000-MinAdvance,R9	; Compare with maximum value
			_IF			HS					; If higher or same,
				mov			#1000-MinAdvance,R9	; Enforce maximum value to avoid timer compare wrap
			_ENDIF
			mov			R9,&socPwmAdv		; Save in the pre-computed advance variable
			pop			R9
			pop			R8
			ret


; Some calculations so we can see how much space we have left, by reading the listing.
freespace	EQU		_CMDCHRTBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/(_CMDCHRTBL-PROG_START))

;---------------------------------------------------------------------------------
; Interrupt and entry-point jump table at the end of the third-last main-flash segment
;---------------------------------------------------------------------------------
				ORG		BSL2_START-$22	; FBDE for now
CMDCHRTBLEND	EQU		$				; Command character table ends immediately below lowest
										;  main-program entry point
jInterpretByte	br		#InterpretByte	; A branch to InterpretByte, independent of PROG_START

jUCA0TxIsr		br		#TxIsr			; UART transmit
jUCA0RxIsr		br		#RxIsr			; UART receive

jTA1TxRxIsr		br		#ChgTxRxIsr		; Combined TA1 CCR1 & CCR2
										; (BMU only: Chg transmit & receive capture/compare)
jTA1MeasureIsr	br		#MeasureBmuIsr	; Timer A1 CCR0
										; (BMU only: Measurement compare)
jInterpretInit	br		#InterpretInit	; A branch to InterpretInit, independent of PROG_START

jTA0TxRxIsr		br		#ScuTxRxIsr		; Combined TA0 CCR1 & CCR2
										; (BMU only: SCU transmit & receive capture/compare)
										; (CMU only: Measurement compare)
jTA0FllIsr		reti					; Timer A0 CCR0 (frequency locked loop capture).
				nop						;   This is handled directly by the BSL.
				ORG		BSL2_START-2	; FBFE for now
ProgPresence	DB		$AA				; For BSL2 to check before calling main program (InterpretByte)
ProgChecksum	DB		$FF				; Placeholder for checksum added by LyteFlash or SendProg

;---------------------------------------------------------------------------------
; Bootstrap loader, in the last two main-flash segments
;---------------------------------------------------------------------------------
				ORG		BSL2_START		; Start of second-last main-flash segment
; Include the Bootstrap loader
#include "../common/BSL2.s43"			// Include bootstrap-loader and interrupt vectors
				ORG		$FFFE			; The reset vector
				DW		jBSL			; Reset to BSL main entry in case there is a crash

				_CS_CHECK				; Check that the control-flow stack is balanced
				END
