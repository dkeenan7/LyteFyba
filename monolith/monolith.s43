			COL		154			; Wide listings
; 14/Dec/2014: split off from monitor.s43

; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve calibration data.
;
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Output options to:
;  Allow C-SPY-specific extra output file
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	monolith.bin
;	Output format: raw-binary
;
; This software has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for solar power systems.
;
; "Monolith" is the standard solar power system operating software for our Cell Management Unit (CMU)
; and Battery Management Unit (BMU) based on an MSP430 microcontroller.
;
; Aspirational register-use policy:
; R8 thru R12 should be caller save (callee trashable)

;-------------------------------------------------------------------------------------------------------
; Commonly changed conditional assembly -- defaults are for Eddie
#define		CONFIG			OFF_GRID 	// Options: OFF_GRID (default), ON_GRID_SMALL, ON_GRID_LARGE
#define		QUIET			0			// 0 (default), 1 for BMU to tell CMUs not to beep
#define 	LOW_LOW_CUTOFF	0			// 0 (default) for 2.935 V (5% SoC), 1 for 2.8 V (2% SoC)
#define		chargerCurrMax	80			// 80 (default) or 60 A charger limit, depends on PIP-4048 model
;-------------------------------------------------------------------------------------------------------

#define MONOLITH				// For some conditional assembly in otherwise common code.
								// Changes StatusFreq from 16 Hz to 2 Hz.
								// Enables SoC meter PWM.
								// Causes ID 255 (instead of ID 0) to respond to fuel gauge commands
								// 'f' (SoC) and 'g' (DoD).

ShutdownTime	EQU		15*StatusFreq	; Shut down after approx 15 seconds of stress 15.

			LSTOUT-
#include "msp430.h"							// MSP430 Special Function Register definitions
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Assembler macros for obscure instruction sequences
#include "../common/common.h"				// Definitions common to monitor, TestICal and BSL
			LSTOUT+

; Some definitions so the IntMeasure.s43 code will work
; TestICal defines these as their RAM counterparts instead of info-flash
CellCal 	EQU	infoCellCal
CellOff		EQU infoCellOff
BoltPlCal 	EQU	infoBoltPlCal
BoltPlOff	EQU infoBoltPlOff
BoltMiCal	EQU	infoBoltMiCal
BoltMiOff	EQU	infoBoltMiOff
TempSlope	EQU	infoTempSlope
TempOff		EQU	infoTempOff
AdcTimIdx	EQU	infoAdcTimIdx
BypFull		EQU	infoBypFull


			NAME	main			; Module name
			PUBLIC	main			; Make the "main" label visible for IAR debugger

ProductCode	EQU		'L'				; T for TestICal, R for monitoR, L for monoLith, W for Wmonolith

ID			EQU		infoID			; We use the info-flash copy of the ID for s, x, prettyPrint
									; commands. TestICal uses the ram copy

; Conditional assembly
#define		WATCHDOG	1			// True if watchdog timer is to be used (only turn off for debugging
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer.
									// Buffered ADC is mainly useful for debugging.

; Constants

; For stress calculations
; Stress 7 is the set point for control loops.
; Stress 8 is the lowest dis-stress. Alarm is given at stress 12.
; Source or load contactors drop out at 12 if enabled.
; Battery contactor drops out at 15.
; High volt values and bypass and full thresholds assume defaults
; They can be changed by 'Th' commands
/*
Str- High Low  High Low  Link
ess  volt volt temp temp volt
     (mV) (mV) (°C) (°C) (mV)
-----------------------------------
 0
     3170 3425  35   22    0
 1
     3210 3390  37   20    8
 2
     3250 3355  39   18   16
 3
     3290 3320  41   16   24
 4
     3330 3285  43   14   32
 5
     3370 3250  45   12   40
 6
     3410 3215  47   10   48
 7 bypass - setpoint for control loops
     3450 3180  49    8   56
 8 full - warning
     3490 3145  51    6   64
 9
     3530 3110  53    4   72
10
     3570 3075  55    2   80
11
     3610 3040  57    0   88
12 alarm - disconnect if it persists for more than a few seconds
     3650 3005  59   -2   96
13
     3690 2970  61   -4  104
14
     3730 2935  63   -6  112
15 shutdown - immediate disconnect
*/

#define WHINGE 0
#if !WHINGE
// OV = Over Voltage: One stress unit for each 40 mV in excess of 3.130 V, to a max of 15 at >= 3.730 V
// OV setpoint is 3.410 to 3.450 V. Bypass at 3.410. Alarm at 3.610. Drop out source contactors at 3.610
// Drop out battery cont at 3.730 V.
OV_ZERO		EQU		3130		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		40			; mV difference between one OV stress level and the next
; These were an attempt to float at the 75% step
;// OV = Over Voltage: One stress unit for each 3 mV in excess of 3.332 V, to a max of 15 at >= 3.377 V
;// OV setpoint is 3.353 to 3.356 V. Alarm at 3.365 V. Drop out source contactors at 3.368 V.
;OV_ZERO		EQU		3332		; Threshold in mV between OV stress levels -1 and 0
;OV_STEP		EQU		3			; mV difference between one OV stress level and the next
#if LOW_LOW_CUTOFF			// 2.8 V cutoff for Greg -- about 2% SoC
// UV = Under Voltage: One stress unit for each 40 mV below 3.40 V, to a maximum of 15 at <= 2.80 V
// UV setpoint is 3.080 to 3.120 V (around 5% SoC). Alarm at 2.92 V. Drop out bat contactor at 2.80.
UV_ZERO		EQU		3400		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-40			; mV difference between one UV stress level and the next
#else 						// 2.935 V cutoff for the rest of us -- about 3% SoC
// Adjusted after learning with Matt James, of the low plateau between 3.18 V and 3.17 V, 14% and 8% SoC
// Made it so low plateau is stress 8, and equal OV and UV stress (4) at about 75% SoC.
// UV = Under Voltage: One stress unit for each 35 mV below 3.460 V, to a maximum of 15 at <= 2.935 V
// UV setpoint is 3.180 to 3.215 V (15% SoC). Alarm at 3.040 V (5% SoC). Drop out bat contactor at 2.935
UV_ZERO		EQU		3460		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-35			; mV difference between one UV stress level and the next
#endif
// OT = Over Temperature: One stress unit for every 2 degrees C above 33C, to a max of 15 at >= 63 degC
// OT setpoint is 47 to 49 degC. Alarm at 55 degC. Dropout bat contactors at 63 degC.
OT_ZERO		EQU		33			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		2			; Degrees C difference between one OT stress level and the next
BypTempQuota EQU	15			; Degrees C subtracted when bypassing in past 5 minutes
// UT = Under Temperature: One stress unit for every 2 degree C below 24C, to a max of 15 at <= -6 degC
// UT setpoint is 10 to 8 degC. Alarm at 0 degC. Bat contactor dropout at -6 degC.
UT_ZERO		EQU		24			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-2			; Degrees C difference between one UT stress level and the next
// AL = Absolute "Link" voltage. Now max of absolute positive and negative bolt voltages.
// One stress unit for every 8 mV above 0 mV, to a max of 15 at >= 120 mV
// AL setpoint is 56 to 64 mV. Alarm at 88 mV.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		8			; mV difference between one AL stress level and the next

#else
// OV = Over Voltage: One stress unit for each 10 mV in excess of 3.500 V, to a max of 15 at >= 3.65 V
// OV setpoint is 3.57 to 3.58 V. Alarm at 3.61 V.
OV_ZERO		EQU		3285		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		5			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 40 mV below 2.500 V, to a maximum of 15 at <= 1.90 V
// UV setpoint is 2.18 to 2.22 V. Alarm at 2.06 V.
UV_ZERO		EQU		3200		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-50			; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 40C, to a max of 15 at >= 55degC
// OT setpoint is 47 to 48 degC. Alarm at 51 degC.
OT_ZERO		EQU		40			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		1			; Degrees C difference between one OT stress level and the next
BypTempQuota EQU	15			; Degrees C subtracted when bypassing in past 5 minutes
// UT = Under Temperature: One stress unit for every 1 degree C below 11C, to a max of 15 at <= -4degC
// UT setpoint is 4 to 3 degC. Alarm at 0degC.
UT_ZERO		EQU		11			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-1			; Degrees C difference between one UT stress level and the next
// AL = Absolute "Link" voltage. Now max of absolute positive and negative bolt voltages.
// One stress unit for every 4 mV above 0 mV, to a max of 15 at >= 60 mV
// AL setpoint is 28 to 32 mV. Alarm at 44 mV.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		4			; mV difference between one AL stress level and the next
#endif


ComErrTicks	EQU		9			; Minimum ticks without receiving valid status byte before
								;	taking on master duties and reporting comms error (if ID not 1)
ZeroCurrentTicks EQU 9			; Minimum ticks without receiving an 'i' (current) command before
								;	assuming current is zero (if ID not 255)

; Status byte bit masks - Used for localStatus in RAM as well as RXed and TXed status bytes
COM_ERR		EQU		1<<6			; Communications error
UV_AF		EQU		1<<5			; Stress type is UnderVoltage (ignore on charge) when bit 4 is clear
									;	or cells are All considered Full when bit 4 is set
OV_UT		EQU		1<<4			; Stress type is OverVoltage or UnderTemp (ignore on discharge)
ALL_FULL	EQU		1<<4 | 1<<5		; When both type bits are set it means All considered Full
									;   (reset to 0% DoD) as well as OverVoltage (ignore on discharge)
									; When both type bits are clear it means OverTemp (never ignore)
S_TYPE		EQU		$30				; Stress type field mask. Bits 4-5
STRESS		EQU		$0F				; Stress level field mask. Bits 0-3

;
; RAM allocation
;
				ORG		$200		; Start of RAM. Ends at InitSP-1
; This area is common to all main programs and used by the BSL and is not block erased on a reset
bsl2state		DS		2			; Password recogniser state for BSL2
resetCounter	DS		2			; Number of resets since the last "^" command
resetBuffer		DS		16			; Circular buffer recording the reason for the last 16 resets
discharge		DS		4			; Accumulator for depth of discharge determination.
									; Unit is 1/10 A for 1/2 s = 1/20 coulomb = 1/72 milliamphour.
									; So 32 bits allows 60,000 Ah, but 24 bits would only allow 233 Ah.

oldFllTime		DS		2			; Used by Frequency Locked Loop. NOTE: do not put this after
									;	comNoEraseEnd, as it will affect the first FLL interrupt
measureCount	DS		2			; Incremented by FLL interrupt routine, on ACLK rising edge, 4096 Hz
oldMeasureCount DS		2			; Value of measureCount at the last measure
oldRtcMeasCnt	DS		2			; Hi 4 bits of measureCount at the last advance of RTC seconds count

; Command Character Interpreter flags
interpFlags		DS		1			; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1<<0		; Should numeric output be in hexadecimal, not decimal?
bErrorChecking	EQU		1<<1		; Are we sending CRC12s and checking received CRC12s?
bDontInterpret	EQU		1<<2		; Are we interpreting?
bDontEcho		EQU		1<<3		; Are we echoing at the character level?
bModbusOutput	EQU		1<<4		; Should PrettyPrint output be formatted as a Modbus/ASCII response?
bEchoResponses	EQU		1<<5		; True to echo complete Modbus responses
bQuiet			EQU		1<<6		; True to silence piezo

; Overvoltage-related thresholds (set by 'Th' command)
				ALIGNRAM 1
ovZero			DS		2			; Overvoltage zero, set by 'VTh command (param1 - 7 * param2)
ovStep			DS		1			; Overvoltage step, set by 'VTh command (param2)
alarmStress		DS		1			; Stress level for red LED and beeper and BMU dropping contactors
bypassVoltage	DS		2			; Bypass voltage threshold, set by 'bTh
fullVoltage		DS		2			; Full voltage threshold, set by 'fTh

ALIGNRAM 1
comNoEraseEnd	; End of unerased variables; start of erased variables

#if	ADCBUF
				ALIGNRAM 1
sampleBuf		DS		2*NumSamples ; ADC sample buffer; 4 or 16 samples
#endif

monFlags		DS		1			; Monitor flags, bitmask definitions follow
bNotSendStatus	EQU		1<<0		; Zero if sending status bytes at all
bNotMeasureTime EQU		1<<1		; Zero if time to measure
bCharging		EQU		1<<2		; 1 if charging or regen. See 'c' command.
bChargerControl	EQU		1<<3		; 1 in charger control mode (masterless operation). See 'o' command.
bBadInsulation	EQU		1<<4		; 1 if the last insulation test failed. (BMU only)
bDonePipInit	EQU		1<<5		; 1 if have done PIP initialisation

masterFlags		DS		1			; Master (command injector) flags; bitmask definitions follow
bBlocked		EQU		1<<0		; 1 if blocked.
bSendZ			EQU		1<<1		; 1 if Z command is due to be sent
bSendi			EQU		1<<2		; 1 if 'i' (current) command is due
bSendInit		EQU		1<<3		; 1 if CMU initialisation string should be sent
bTimeout		EQU		1<<4		; 1 if unblocked via timeout; may or may not have to send a CR to
									;	clear a stalled command if we have something to inject (may not
									;	be ready now, hence we need this separate bit)
masterUnblockTicks DS	1			; When the master is blocked, this field indicates what the tick
									; counter will read when the timeout expires
localStatus		DS		1			; Bits 0-3 stress, 4 ignore-on-dis, 5 ignore-on-chg, 6 comms error
globalStatus	DS		1			; BMU only. For SCUs that don't accept status bytes but use 'p' cmd
ticksSinceLastRx DS		1			; Ticks since last valid status received
ticksSinceLastI DS		1			; Ticks since last 'i' (current) command received
ticks			DS		1			; To time various medium frequency tasks. Allowed to wrap
passWordState	DS		1			; State machine for password recogniser

; Charger controller variables

shutdownTimer	DS		1			; To allow time for charging to start, when restarting
									;   after a low voltage shutdown.
				ALIGNRAM 1
pipInitPtr		DS		2			; Pointer to next PIP init string to send, or zero (NULL) if none
chargerVoltMin	DS		2			; Charger voltage minimum (tenths of a volt). Set by 'o' command.
chargerVoltMax	DS		2			; Charger voltage maximum (tenths of a volt). Set by 'o' command.
piPrevOutput	DS		2			; State of PI controller
piPrevError		DS		2			; State of PI controller
prevBulk		DS		2			; Previous Bulk/Absorb voltage (tenths of a volt) sent to PIP.
prevFloat		DS		2			; Previous Float voltage (tenths of a volt) sent to PIP.
;lastWasFloat	DS		2			; True (nonzero) if last voltage command sent to PIP was for float.
pipInitCtr		DS		1			; Counts ticks till the PIP is ready to receive commands
PipWait			EQU		3*StatusFreq ; Number of the above that will be required (3 seconds)
pipCmdCtr		DS		1			; Counts ticks till it's time to send the next init str
PipCmdWait		EQU		2*StatusFreq ; Number of the above that will be required (2 seconds)
AllFullDod		EQU		0			; DoD in tenths of a percent, to reset discharge counter to when all considered full
;AllFullDod		EQU		250			; DoD in tenths of a percent, to reset discharge counter to when all considered full
;ChargerVoltMin	EQU		530			; Lower limit of PI controller output. In tenths of a volt.
;ChargerVoltMax	EQU		570			; Upper limit of PI controller output. In tenths of a volt.
;ChargerVoltMin	EQU		526			; Lower limit of PI controller output. In tenths of a volt.
;ChargerVoltMax	EQU		546			; Upper limit of PI controller output. In tenths of a volt.
CHG_BULK_MIN	EQU		538			; 53.8 Lower limit for bulk charge voltage
CHG_BULK_STD	EQU		552			; 55.2 Set and maximum value for bulk charger voltage
CHG_FLT_MIN		EQU		512			; 51.2 Lower limit for float charge voltage
CHG_FLT_STD		EQU		538			; 53.8 Set and maximum value for float charger voltage

ocCellVolt		DS		2			; IR-compensated cell voltage
ocCellVoltX256	DS		4			; Filtered IR-compensated cell voltage, shifted left 8 bits
restedCounter	DS		2			; Count of measurements since the battery qualified as "rested"
current			DS		2			; Current most recently reported by BMU, in tenths of an amp (signed)
cellTemperature	DS		1			; Cell temp degC (signed). For Rint calc. Not updated when bypassing
cmuTemperature	DS		1			; CMU temp degC (signed). For ADC Vref temperature compensation
smoothStressX4	DS		1			; Low pass filtered stress used by BMU to control contactors
lastChgChanged	DS		1			; True (non zero) if lastBulk or lastFloat changed
chargerTxTimer	DS		1			; To keep charger packet transmission to the minimum required.

; Serial-io variables
	; Cell monitoring units comms variables
	; Note that the CMU variables have no prefix while the others have "scu" and "chg".
				ALIGNRAM 1
txCksum			DS		2			; CRC12 for data transmitted to CMUs/BMU or SCU
txCrc			DS		2			; CRC16 for data transmitted to PIP inverter
txBitTime		DS		2			; Determines transmit baud rate for timer-based comms (not UART).
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
txData			DS		2			; Byte to transmit in lower byte; always $FF in high byte
rxData			DS		1			; Received char
bitCntTx		DS		1			; Bit count 10 -> 1
bitCntRx		DS		1			; Bit count 8 -> 1

RxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
TxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
rxBuf			DS		RxSz		; Receive queue buffer
rxWr			DS		1			; Receive queue write index
rxRd			DS		1			; Receive queue read index
txBuf			DS		TxSz		; Transmit queue buffer
txWr			DS		1			; Transmit queue write index
txRd			DS		1			; Transmit queue read index

	; System control unit comms variables
				ALIGNRAM 1
scuBitTime		DS		2			; Determines bit rate.
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
scuTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
scuRxData		DS		1			; Received char
scuBitCntTx		DS		1			; Bit count 10 -> 1
scuBitCntRx		DS		1			; Bit count 8 -> 1

ScuRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
ScuTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256

				ALIGNRAM 1
scuRxBuf		DS		ScuRxSz		; Receive queue buffer
scuRxWr			DS		1			; Receive queue write index
scuRxRd			DS		1			; Receive queue read index
scuTxBuf		DS		ScuTxSz		; Transmit queue buffer
scuTxWr			DS		1			; Transmit queue write index
scuTxRd			DS		1			; Transmit queue read index

	; Charger/inverter comms variables
				ALIGNRAM 1
chgBitTime		DS		2			; Determines bit rate.
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
chgTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
chgRxData		DS		1			; Received char
chgBitCntTx		DS		1			; Bit count 10 -> 1
chgBitCntRx		DS		1			; Bit count 8 -> 1

ChgRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
ChgTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256

				ALIGNRAM 1
chgRxBuf		DS		ChgRxSz		; Receive queue buffer
chgRxWr			DS		1			; Receive queue write index
chgRxRd			DS		1			; Receive queue read index
chgTxBuf		DS		ChgTxSz		; Transmit queue buffer
chgTxWr			DS		1			; Transmit queue write index
chgTxRd			DS		1			; Transmit queue read index

				ALIGNRAM 1
rxCksum			DS		2			; CRC12 for data received from CMUs/BMU or SCU
prevRxCksum		DS		2			; Previous CRC12
priorRxCksum	DS		2			; Previous previous CRC12
errorRatio		DS		4			; Error ratio

				ALIGNRAM 1
ticksSinceLastBypass DS	2			; Ticks since last bypass
beenBypassing	DS		1			; True if we've bypassed in last 5 minutes. Used by OT stress calc

; The following variables are for interrupt driven measurement code
				ALIGNRAM 1
sampIndex   	DS  	1    		; Cycles from 0 to 15
chanIndex   	DS  	1    		; Cycles from 0 to 3
chanList    	DS  	2*4    		; Initialised to channel selections and timing, for ADC10CTL1
partialSum  	DS  	2
rawMeasures							; Raw measurement results (sum of 16 measurements)
boltVPlRaw		DS  	2
boltVMiRaw		DS  	2
cellVRaw		DS  	2
temperatureRaw	DS  	2

				ALIGNRAM 1
eraseEnd							; End of the erased variables

; A kind of trip-meter for this cell's stress
worstStress		DS		1			; Worst local stress since the last resetWorstStress command
worstStressType	DS		1			; Type of measurement that caused worst stress
worstOV			DS		2			; Worst over-voltage since the last resetWorstStress command
worstUV			DS		2			; Worst under-voltage since the last resetWorstStress command
worstOT			DS		2			; Worst over-temperature since the last resetWorstStress command
worstUT			DS		2			; Worst under-temperature since the last resetWorstStress command
worstAL			DS		2			; Worst absolute link voltage since the last resetWorstStress command
; The 5 variables above are also treated as an array indexed from worstStress, so order matters

; Command Character Interpreter variables
				ALIGNRAM 1
ToIN			DS		2			; Pointer to present character being stored in Text Input Buffer
TIB				DS		48			; Text Input Buffer (packet buffer)
TIBEnd

TxBytePtr		DS		2			; Pointer to TxByte handler. Initially CmuTxByte, except for BMUs
									;	which initialise it to ScuTxByte
socPwmAdv		DS		2			; Amount to add to TACCTL2 for next compare value for SoC meter

; "Real time clock"
rtcDay			DS		1			; Day of week 0 = Sunday, 6 = Saturday
rtcHour			DS		1			; Hour (0=midnight, 12 = noon, 23 = 11 pm)
rtcMin			DS		1			; Minute (0-59)
rtcSec			DS		1			; Second (0-59)

; Must leave room for stack (about 36 bytes minimum)
STACKSPACE		EQU		InitSP-$	; Look at listing to see what this is

;-------------------------------------------------------------------------------
				ORG		PROG_START	; In main-flash
;-------------------------------------------------------------------------------

#include "../common/CmdCharInterpreter.s43" // RPN interpreter with one-or-two-character commands
#include "../common/InterruptComms.s43" // Comms routines
#include "../common/ComComms.s43"	// Common comms functions, e.g. TxCksum
#include "IntMeasure.s43"			// Interrupt driven ADC measurement functions
#include "../common/math.s43"		// Multiply and divide routines
#include "../common/Crc12.s43"		// Twoth CRC12 calculation routines
#include "crc.s43"					// PIP CRC16 calculation routines
#include "monoDefinitions.s43"		// Command character definitions
#include "master.s43"				// Master function for injecting commands

;-------------------------------------------------------------------------------
; InterpretInit
;-------------------------------------------------------------------------------

InterpretInit:                              ; This is called by the BSL, on reset.
InterpretByte:								; Should not be called -- but just in case
main:										; For IAR Embedded Workbench IDE debugger
			dint							; Disable interrupts while initialising various things that
											;	will use interrupts. Note that this will temporarily
											;	stop the FLL.
			ClearWatchdog					; Clear and enable Watchdog Timer 32k cyc. BSL sets 64 cyc.
			mov.w	#InitSP,SP				; Initialize stackpointer, likely not necessary

			; Clear all variables in RAM except resetBuffer and BMU's fuel-gauge discharge accumulator
			; and worstStress (and ToIN/TIB)
			; In other words: erase from comNoEraseEnd up to but not including eraseEnd
			_FOR		#eraseEnd-comNoEraseEnd,R8
				clr		comNoEraseEnd-2(R8)
			_NEXT_DECD	R8

			; Don't initialise system clock registers. BSL2 and the FLL have set them.

			cmp.b	#255,&ID					; Is this a BMU?
			_IF		EQ
				mov		#ScuTxByte,&TxBytePtr		; By default, TxByte goes to the SCU port for a BMU
			_ELSE
				mov		#CmuTxByte,&TxBytePtr		; In other cases, particularly CMUs, TxByte goes to
													;	the CMU port
			_ENDIF

;
;	Initialise io ports
;
			; Port 1 already set up by BSL.

			; Initialise port 2
			mov.b	#0,&P2OUT					; Set all outputs low.
			bis.b	#ErrLed,&P2DIR 				; Set ErrLed as output
			bis.b	#TxMiChg_57k6B|TxMiChg2_RlyP_57k6A,&ChgPortDIR ; Set Txs as outputs
												; Do not disturb bits 6, 7 (XIN, XOUT)
			bis.b	#RxChg|TxMiChg_57k6B,&ChgPortSEL	; Select timer functions for Rx and Tx pins
												; Do not disturb bits 6, 7 (XIN, XOUT)
			cmp.b	#255,&ID
			_IF		NE							; If we're not a BMU
				bis.b	#Bypass,&BypPortDIR 		; Set Bypass as output
			_ENDIF

			; Initialise port 3. CMUs don't use this port, but no harm in setting it up.
			; Don't change the state or direction of any BMU contactor outputs or you might cut off
			; power to the BMU.
			cmp.b	#255,&ID
			_IF		NE						; If we're a CMU
				mov.b	#$FF,&P3REN				; Enable pullup/pulldown resistors to save power, for
												;   any pin which may remain a floating input in a CMU.
			_ENDIF
			; Don't change the state of contactor outputs (or SoC) unless this is a power-on reset
			; or you might cut off your own power.
			mov		&resetCounter,R8
			dec		R8
			and		#$0F,R8
			mov.b	resetBuffer(R8),R8
			bit.b	#PORIFG,R8				; Check for power-on reset
			_IF		NZ						; If it was a power-on
				mov.b	#0,&P3OUT				; Turn off all contactors
				; SoC initialisation
				clr		&discharge				; Initialise the SoC to 100%
				clr		&discharge+2			; BMU will retrieve SoC from CMU 1
				call	#UpdateSoC				; Initialise the pre-computed counter advance value
				; Threshold initialisation
				mov		#OV_ZERO,&ovZero			; -1/0 overvoltage stress threshold in mV
				mov.b	#OV_STEP,&ovStep			; Spacing of overvoltage stress levels in mV
				mov.b	#12,&alarmStress			; Stress for red LED, beeper and BMU contctr dropout
				mov		#OV_ZERO+7*OV_STEP,&bypassVoltage	; mV to turn on bypass resistor
				mov		#OV_ZERO+8*OV_STEP,&fullVoltage		; mV to signal "FULL" and reset SoC to 100%
			_ENDIF
			; Set contactor outputs as outputs in case they aren't already.
			mov.b	#PreCtor|BatPosCtor|BatNegCtor|AcLfPvCtor|RtPvCtor,&P3DIR
			bic.b	#TxMiScu,&ScuPortOUT		; Set Tx low
			bis.b	#TxMiScu,&ScuPortDIR		; Set Tx as output
			bis.b	#RxScu|TxMiScu,&ScuPortSEL	; Select timer functions for Rx and Tx pins

;
;	Initialise timer and interrupt comms
;
			; Don't initialise the UART. Everything is already set up from BSL, except for interrupts.
			; But we don't want to enable TX ints before anything is in the circular buffer.
			bis.b		#UCA0RXIE, &IE2			; Enable UART receive interrupts

			; Initialise the Timers
			cmp.b	#255,&ID					; If we're a BMU
			_IF		EQ
				; TA0CTL is set up correctly by the BSL as it is used for the Frequency Locked Loop.
				; Initialise timer TA1
				; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
				; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
				; MC: 2 = continuous mode 1 = up mode
				; TAIE = interrupt enable (for timer overflow)
				mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2, &TA1CTL

				; Initialise TA0 CCRs
				mov.w	#OUTMOD_5, &ScuCCTLt		; Initialise SCU transmit capture/compare register
				mov.w	#BitTime96,&scuBitTime		; Set the SCU bit time for 9600 baud
				mov.b	#$FF,&scuTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
				mov.b	#8,&scuBitCntRx				; Load Rx bit Counter, 8 data bits
				mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ScuCCTLr	; Falling edge, Input A, Sync, Capture

				; Initialise TA1 CCRs
				mov.w	#OUTMOD_5, &ChgCCTLt		; Initialise charger transmit capture/compare register
				mov.w	#BitTime24,&chgBitTime		; Set the charger bit time for 2400 baud
				mov.b	#$FF,&chgTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
				mov.b	#8,&chgBitCntRx				; Load Rx bit Counter, 8 data bits
				mov		#InitialCrc12,&txCksum		; Initialise transmit CRC12.
				mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ChgCCTLr	; Falling edge, Input A, Sync, Capture

				mov.w	#CCIE, &MeasCCTL			; Enable measurement interrupts on a BMU (TA1CCTL0)
			_ELSE									;  in compare mode.
				mov.w	#CCIE, &ScuCCTLr			; Enable measurement interrupts on a CMU (TA0CCTL2)
			_ENDIF									;  in compare mode.

			; Already cleared by loop above
;			clr.b	&rxWr						; Initialise the Tx and Rx queue indexes
;			clr.b	&rxRd
;			clr.b	&txWr
;			clr.b	&txRd

;
; Initialise the charger controller
;
			; Already cleared by loop above
;			clr.b	&shutdownTimer				; Initialise shutdown timer
;			clr.b	&chargerTxTimer				; Initialise charger transmit timer
			cmp.b	#255,&ID					; If we're a BMU
			_IF		EQ
;				mov.w	#ChargerVoltMin,&chargerVoltMin ; Initialise charger voltage min
;				mov.w	#ChargerVoltMax,&chargerVoltMax ; Initialise charger voltage max
				bis.b	#bChargerControl,&monFlags	; Set by o command
				bis.b	#bCharging,&monFlags		; Set by c command
			_ENDIF
;			clr.w	&piPrevOutput				; Initialise PI controller state
;			clr.w	&piPrevError				;
;			clr.w	&chargerPrevCurr			; Initialise charger current

			mov.w	#CHG_BULK_STD,&prevBulk
			mov.w	#CHG_FLT_STD,&prevFloat

;
; Initialise the ADC10
;
			; Disconnect digital buffers from analog inputs. Enable ADC function of P1.4 (Vref+ out).
			; BMU TouchVChan is not currently used
			mov.b	#(1<<CellVChan)|(1<<BoltVMiChan)|(1<<BoltVPlChan)|(1<<4),&ADC10AE0
			; Initialise ADC10CTL0
			; SREF_1	= +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temp)
			; REFOUT	= connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			; ADC10ON	= power on the measurement system (now on all the time)
			mov		#SREF_1|ADC10SHT_3|REFOUT+REFON|ADC10ON,&ADC10CTL0
			; We precalculate the values for ADC10CTL1, to save time in the frequently-called
			; interrupt routine.
            ; We need the above maximum sample time of 64 cycles to get the 38 us we need to achieve
			; 12 bit accuracy with the 155 kR impedance of our voltage dividers.
			; ADC adds 2 kR and sampling capacitor is 27 pF.
            ; Temperature measurement also requires 30 us just to get half-degree accuracy.
            ; So ADC clock frequency should not be much greater than 64/38 us = 1.67 MHz.
            ; Datasheet gives 3.7-6.3 MHz range for ADC10OSC but this seems to be reduced to
            ; something like 3.4-5.9 MHz due to Vcc being 2.5 V instead of 3.0 V.
			; For the LSB of each chanList element, see the comments for AdcTimingTbl below.
			mov.b	&AdcTimIdx,R9				; Get the ADC timing index from info-flash
			rra4	R9							; MS nibble is for Monolith. LS nibble is for TestICal
			cmp		#NumAdcClocks+1,R9			; Test the ADC timing index
			_IF		HS							; If not in the range 0 to NumAdcClocks
				clr		R9							; Then use default timing (index = 0)
			_ENDIF
			mov.b	AdcTimingTbl(R9),R9			; Get byte value from table
			mov.b	R9, chanList+0				; Store it for each conversion channel
			mov.b	R9, chanList+2
			mov.b	R9, chanList+4
			mov.b	R9, chanList+6

; MSB of each chanList element must contain the channel number in the INCHx position
			; and have SHSx, ADC10DF and ISSH all set to zero.
			; INCHx		= channel number to convert
			; SHS_0		= enable software starting via the ADC10SC bit
			; &~ADC10DF	= straight binary output, not twos complement.
			; &~ISSH	= the sample input signal is not inverted
			mov.b	#BoltVPlChan<<4,&chanList+1+0
			mov.b	#BoltVMiChan<<4,&chanList+1+2
			mov.b	#CellVChan<<4,	&chanList+1+4
			mov.b	#TempChan<<4,	&chanList+1+6

			mov		&chanList+0, &ADC10CTL1		; Ready for the first conversions
;
; Initialise the command character interpreter
;
			mov		#InitialCrc12,&rxCksum	; Initialise received packet CRC12
			cmp.b	#255,&ID					; If we're not a BMU
			_IF		NE
				mov.b	#bErrorChecking,&interpFlags ; Default error checking on
			_ELSE
				mov.b	#bErrorChecking | bDontEcho | bEchoResponses,&interpFlags ; Don't want to echo
													; command packets, do want to see responses
			_ENDIF
;			bic.b	#bHexOutput,&interpFlags	; Default numeric output to be in decimal, not hexadecimal
;			bic.b	#bDontInterpret,&interpFlags ; Do interpret
;			bic.b	#bDontEcho,&interpFlags	; Do echo
			mov		#TIB,&ToIN				; Initialise write pointer into text input buffer
;
; Miscellaneous initialisation
;
			mov.b	#4,&passWordState		; Waiting for first byte of bootstrap loader password
			mov		#(3300*256)&$FFFF,&ocCellVoltX256	; Initialise the low pass filter for the
			mov		#(3300*256)>>16,&ocCellVoltX256+2	;	average cell voltage to 3300 mV
			mov		#PipInitTbl,&pipInitPtr	; Point to the first init string

			eint							; Enable interrupts now that all initialisation is complete

; Do precharge and get the main contactor on, so we stay powered up
; even when the human lets go of the green button.
			cmp.b	#255,&ID
			_IF		EQ							; If we're a BMU
				call	#DoPrecharge
			_ENDIF

; If we're a BMU, ensure CMUs are using and expecting CRC12s, and sending status bytes,
; then retrieve the high word of the discharge accumulator from CMU 1
; This is now done in Master, using the bSendInit masterFlag.
			cmp.b	#255,&ID
			_IF		EQ
				bis.b	#bSendInit,&masterFlags
			_ENDIF

; Main loop
			_REPEAT
				; If we're a BMU (ID = 255) handle SCU and Charger communication.
				cmp.b	#255,&ID				; Check my ID
				_IF		EQ						; If I'm a BMU
					; Check for a character from the SCU Rx port, and send it to the CMU Tx port.
					; Also pass it to the "Master" function, so it knows when it is safe for it to
					; inject commands such as Z, G and i as required.
					call	#ScuRxByteNW			; Try to read a character from the SCU
					_IF		NZ						; If there was one
						tst.b	R8						; Check if the high bit is set
						_IF		NN						; If the high bit is not set (not a status byte)
							call	#CmuTxByte				; Send it to the CMUs. Preserves R8
							call	#DoPassword				; Check for BSL password bytes from SCU port
						_ENDIF
					_ELSE							; Else there was no character
						clr		R8						; Indicate to Master that no char is avail
					_ENDIF
					call	#Master					; Call the "Master" function, char or not

					; Check for a character from the Chg Rx port, and send it to the SCU Tx port.
					call	#ChgRxByteNW			; Try to read a character from the charger (PIP)
					_IF		NZ						; If there was one
						bic.b	#$80,R8					; Clear hi bit so doesn't look like status byte
						call	#ScuTxByte				; Send it to the SCU
					_ENDIF
				_ENDIF

				; Check for a command or status character from the CMU port
				; For both CMUs and the BMU, read from CMU Rx
				call	#RxByteNoWait			; Check if received CMU data
				_IF		NZ
					tst.b	R8
					_IF		NN						; If an ordinary (non status) char
						call	#DoEcho					; Echo the command or password byte if required
						; Check for a BSL password
						cmp.b	#255,&ID				; Check ID
						_IF		NE						; If I'm not a BMU
							call	#DoPassword				; Check for BSL password bytes from CMU port
						_ENDIF
						call	#ACCEPT					; Process command bytes (could be slow)
					_ELSE							; Else was status byte
						call	#DoStatus				; Forward possibly-updated status bytes
					_ENDIF
				_ELSE
					call	#UpdateRtc					; Update "real time clock" if needed

					; Check if time to measure. The FLL interrupt (happens 4096 times per second) is
					;	incrementing &measureCount. We want to know if this count has advanced by
					;	4096/StatusFreq or more since the last measure (when &measureCount was saved as
					;	&oldMeasureCount)
					mov		&oldMeasureCount,R8
					add		#(4096/StatusFreq),R8		; Where it will be at measure time (minimum)
					sub		&measureCount,R8			; Subtract where it is now
					_IF		NN							; If this is nonnegative, it is not time to measure
				;		mov.w	#WDTPW+WDTHOLD,&WDTCTL		; Stop Watchdog Timer before sleeping CPU
				;		bis		#CPUOFF+GIE,SR				; Turn off CPU and ensure interrupts still enabled
					_ELSE								; Else time to measure
						add		#(4096/StatusFreq),&oldMeasureCount ; Set the count for the next measure
						call	#DoMeasurement			; May transmit status
					_ENDIF
				_ENDIF

			ClearWatchdog				; Clear and restart Watchdog Timer each time around main loop

			_FOREVER
; End of main loop


;
; Call this repeatedly to initialise the PIP4048MS inverter with various non-default settings
;
InitPip:
			mov		&pipInitPtr,R10		; Point to the current initialisation string
			call	#ChgTxString		; Send one command
			mov		R10,&pipInitPtr		; Update the pointer
			tst.b	0(R10)				; Check the next length byte
			_IF		Z					; If it's zero, this is the end of the table
				clr		&pipInitPtr				; For tidiness
				bis.b	#bDonePipInit,&monFlags	; Tell DoMeasurement and ControlContactors that we're done
			_ENDIF
			ret


#define		OFF_GRID 		1
#define		ON_GRID_SMALL	2
#define		ON_GRID_LARGE	3

; PIP 4048MS inverter/charger initialisation strings. First byte is length.
; CRCs are precomputed using http://www.lammertbies.nl/comm/info/crc-calculation.html
; CRC-CCITT (XModem), except $0D, $0A and $28 bytes in the CRC must be incremented. See crc.s43.
PipInitTbl 	DB	1,$0D						; First send a CR in case PIP has already received junk.
											; This will cause an initial NAK.
#if	CONFIG == OFF_GRID
		 	DB	8,'POP00',$C2,$48,$0D		; Utility priority (default) (for off-grid use) (Param 1)
;		 	DB	8,'POP01',$D2,$69,$0D		; Solar priority (Param 1)
#else
			DB	8,'POP02',$E2,$0B,$0D		; "SBU" (Solar, Bat, Util) priority (for on-grid use) (Param 1)
#endif
			DB	6,'PDa',$E3,$41,$0D			; Disable beeper (Param 18)
			DB	6,'PDk',$42,$0B,$0D			; Disable return to default screen (Param 19)
;			DB	6,'PEj',$61,$1B,$0D			; Enable load-sense (Param 4)
			DB	6,'PEu',$82,$C5,$0D			; Enable OL-restart (Param 6)
			DB	6,'PEv',$B2,$A6,$0D			; Enable OT-restart (Param 7)
			DB	6,'PDy',$70,$78,$0D			; Disable beeps when primary charge source interrupted (Param 22)
			DB	6,'PEz',$73,$2A,$0D			; Enable fault info recording; access with QFS
			DB	8,'PBT02',$07,$4C,$0D		; Battery type "User" (Param 5)
;			DB	8,'PGR01',$39,$CA,$0D		; AC input range "UPS" (170 to 280 Vac) Doesn't work with genset (Param 3)
;			DB	11,'PSDV52.0',$65,$A4,$0D	; Battery low cutoff voltage 52.0 V (3.25 Vpc)
;			DB	11,'PSDV51.6',$5C,$32,$0D	; Battery low cutoff voltage 51.6 V (3.225 Vpc)
;			DB	11,'PSDV51.2',$1C,$B6,$0D	; Battery low cutoff voltage 51.2 V (3.20 Vpc)
			DB	11,'PSDV50.8',$8A,$CC,$0D	; Battery low cutoff voltage 50.8 V (3.175 Vpc) (Param 29)
;			DB	11,'PSDV48.0',$D4,$D1,$0D	; Battery low cutoff voltage 48.0 V (3.00 Vpc)
			DB	11,'PBCV51.0',$7B,$AF,$0D	; Start charging from util (if avail) when bat falls to 51 V (Param 12)
#if CONFIG == OFF_GRID
			DB	11,'PBDV00.0',$38,$9B,$0D	; Stop charging from utility when "FUL", i.e. float achieved (Param 13)
											; The $9B above acts as an ESC for TeraTerm so don't be
											; fooled by the fact that you don't see the next 3 commands.
#else
;			DB	11,'PBDV52.0',$EA,$BE,$0D	; Stop charging from utility when bat rises to 52 V (Param 13)
			DB	11,'PBDV53.0',$DD,$8E,$0D	; Stop charging from utility when bat rises to 53 V (Param 13)
#endif
			DB	11,'PCVV55.2',$66,$C9,$0D	; Set bulk/absorb voltage to 55.2 V (3.45 Vpc) (Param 26)
;			DB	11,'PBFT53.8',$93,$45,$0D	; Set float voltage to 53.8 V (3.3625 Vpc)
			DB	11,'PBFT53.7',$62,$AA,$0D	; Set float voltage to 53.7 V (3.35625 Vpc) (Param 27)
#if CONFIG != ON_GRID_LARGE
			DB	13,'MNCHGC0100',$16,$3A,$0D	; Maximum charge current 100 amps (utility plus solar) (Param 2)
#else
			DB	13,'MNCHGC0120',$70,$58,$0D	; Maximum charge current 120 amps (if battery >= 200 Ah; Param 2)
#endif
;			DB	12,'MUCHGC020',$F3,$F1,$0D	; Maximum utility charge current 20 amps (Param 11)
			DB	12,'MUCHGC030',$C0,$C0,$0D	; Maximum utility charge current 30 amps
;			DB	12,'MUCHGC040',$59,$57,$0D	; Maximum utility charge current 40 amps
			DB	0							; Zero length at end of table
			ALIGN		1



DoMeasurement:
;
; Regular measurement. Called StatusFreq times per second (2-16 times per second, see InterruptComms.s43)
;
#define Rstrs R12				// Worst stress (present, not trip)
#define Rmeas R14				// Measurement causing worst stress
#define Rtype R15				// Type of measurement causing worst stress

			inc.b	&ticks					; Used to time various infrequent tasks. Allowed to wrap.
			bit.b	#bDonePipInit,&monFlags	; Check if we've already done PIP initialisation
			_IF		Z
				cmp.b	#PipWait, &pipInitCtr
				_IF		NE
					inc.b	&pipInitCtr				; Wait till the PIP is ready to receive commands
				_ELSE
					mov		#$7FFF,&errorRatio		; Reset errorRatio so we don't count startup junk
					mov		#$0000,&errorRatio+2
					cmp.b	#255,&ID				; Check ID
					_IF		EQ						; If we're a BMU
						cmp.b	#PipCmdWait, &pipCmdCtr
						_IF		NE
							inc.b	&pipCmdCtr			; Wait the delay before each init string
						_ELSE
							clr.b	&pipCmdCtr
							call	#InitPip			; Send the next PIP initialisation string
						_ENDIF
					_ELSE							; Else we're a CMU
						bis.b	#bDonePipInit,&monFlags	; Tell DoMeasurement we're done
					_ENDIF
				_ENDIF
			_ENDIF

			clr		Rstrs					; Init present stress to zero
			clr		Rmeas					; Init measurement causing zero stress to zero
			clr		Rtype					; Init type of measurement causing zero stress to zero

			inc.b	&ticksSinceLastRx		; Cleared whenever valid stress byte received
			_IF		C						; If unsigned overflow
				mov.b	#$FF,&ticksSinceLastRx	; Saturate at $FF
			_ENDIF
			inc.b	&ticksSinceLastI		; Cleared whenever an 'i' (current) command is received
			_IF		C						; If unsigned overflow
				mov.b	#$FF,&ticksSinceLastI	; Saturate at $FF
			_ENDIF

			cmp.b	#255,&ID				; Check ID
			_IF		NE						; If we're not a BMU
				cmp.b	#ZeroCurrentTicks,&ticksSinceLastI ; Check ticks since last 'i' command
				_IF		HS 					; if too many ticks since last 'i' (current) command
					mov		#0,&current				; Assume current is zero
				_ENDIF
			_ENDIF

			; Do cell voltage measurement
			call	#GetCellV				; Get cell voltage in mV in R10
			cmp.b	#255,&ID				; Check ID
			_IF		EQ						; If we're a BMU
				; Multiply by 100/16 to bring the total battery voltage in tenths of a volt to
				;	average cell millivolts. This is to let us use the same IR compensating code that
				;	the CMUs already use.
				; Use shifts and adds to multiply by 25, then divide by 4 at the end. 25 = 16+8+1
				mov		R10,R8					; R8 = 1x
				rla3	R8						; R8 = 8x
				add		R8,R10					; R10 = 9x
				rla		R8						; R8 = 16x
				add		R8,R10					; R10 = 25x
				mov		R10,R8					; Copy to R8
				rra2	R10						; R10 = 6.25x
				and		#2,R8					; Check if rounding needed
				_IF		NZ
					inc		R10						; Round up
				_ENDIF
			_ENDIF
			; Estimate OCV by subtracting current times internal resistance from measured voltage.
			; Shunt must be wired so charge current is positive and discharge current is negative.
			push	R10						; Save the cell voltage measurement

			; We have a 16x16=32-bit multiply, and we want to scale the current and resistance
			; so the high 16 bits of the result is the voltage in millivolts, while ensuring
			; that the scaled current and resistance do not overflow unsigned 16 bits.
			; We will scale current by <<3 to 1/80ths of an amp, so overflow is at 819.2 A.

			; Get the scaled cell internal resistance into R8.
			; Given that we want the result to be in 1/65536ths of a millivolt, we need to scale
			; resistance to 1/(65536/80) = 1/819.2ths of a milliohm
			; HiTempCellRes is in micro-ohms.
			mov		&infoCellRes,R10		; Treating as high word effectively multiplies by 2^16
			clr		R9
			rra3_l	R10,R9					; Divide by 2^3, so overall multiplied by 2^13 = 8192
			add		#5000,R9				; Add half the divisor for rounding
			adc		R10
			mov		#10000,R8
			call	#UMSlashMod				; Divide by 10000. Result in R9
			; Now in 1/819.2ths of a milliohm, so overflow at 80 mR.
			; Max resistance setting is is 19.999 mR. Less if we expect to go below -8 degC.

			; Adjust the internal resistance for temperature using a function that requires
			; only shifts and adds, that Dave fitted to the graph on page 17 of Languang Lu, 2011.
			; https://forums.aeva.asn.au/download/file.php?id=1410
			; The cell resistance at a given temperature is estimated as
			; CellResistance = CellRes25Deg/7.76 * [1 + 1.046875^(67-T)] where T is the cell temperature

			; Divide the 25 degC cell resistance by 7.76
			; It doesn't matter that the LS 3 bits of the resistance are not used.
			; It can't be measured that accurately anyway.
			mov		R9,R8					; Make a copy in R8
			rra3	R9						; Divide by 8
			adc		R9						; Rounding
			swpb_b_R 8						; Divide by 256
			rra		R8						; Divide by 2
			adc		R8						; Rounding
			add		R8,R9					; Add

			; For every degree we are below 67 degC, multiply resistance by 1.046875 = 1+3/64
			push 	R9						; Save a copy of the fixed part of the resistance
			mov.b	#67-1,R11				; R11 is loop counter, init 67 degC
			_DO
				cmp.b	&cellTemperature,R11	; cellTemperature is not updated when bypassing
			_WHILE	GE						; While loop counter >= temperature
				mov		R9,R8					; Multiply resistance by 1.046875 = 1+3/64
				clrc							; Unsigned divide by 2
				rrc		R8						; No rounding required for the first one
				mov		R8,R10					; Save this value
				rra		R8						; Divide by 2 again
				adc		R8						; Rounding required for this one
				add		R10,R8					; Add to obtain 3/4ths
				rra4	R8						; Divide by 16 to obtain 3/64ths
				adc		R8						; Rounding required for this one
				add		R8,R9					; Add to original to obtain 1+3/64 times
				dec.b	R11						; Decrement loop counter by 1 degC
			_ENDW
			pop		R8						; Restore the fixed part of the resistance to R8
			add		R9,R8					; Add the temperature-dependent part to the fixed part in R8

			; Get the scaled absolute value of the current into R9
			mov		&current,R9				; Current is in tenths of an amp
			abs		R9
			rla3	R9						; Now in 1/80ths of an amp, so overflow is at 819.2 A

			; Multiply cell resistance and current, and subtract from measured cell voltage
			ClearWatchdog
			call	#UMStar					; R10:R9 = R8 * R9, resistance * current, clears R11
			mov		R10,R9					; Use only the high word of the result, put into R9
			pop		R10						; Restore the cell voltage measurement to R10
			tst		&current
			_IF		NN						; If current is not negative (i.e. if charging)
				sub		R9,R10					; OCV is lower than measured, when charging
			_ELSE							; Else discharging
				add		R9,R10					; OCV is higher than measured, when discharging
			_ENDIF							; Endif
			mov		R10,&ocCellVolt			; Store it so it can be reported by the 'W' command.

            ; Calculate the smoothed IR-compensated cell voltage (average if BMU)
            ; Use (255/256) * old + (1/256) * new
            ; = (old << 8 - old + new) >> 8
            ; Label ocCellVoltX256 as 0HML (Zero High Middle Low bytes)
            mov		&ocCellVoltX256  ,R8; Get lower word ML
            mov		&ocCellVoltX256+2,R9; Get upper word 0H
            rra8_l	R9,R8				; Shift right 8 bits with tricky macro
            sub		R8,&ocCellVoltX256	; Ram -= old
            sbc		&ocCellVoltX256+2
            add		R10,&ocCellVoltX256 ; Ram += new
            adc		&ocCellVoltX256+2

            cmp.b	#255,&ID				; If a BMU
			_IF		EQ
				; Check for low rested average cell voltage and update of SoC
				; First check if battery current is "rested"
				_COND
					cmp		#20,&current		; No more than 2.0 A
				_AND_IF	L
					mov		&infoCapacity,R8
					add		#8,R8				; Add half the divisor, for rounding
					rra4	R8					; C/16 in tenths of an amp
					neg		R8
					cmp		R8, &current
				_AND_IF	GE					; No less than -C/16
					mov		&ocCellVoltX256  ,R8; Get lower word ML
					mov		&ocCellVoltX256+2,R9; Get upper word 0H
					rra8_l	R9,R8
					cmp		#3251,R8
				_AND_IF	L					; <= 3.250 V smoothed
					inc		&restedCounter
					cmp		#10*60*StatusFreq,&restedCounter
					_IF		HS				; If counter >= 10 minutes
						clr		&restedCounter
						; Calculate a new SoC based on the rested smoothed average cell voltage that
						;	hasn't been charging for 10 minutes
						; Use SoC = (V-3.15)*300%
						sub		#3150,R8			; R8 = smoothed average cell voltage - 3.150 V
						; Result is 0-100 representing 0-30.0% SoC
						; So the units are 0.3%. Multiply by 3 to bring to tenths of a percent.
						mov		R8,R9				; R9 = 1x
						rla		R8					; R8 = 2x
						add		R8,R9				; R9 = 3x
						call	#SocToDischarge		; Convert to discharge
						mov		R9,&discharge		; Update discharge counter
						mov		R10,&discharge+2
					_ENDIF
				_ELSES
					clr		&restedCounter
				_ENDIF

			_ENDIF	; not BMU

			; Set bypass as required
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		NE
				mov		&bypassVoltage,R9		; Get the bypass threshold in R9
				cmp		R9,R10					; Compare present cell voltage (R10) to bypass threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00

				; Update the beenBypassing flag used by the OT stress calculation
				_IF		HS						; If bypassing (Note: HS = C)
					clr		&ticksSinceLastBypass	; ticksSinceLastBypass := 0
					mov.b	#1,&beenBypassing		; beenBypassing := TRUE
				_ELSE							; Else not bypassing
					tst.b	&beenBypassing
					_IF		NZ						; If been bypassing in last 5 minutes
						inc		&ticksSinceLastBypass	; ticksSinceLastBypass += 1
						cmp		#5*60*StatusFreq,&ticksSinceLastBypass
						_IF		HS						; If 5 minutes or more since last bypass
							clr.b	&beenBypassing			; beenBypassing := FALSE
						_ENDIF							; End if
					_ENDIF							; End if been bypassing in last 5 minutes
				_ENDIF							; End else not bypassing

				movBits_B	R8,#Bypass,&P2OUT	; Move only the #Bypass bit from R8 to &P2OUT. Trashs R8
				mov			&fullVoltage,R9		; Get the full (coulomb-counter reset) threshold in R9
												; Typ. 1 level above bypass (cf. one below for monitor)
				cmp			R9,R10				; Compare cell voltage (R10) to the full threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#ALL_FULL,&localStatus ; Move only All-Full bits from R8 to localStatus
			_ELSE
				bis.b		#ALL_FULL,&localStatus	; BMU must pretend it's in bypass so charge terminates
			_ENDIF

			cmp.b	#255,&ID
			_IF		NE						; If we're not a BMU
				push	R10						; For undervoltage stress calc below
				; Calculate stress due to overvoltage
				push	R10						; OCV for overvoltage stress calc
				mov.b	&ovStep,R8				; push.b doesn't work. It leaves junk in the high byte
				push	R8						; For every ovStep (millivolts)
				push	&ovZero					;	over ovZero, we add one level of stress
				push	#1						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if non-zero stress due to OV

				; Calculate stress due to undervoltage
												; OCV for undervoltage stress calc already pushed
				push	#UV_STEP				; For every UV_STEP (millivolts)
				push	#UV_ZERO				;	below UV_ZERO, we add one level of stress
				push	#2						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress UV
			_ENDIF	; not a BMU

			; Do temperature measurement
			call	#GetTemp				; Get temperature in degrees Celsius in R10

			cmp.b	#255,&ID
			_IF		EQ						; If we're a BMU
				sub		#8,R10					; Subtract 8 kelvin for self-heating
				mov.b	R10,&cellTemperature	; Save temp for calculation of internal resistance
			_ELSE							; Else we're not a BMU
				push	R10						; Save measurement for undertemperature stress calc
				; Calculate stress due to overtemperature

				; Prevent nuisance alarms/shutdowns and miscalculation of internal resistance
				; when high temp is only due to bypassing
				tst.b	&beenBypassing
				_IF		NZ						; If we've been bypassing in the last 5 minutes
						sub		#BypTempQuota,R10	; Subtract ~15 degC from the temp used for OT stress
				_ELSE							; Else only update cellTemperature when not bypassing
						mov.b	R10,&cellTemperature ; Save temp for calculation of internal resistance
				_ENDIF							; End if

				push	R10						; Measurement for overtemperature stress calc
				push	#OT_STEP				; For every OT_STEP (degrees Celsius)
				push	#OT_ZERO				;	over OT_ZERO, we add one level of stress
				push	#3						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to OT

				; Calculate stress due to undertemperature
												; Measurement saved on stack earlier
				push	#UT_STEP				; For every UT_STEP (degrees Celsius)
				push	#UT_ZERO				;	below UT_ZERO, we add one level of stress
				push	#4						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to UT
			_ENDIF

			; Calculate stress due to link voltage (current shunt measurement for a BMU)
			call	#GetLinkV				; Get worst link voltage in mV in R10
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		NE
				cmp		#9999,R10				; Special "invalid" value?
				_IF		NE						; Only calculate link stress if not this value
					; Calculate stress due to excessive absolute link voltage
					tst		R10						; Get absolute value of link voltage
					_IF		L
						inv		R10
						inc		R10
					_ENDIF
					push	R10						; Measurement for absolute link stress calc
					push	#AL_STEP				; For every AL_STEP (millivolts)
					push	#AL_ZERO				;	over AL_ZERO, we add one level of stress
					push	#5						; Type of measurement
					call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to AL
				_ENDIF
			_ELSE	; BMU
				; We have a 200 A 50 mV shunt,
				; and the diffamp has a gain of 10, so the linkV result should be
				; in units of 0.2 A. So -1500 to 1500 corresp to -300 A to 300 A.

												; Multiply by 2 to
				rla		R10						;  convert to tenths of an amp
												; Note: this means that the unit of current used by CMUs
												;	and the discharge logic is 1/10 A
				mov		R10,&current			; Save in RAM variable
				bis.b	#bSendi,&masterFlags	; Indicate that an 'i' command using &current is due
				ClearWatchdog					; When testing, seem to need this


				tst		&current
				_IF		NN						; If current is not negative
					bis.b	#bCharging,&monFlags	; We're charging
				_ELSE							; Else
					bic.b	#bCharging,&monFlags	; We're not charging
				_ENDIF							; Endif

				; Sign extend current to 32 bits in R10:R9.
				mov		&current,R9					; Get current in R9
				mov		R9,R10						; Make a copy in R10
				rla		R10							; Shift sign bit to carry
				subc	R10,R10						; 0 if R9 is negative, -1 otherwise
				inv		R10							; -1 if R9 is negative, 0 otherwise

				; Do coulomb counting
				sub		R9,&discharge				; Integrate current in 32-bit discharge accumulator
				subc	R10,&discharge+2			; for fuel gauge
				_IF		NN							; Clamp negative values to zero
				_ELSE								; There is no true _IF N with the MSP430
					clr		&discharge
					clr		&discharge+2
				_ENDIF
				call	#UpdateSoC					; Update the pre-computed SoC timer advance value

				; Send the high word of the discharge counter to safe storage
				tst.b	&ticks						; Every 128 seconds
				_IF	Z
					bis.b	#bSendZ,&masterFlags		; Indicate to the master that a Z command is due
				_ENDIF ; Every 128 seconds
			_ENDIF ; BMU current measurement

			cmp.b	#255,&ID
			_IF		NE						; If we're not a BMU
				; Clamp local present stress to a maximum value
				mov		#15,R9					; Default clamp value is 15
				cmp		#4,Rtype
				_IF		EQ						; If type is undertemperature
					mov.b	&alarmStress,R9		; Clamp to a max of 12 to avoid masking UV >= 12
				_ENDIF
				mov		Rstrs,R8				; Copy stress. movBits_B macro below trashes R8
				cmp		R9,R8					; If the stress is not less than the maximum allowed
				_IF		HS
					mov		R9,R8					; Use the maximum allowed
				_ENDIF

				; Update local present stress
				movBits_B R8,#STRESS,&localStatus ; Record for later use, preserving other status bits.

				; Update local present stress type if not already set to "all considered full" above.
				mov.b	&localStatus,R10
				and		#S_TYPE,R10
				cmp		#ALL_FULL,R10
				_IF		NE						; If stress type is not already All considered Full
					cmp		#2,Rtype
					_IF		EQ						; If stress type is UnderVoltage
						mov		#UV_AF,R8				; Set the UV_AF bit, clear the OV_UT bit
					_ELSE							; Else
						_COND							; Begin short circuit conditional
							cmp		#1,Rtype
						_OR_ELSE EQ					; If type is OverVoltage, else
							cmp		#4,Rtype
						_OR_IFS	EQ						; or if type is UnderTemperature
							mov		#OV_UT,R8				; Set the OV_UT bit, clear the UV_AF bit
						_ELSE							; Else type is OT (3) or AL (5)
							clr		R8						; Clear both type bits (never ignore)
						_ENDIF
					_ENDIF
					movBits_B R8,#S_TYPE,&localStatus ; Record type for later, presrve other status bits
				_ENDIF

				; Update worst stress since last reset thereof
				cmp.b	&worstStress,Rstrs		; If stress high or same as worstStress for trip so far
				_IF		HS
					tst.b	Rstrs					; and it's an actual, nonzero stress
					_IF	NZ
						mov.b	Rstrs,&worstStress		; Update worstStress
						mov.b	Rtype,&worstStressType	; Update type of measurement causing worst stress
					_ENDIF
				_ENDIF

				; Update Alarm -- local red LED and piezo
				cmp.b		&alarmStress,Rstrs ; Turn on error LED if stress is alarmStress or more
				CtoAllBits	Rtos
				bit.b		#bBadInsulation,&monFlags
				CtoAllBits	R8
				bis			R8,Rtos				; or if the last insulation test failed (BMU only)
				cmp			#200/4*16, &cellVRaw
				_IF			LO					; Don't alarm if cell disconnected (approx < 200 mV)
					clr			Rtos					; Actively turn alarm off if already on
				_ENDIF
				call		#ErrorLed			; Use this function so it optionally turns on piezo too
			_ENDIF	; Not a BMU

			; Check for comms error and send local status if required
			bic.b	#COM_ERR,&localStatus	; Clear comms error flag by default. May be set below.
			bit.b	#bNotSendStatus,&monFlags ; If sending status, and so expecting to receive it
			_IF		Z
				cmp.b	#ComErrTicks,&ticksSinceLastRx ; and too many ticks since last valid status Rx
				_IF		HS
					; If our ID is not 1 (first CMU), set the comms error bit in local status
					; and send a comment with our ID followed by 'c' for comms error
					; every 16 status bytes (approx every 8.5 seconds).
					cmp.b	#1,&ID
					_IF		NE
						bis.b	#COM_ERR,&localStatus
						mov.b	&ticks,R8
						and.b	#$F,R8
						_IF	Z
							call	#_commsError			; Call pretty-printing command
						_ENDIF
					_ENDIF

					; Act as a master -- send our status
					mov.b	&localStatus,R8
					bis.b	#$80,R8					; Set the high bit to say it's a status byte

					; Send status or control a charger
					cmp.b	#255,&ID
					_IF		NE						; If we're a CMU
						call	#TxByte					; Send the status byte. Wait buffer not full
					_ELSE							; Else we're a BMU, in charger control mode
						call	#ScuTxByte				; Send status to the SCU. Wait buffer not full
						mov.b	R8,&globalStatus		; '255sp' (or modbus equiv) reads global status
						call	#ControlContactors		; Control contactors
					_ENDIF							; End if
				_ENDIF							; End if too many ticks since last rx
			_ENDIF							; End if sending status
			ret
; End of DoMeasurement


DoStress:
;
; Called 5 times by DoMeasurement to calculate the various kinds of stress
; and keep track of which is worse.
; It takes 4 parameters on the stack and updates 3 registers as required (Rstrs, Rmeas, Rtype).
; Trashes R8 thru R11.
;
; Stack offsets for parameters (return address is at offset zero)
type	EQU		2				; A number representing the type of measurement OV=1 UV=2 OT=3 UT=4 AL=5
zero	EQU		4				; The measurement corresponding to zero stress
step	EQU		6				; The change in measurement corresp to a change of one stress level
meas	EQU		8				; The measurement

			ClearWatchdog
			mov		meas(SP),R9				; Get meas in R9
			mov		type(SP),R10			; Get type * 2 in R10 for use as word index
			rla		R10
			mov		step(SP),R8				; Get step in R8
			tst		R8
			_IF		GE
				cmp		worstStress(R10),R9
				_IF		GE						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				sub		zero(SP),R9				; Get meas - zero in R9
			_ELSE
				cmp		worstStress(R10),R9
				_IF		L						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				inv		R8						; Get absolute value of step in R8
				inc		R8
				mov		zero(SP),R9				; Get zero - meas + step -1 in R9
				sub		meas(SP),R9
				add		step(SP),R9
				sub		#1,R9
			_ENDIF
			_IF		L
				clr		R9						; Min of 0
			_ENDIF
			clr		R10						; Clear high word of dividend
			call	#UMSlashMod				; R9 = R10:R9 / R8 = (meas - zero) / step, clears R11
			cmp		R9,Rstrs
			_IF		LO						; If this stress worse than present stress calculated so far
				mov		R9,Rstrs				; Make it the new present stress
				mov		meas(SP),Rmeas			; Measurement causing present stress
				mov		type(SP),Rtype			; Type of measurement causing present stress
			_ENDIF
			pop		R8						; Pop the return address
			add		#8,SP					; Drop the parameters off the stack
			br		R8						; Return
; End of DoStress


DoStatus:
;
;	Process received status byte in R8. Trashes R9, R10
;	Status byte:
;	Bit 7: Always 1 for status byte
;	Bit 6: Comms error: Means that status information does not represent the whole pack
;	Bit 5: Ignore on charge (if bit 4 is clear), All considered full (if bit 4 is set)
;	Bit 4: Ignore on discharge
;	Bits 3-0: Stress level 0-15
;
		; Extract the stress bits from the incoming status byte
		mov.b	R8,R9					; Copy incoming status to R9
		and.b	#STRESS,R9				; Only stress bits in R9

		clr.b	&ticksSinceLastRx		; Now zero time since last received valid status
		; This will eliminate any comms error next time through DoMeasurement

		; Check if DoMeasurement may have just sent a status byte, due to a comms error
		bit.b	#COM_ERR,&localStatus
		_IF		Z						; If no comms error

			cmp.b	#255,&ID
			_IF		NE						; If we're a CMU
				; Do MAX of local and incoming stress, and handle stress type and all considered full
				mov.b	&localStatus,R10		; Get local status to R10
				and.b	#STRESS,R10				; Extract stress bits
				cmp.b	R10,R9					; Compare incoming stress (R9) to ours (R10)
				_IF		LO						; If incoming stress (R9) is less than ours (R10)
					mov		R8,R9					; Make a copy of incoming status for tests below
					mov.b	&localStatus,R10		; Get local status to R10
					movBits_B	R10,#STRESS|S_TYPE,R8 ; Replace incoming stress and type with ours (trashes R10)
					_COND
						and		#S_TYPE,R9
						cmp		#ALL_FULL,R9
					_AND_IF	NE						; If incoming was not all considered full
						mov.b	&localStatus,R10
						and		#S_TYPE,R10
						cmp		#ALL_FULL,R10
					_AND_IF	EQ						; and if local is in bypass
						bic		#UV_AF,R8 				; Clear the UV_AF (undervoltage or all considered full) bit
					_ENDIFS
				_ELSE							; Else incoming stress is not less than ours
					_IF		EQ						; If incoming stress is equal to ours
						mov.b	&localStatus,R10		; Ensure UV trumps other types, particularly UT,
						and		#S_TYPE,R10				; which won't go away when sources dropped, and
						cmp		#UV_AF,R10				; may mask UV and prevent loads being dropped.
						_IF		EQ						; If local is undervoltage
							movBits_B	R10,#S_TYPE,R8		; Replace incoming type with ours (trashes R10)
						_ENDIF
					_ENDIF
					; Incoming stress not less than ours
					mov		R8,R9					; Make a copy of incoming status for tests below
					_COND
						and		#S_TYPE,R9
						cmp		#ALL_FULL,R9
					_AND_IF	EQ						; If incoming is all considered full
						mov.b	&localStatus,R10
						and		#S_TYPE,R10
						cmp		#ALL_FULL,R10
					_AND_IF	NE						; and if local is not in bypass
						bic		#UV_AF,R8 				; Clear UV_AF (UV or all considered full) bit
					_ENDIFS
				_ENDIF							; End else incoming stress is not less than ours

				; Process incoming comms error bit.
				; Since we received a valid status byte, there is no local
				;	comms error, so just pass the incoming comms error bit through.

				; Send the possibly-updated status byte
				call	#TxByte					; Send the status byte. Wait buffer not full
			_ELSE							; Else we're a BMU
				; Process incoming status for BMU. Stress in R9, complete status in R8.
				mov.b	R8,&globalStatus		; Put it where can be read by '255sp' (or modbus equiv)
				bit.b	#bNotSendStatus,&monFlags
				_IF		Z 						; If sending status, and so expecting to receive it
					call	#ScuTxByte				; Send status byte to the SCU. Wait buffer not full
				_ENDIF

				; If all considered full (and no comms error), reset the coulomb counter
				_COND							; Start short-circuit conditional
					bit		#COM_ERR,R8				; Test the comms error bit
				_AND_IF	Z						; If no comms error
					mov		R8,R10					; Make a copy of the status byte in R10
					and		#S_TYPE,R10				; Extract the stress type bits
					cmp		#ALL_FULL,R10
				_AND_IF	EQ						; And If all cells are considered full
					; Set the discharge counter to a DoD of 0.
					mov		#0,&discharge		; Lo word
					mov		#0,&discharge+2		; Hi word
					call	#UpdateSoC			; Update the pre-computed PWM counter advance value
				_ENDIFS ; All Considered Full and no comms error

				call	#ControlContactors		; Control PIP charging, and shut down if all else fails
			_ENDIF							; End else BMU
		_ENDIF							; End if no comms error
		ret
; End of DoStatus


ControlContactors:
;
; Status byte is in R8. Use it to control contactors
;
		push 	R9
		push	R10

		; Check if the stress type can be ignored, based on the direction of the current.
		; But if the source contactors are off, treat it as if we are charging, and so ignore only
		; undervoltage stress.
		mov		R8,R9					; Take a copy of the status byte in R9
		_COND							; Begin a short-circuit conditional
			cmp		#10,&current			; Check the current, which is in tenths of an amp
		_OR_ELSE	GE						; If there's 1 amp or more of charge current (positive)
			bit.b	#AcLfPvCtor,&CtorPortOUT ; Check the state of the source contactors
		_OR_IFS	Z						; Or if the AC and left PV source contactors are off
			and		#S_TYPE,R9				; Isolate the two stress-type bits
			cmp		#UV_AF,R9				; Check if type of stress is ignore-on-charge
		_ELSE							; Else not charging
			cmp		#-9,&current			; Check the current, which is in tenths of an amp
			_IF		L						; If 1 amp or more of discharge current (negative)
				and		#OV_UT,R9				; Isolate the single overvolt/undertemp stress-type bit
				cmp		#OV_UT,R9				; Check if type of stress is ignore-on-discharge
			_ELSE							; Else current between -1 amp and 1 amp
				clrz							; Ensure stress will not be ignored, by clearing EQ flag
			_ENDIF							; Endif 1 amp discharge
		_ENDIF							; Endif >= 1 amp charge or source contactors off

		; Treat ignorable stress as 6 and comms error as 15, for contactor control (will be smoothed)
		_IF		EQ						; If we can ignore this stress
			mov		#6,R9					; Treat it as stress 6 (< neutral) for contactor control
		_ELSE							; Else can't ignore
			mov		R8,R9
			and		#STRESS,R9				; Get stress into R9
		_ENDIF							; Endif ignore stress
		bit		#COM_ERR,R8
		_IF		NZ						; If the comms error bit is set
			mov		#15,R9					; Treat it as stress 15 for contactor control
		_ENDIF								;   (it will be smoothed)

		; Calculate smoothed stress for controlling contactors and charge voltages
		rla2	R9						; Quadruple the incoming stress
		mov.b	&smoothStressX4,R10		; Get the previous smoothed stress times 4 into R10
		add		R10,R9
		add		R10,R9
		add		R10,R9					; R9 = 4*incoming + 3*4*previous
		incd	R9						; Add 2 for rounding
		rra2	R9						; Divide by 4 to get new smoothed stress times 4
		mov.b	R9,&smoothStressX4		; Save it for next time
		inc		R9						; Add 1 for rounding (don't add 2 or it won't descend fully)
		rra2	R9						; Divide by 4 to get smoothed stress

		cmp.b	#15,R9					; If smoothed stress is extreme
		_IF		GE
			inc.b	&shutdownTimer
			cmp.b	#ShutdownTime,&shutdownTimer
			_IF		HS						; And enough time has passed
				bic.b	#(BatPosCtor|BatNegCtor|AcLfPvCtor|RtPvCtor),CtorPortOUT ; Drop out all battery
																		; contactors, and we die
				; We need an endless loop here in case the BMU doesn't lose power.
				; It may still be powered up by the inverter capacitors, or some charge source.
				; This will require the red button to be pushed to remove power from the BMU
				; to reset it. After which, releasing the red may be sufficient to restart,
				; or you may also have to push the green.
				br		#Halt			; Also check for BSL password
			_ENDIF
		_ELSE							; Else
			clr.b	&shutdownTimer			; Clear the shutdown timer
		_ENDIF							; Endif

		; If (not UV && charging && stress >= 12 && bDonePipInit) || (array voltage >= 145 V)
		;	turn off charging/source contactors
		mov		R8,R10					; Make a copy of the status byte in R10
		and		#S_TYPE,R10				; Extract the two stress-type bits
		_COND							; Begin short circuit conditional
			cmp		#UV_AF,R10				; Check for UV = UV_AF and not OV_UT
		_AND_IF	NE						; If the stress is not due to UnderVoltage
			bit.b	#bCharging,&monFlags
		_AND_IF	NZ						; And if we're charging
			cmp.b	&alarmStress,R9
		_AND_IF	GE						; And if incoming stress is alarming
			bit.b	#bDonePipInit,&monFlags
		_AND_IF	NZ						; And if we haven't just started up (CMU breaks look like stress)
			bic.b	#RtPvCtor|AcLfPvCtor,&CtorPortOUT ; Drop out the source contactors (grn, white LEDs)
		_ELSES							; Else
			push	R8
			push	R9
			call	#GetArrayV				; Get the PV array voltage
			pop		R9
			pop		R8
			cmp		#145*10,R10
			_IF		HS						; If PV array voltage is greater or equal to 145 volts
				bic.b	#RtPvCtor|AcLfPvCtor,&CtorPortOUT ; Drop out the source contactors
			_ENDIF
		_ENDIF

		; If stress <= 6 && array voltage < 140 V
		;	turn on charging/source contactors
		; We need to let it go down to stress 6 so that balancing can occur.
		_COND							; Begin short circuit conditional
			cmp.b	#7,R9
		_AND_IF	L						; And if incoming stress is < 7
			push	R8
			call	#GetCellV
			pop		R8
			cmp		#140*10,R10
		_AND_IF	LO						; And if PV array voltage is less than 140 volts
			; The following test is required to avoid waiting 700 ms every time around the main loop
			; and thereby slowing communications between BMU ports to a crawl.
			; The 140 ms delay before turning the first one back on, was found necessary to avoid
			; overloading the 12 V DC-DC converter and shutting down the whole system, in the case where
			; these contactors had only just been turned off.
			_COND								; Begin short-circuit conditional
				bit.b	#AcLfPvCtor,&CtorPortOUT
			_OR_ELSE	Z						; If the AC and left PV source contactors are off
				bit.b	#RtPvCtor,&CtorPortOUT
			_OR_IFS		Z						; Or the right PV source contactors are off
				mov		#140,R8						; 140 milliseconds
				call	#DelayMs					; Wait in case they have only just been turned off
				bis.b	#AcLfPvCtor,&CtorPortOUT	; Turn on the AC and left PV source contactors
				mov		#560,R8						; 560 milliseconds
				call	#DelayMs					; Wait for last economiser to reduce coil current
				bis.b	#RtPvCtor,&CtorPortOUT		; Turn on the right PV source contactors
			_ENDIF
		_ENDIFS

#if 1
		bit.b	#bCharging,&monFlags	; Set by sign of current in 'i' command
		_IF		NZ						; If we've been told to start charging
			ClearWatchdog
			inc.b	&chargerTxTimer			; Increment charger transmit timer
			mov.b	&chargerTxTimer,R9		; Get charger transmit timer
			and.b	#3,R9
			_IF		Z						; Every fourth tick (every 2 seconds)
				bit		#COM_ERR,R8
				_IF		NZ						; If the comms error bit is set
					and		#STRESS,R8
					cmp		#8,R8					; Treat it as a minimum of stress 8 for chg control
					_IF		LO
						mov		#8,R8
					_ENDIF
				_ELSE
					; If stress is due to undervoltage, treat it as stress 0 for charging purposes
					mov		R8,R9					; Make a copy of the status byte in R9
					and		#S_TYPE,R9				; Extract the stress type bits
					cmp		#UV_AF,R9
					_IF		EQ						; If stress type is UnderVoltage
						clr		R8						; Treat as a stress of zero for charging
					_ELSE							; Else
						and		#STRESS,R8				; Use the given stress value (0-15)
					_ENDIF
				_ENDIF
#if 0			// Untested code
				;call	#ChgController			; Call charger controller with R8 as input
				call	#PiController			; Call PI charger controller with R8 as input
				call	#SendChargerPackets		; Send packets to charger to set voltage
#endif
			_ENDIF ; Every fourth tick
		_ENDIF ; bCharging
#endif
		pop		R10
		pop		R9
		ret
; End of ControlContactors


DoPrecharge:
		; This code is designed to work with a number of different battery contactor
		; arrangements.
		; t0 thru t4 indicate the time order of switching during precharge.
		; P22 thru P26 are the numbers of the BMU connectors that drive the contactor coils.
		; The connector numbers increase as you go away from the BMU's 12 V input connector.
		; These BMU connectors are named respectively PRE BAT CHG DIS NRM in the software and schematic.
		;
		; This is the contactor arrangement for monoliths
		; (apart from #1 at Helidon which is handled by the rev61 branch)
		;           + ___ -
		; Bat+ --+----o o------------------+-- Load +
		;        | t3 BAT+ P23             |
		;        |    ___          ___     |
		;        +----o o---------|___|----+
		;          t2 PRE P22    3R3 100W
		;
		;           + ___ -        ___
		; Bat- -------o o---------|___|------- Load -
		;          t0 BAT- P24  500A 50mV shunt
		;
		;           + ___ -
		;        -----o o------     AC In contactor, left PV+ and delayed left PV- contactors
		;          t4 ACLPV P25
		;
		;           + ___ -
		;        -----o o------     Right PV+ and delayed right PV- contactors
		;          t1 RPV P26
		;
 mov	#200,R8
 call	#DelayMs	; Give power supply time to stabilise before first big load
		; We stagger the turn-on of the contactors so that the DC-DC converter can cope.
		bis.b	#BatNegCtor,&CtorPortOUT 	; Turn on the battery negative contactor
		mov		#160,R8						; 160 milliseconds (to allow for GX14 or EV200)
		call	#DelayMs					; Wait for economiser to reduce coil current

		; We may have come here after a bootstrap-load, with all contactors (except precharge) still on.
		; We should only turn on the precharge contactor if the positive contactor isn't already on,
		; because otherwise it may put too much load on the power supply and shut down the Monolith.
		bit.b	#BatPosCtor,&CtorPortOUT	; Check the positive contactor
		_IF		Z							; If the positive contactor is off
			bis.b	#PreCtor,&CtorPortOUT		; Turn on the Precharge contactor
		_ENDIF
		mov		#3*1000/100,R12				; 3 seconds = 30 x 100 ms timeout
		_REPEAT
			mov		#100,R8						; 100 milliseconds; placed at start
			call	#DelayMs					;	of loop to allow ADC system to settle after reset
			call	#GetCapV					; Trashes R8, R9, R11 result in R10
			push	R10							; Save capacitor voltage measurement
			call	#GetBatV					; Trashes R8, R9, R11 result in R10
			pop		R8							; Restore cap voltage to R8
			sub		R8,R10						; R10 = BatV - CapV
			abs		R10							; R10 = Abs(BatV - CapV), allow for CapV > BatV
			cmp		#6*10,R10
			_WHILE	HS							; Wait for less than 6 V across contactor
				dec		R12
		_UNTIL	Z
				mov		#1,Rtos						; Fall thru to here on timeout
				call	#ErrorLed					; We who are about to die beep at you
				bic.b	#PreCtor,&CtorPortOUT		; Turn off the Precharge contactor to save resistor
				bic.b	#BatNegCtor,&CtorPortOUT 	; Turn off the battery negative contactor
				br		#Halt						; Endless loop, but check for BSL password
			_ELSE									; Come here from WHILE, when less than 6 V
				; We stagger the turn-on of the contactors so that the DC-DC converter can cope.
				bis.b	#BatPosCtor,&CtorPortOUT	; Turn on the battery positive contactor
				mov		#160,R8						; 160 milliseconds
				call	#DelayMs					; Wait for economiser to reduce coil current
				bic.b	#PreCtor,&CtorPortOUT		; Turn off the Precharge contactor to save power
				mov		#160,R8						; 160 milliseconds
				call	#DelayMs					; Wait for pre-charge to come off
				; Each source contactor output drives multiple contactors some of which have
				; delay circuit boards preceding them. Their delay is 160 to 400 ms.
				; So we must wait the worst case plus another 160 ms. Total 560 ms.
				bis.b	#AcLfPvCtor,&CtorPortOUT	; Turn on the AC and left PV source contactors
				mov		#560,R8						; 560 milliseconds
				call	#DelayMs					; Wait for last economiser to reduce coil current
				bis.b	#RtPvCtor,&CtorPortOUT		; Turn on the right PV source contactors
				mov		#560,R8						; 560 milliseconds
				call	#DelayMs					; Wait for last economiser to reduce coil current
			_ENDIF
		ret

#if 0
PiController:
;
; A PI voltage controller whose input and output are in R8
; Input range is 0 to 15 (stress levels). Setpoint is 7.
; Output range is chargerVoltMin to chargerVoltMax (tenths of a volt).
;
#define Rerror R10			// Error register
#define Rderiv R9			// Derivative register
#define Routput R8			// Output register
			mov		#7,Rerror				; error = setpoint - measurement
			sub		R8,Rerror
			mov		Rerror,Rderiv			; deriv = error - prev_error
			sub		&piPrevError,Rderiv

			mov		&piPrevOutput,Routput	; output = prev_output + Kp * deriv + Ki * error
			; Insert rla Rderiv here to change Kp
			rla3	Rderiv					; Kp = 4
			add		Rderiv,Routput
			mov		Rerror,R9				; Overwrites unused Rderiv
			; Insert rla R9 here to change Ki
			add		R9,Routput				; Ki = 1

			mov		&chargerVoltMin,R9
			rla2	R9						; The combination of this rla2, the rla2 below,
											; and the rra2 at the end, have the effect of dividing
											; bit Kp and Ki by 4. So they are effectively 1 and 1/4.
			cmp		R9,Routput				; Clamp output between chargerVoltMin and chargerVoltMax
			_IF		L
				mov		R9,Routput
			_ELSE
				mov		&chargerVoltMax,R9
				rla2	R9						; For effective reduction of Kp and Ki
				cmp		R9,Routput
				_IF		GE
					mov		R9,Routput
				_ENDIF
			_ENDIF

			mov		Rerror,&piPrevError		; prev_error = error
			mov		Routput,&piPrevOutput	; prev_output = output
			rra2	Routput					; For effective reduction of Kp and Ki
			ret
; End of PiController
#endif

#if 1
PiController:
;
; A PI curent controller whose input and output are in R8
; Input range is 0 to 15 (stress levels). Setpoint is 7.
; Output range is 0 to #chargerCurrMax (whole amps).
;
#define Rerror R10			// Error register
#define Rderiv R9			// Derivative register
#define Routput R8			// Output register
			mov		#7,Rerror				; error = setpoint - measurement
			sub		R8,Rerror
			mov		Rerror,Rderiv			; deriv = error - prev_error
			sub		&piPrevError,Rderiv

			mov		&piPrevOutput,Routput	; output = prev_output + Kp * deriv + Ki * error
			; Insert rla Rderiv here to change Kp
			rla3	Rderiv					; Kp = 4
			add		Rderiv,Routput
			mov		Rerror,R9				; Overwrites unused Rderiv
			; Insert rla R9 here to change Ki
			add		R9,Routput				; Ki = 1

			mov		#0,R9					; Minimum output current. Keep like the voltage version
			rla2	R9						; The combination of this rla2, the rla2 below,
											; and the rra2 at the end, have the effect of dividing
											; bit Kp and Ki by 4. So they are effectively 1 and 1/4.
			cmp		R9,Routput				; Clamp output between chargerVoltMin and chargerVoltMax
			_IF		L
				mov		R9,Routput
			_ELSE
				mov		#chargerCurrMax,R9
				rla2	R9						; For effective reduction of Kp and Ki
				cmp		R9,Routput
				_IF		GE
					mov		R9,Routput
				_ENDIF
			_ENDIF

			mov		Rerror,&piPrevError		; prev_error = error
			mov		Routput,&piPrevOutput	; prev_output = output
			rra2	Routput					; For effective reduction of Kp and Ki
			ret
; End of PiController
#endif


ChgController:
;
; A simple stress controller. R8 has smoothed stress, zero if due to undervoltage.
; Output stored in prevBulk and prevFloat variables.
;

			clr.b	&lastChgChanged				; Will set later only if bulk or float voltages change
			cmp		#11,R8
			_IF	GE								; If the stress high enough to act
				cmp		#CHG_BULK_MIN,&prevBulk
				_IF		GE							; If the bulk voltage isn't at minimum yet
					dec		&prevBulk					; then decrease the bulk voltage by 0.1 V
					mov.b	#1,&lastChgChanged			; Remember this change
				_ENDIF
				cmp		#CHG_FLT_MIN,&prevFloat		; Same for float voltage
				_IF		GE
					dec		&prevFloat
					mov.b	#1,&lastChgChanged
				_ENDIF
			_ELSE
				; We can't send changes to increase the bulk or float voltages very quickly, because
				; if we're solar charging, every increase will reset the SCC and charge current will
				; go to zero and slowly ramp back
				_COND
					mov.b	&chargerTxTimer,R9
					and		#$7F,R9					; Look at lower 7 bits
				_AND_IF	Z						; Will be zero every 128 ticks
												;	= every 32 seconds
					cmp		#7+1,R8				; If all cells are calm
				_AND_IF		L
					cmp		#CHG_BULK_STD,&prevBulk	; If we have not yet reached the standard bulk voltage
					_IF		L
						inc		&prevBulk				; then slowly work back towards the std voltage
						mov.b	#1,&lastChgChanged
					_ENDIF
					cmp		#CHG_FLT_STD,&prevFloat		; Same for float voltage
					_IF		L
						inc		&prevFloat
						mov.b	#1,&lastChgChanged
					_ENDIF
				_ENDIFS
			_ENDIF
			ret

#if 0			// This is the version that goes with the PI voltage controller
SendChargerPackets:
;
; Send charger float and bulk command packets (in the right order)
; with voltage from R8 (in tenths of a volt)
;
; Trashes R8 thru R11
;
; Send PBFTvv.v<crc16><cr> and PCVVww.w<crc16><cr>
;	where vv.v is the Float voltage and ww.w is the Bulk voltage.
; When raising the voltage, bulk will have to be sent before float,
; and when lowering it, float will have to be sent before bulk.
PipCmdDelay	EQU		950					; Delay in ms between PIP commands, so next one not NAKed

			;
			; Although we have waited long enough to send the last 9600 bps character completely, it is
			; possible that this 9600 bps character has triggered a 2400 bps byte, possibly right near
			; the end of the last 9600 bps character. This may interfere with the carriage return we
			; want to send to flush the 9600 bps "junk" from the PIP's buffers.
			; So a delay of one 2400 bps character time (4 ms) should be enough time to guarantee that
			; any 9600 bps junk has passed.
			push	R8
			mov		#4,R8
			call	#DelayMs
			mov		#$0D,R8				; Send a carriage return to the PIP to flush preceding
			call	#TxByte				; 2400 baud junk caused by 9600 baud commands sent to CMUs.
			mov		#PipCmdDelay,R8		; Delay between commands so next one not NAKed
			call	#DelayMs
			pop		R8

			; Compare new requested voltage with previously sent bulk and float voltages
			; to determine whether to send the new voltage as Float or Bulk.
			; This algorithm is optimised for bringing possibly-distressing voltages _down_ as soon
			; as possible, at the expense of small delays in charging due to possibly not putting
			; them up as soon as possible. The PIP gives no way of telling when it is in float mode.
			_COND
				cmp		&prevFloat,R8
			_AND_IF		EQ
				cmp		&prevBulk,R8
			_AND_IF		EQ
				tst		&lastWasFloat
				_IF		NZ
					mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
					mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
					mov		#BulkCmd,R10		; Send a Bulk voltage packet
					call	#SendPipPacket		; Trashes R8 thru R11
				_ELSE
					mov		R8,&prevFloat		; Record float voltage setpoint for next time
					mov		#-1,&lastWasFloat	; Record that the last sent was a Float
					mov		#FloatCmd,R10		; Send a Float voltage packet
					call	#SendPipPacket		; Trashes R8 thru R11
				_ENDIF
			_ELSES
				_COND
					cmp		&prevFloat,R8
				_OR_ELSE	LO
					cmp		R8,&prevBulk
				_OR_IFS		LO
					tst		&lastWasFloat
					_IF		NZ
						cmp		&prevFloat,R8
						_IF		LO
							mov		&prevFloat,R8
						_ENDIF
						mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
						mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
						mov		#BulkCmd,R10		; Send a Bulk voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ELSE
						cmp		R8,&prevBulk
						_IF		LO
							mov		&prevBulk,R8
						_ENDIF
						mov		R8,&prevFloat		; Record float voltage setpoint for next time
						mov		#-1,&lastWasFloat	; Record that the last sent was a Float
						mov		#FloatCmd,R10		; Send a Float voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ENDIF
				_ELSE
					cmp		&prevBulk,R8
					_IF		EQ					; If equal to previous bulk voltage
						mov		R8,&prevFloat		; Record float voltage setpoint for next time
						mov		#-1,&lastWasFloat	; Record that the last sent was a Float
						mov		#FloatCmd,R10		; Send a Float voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ELSE						; Else
						mov		R8,&prevBulk		; Record bulk voltage setpoint for next time
						mov		#0,&lastWasFloat	; Record that the last sent was a Bulk
						mov		#BulkCmd,R10		; Send a Bulk voltage packet
						call	#SendPipPacket		; Trashes R8 thru R11
					_ENDIF						; End sending Float or Bulk voltage
				_ENDIF
			_ENDIF

			mov		#PipCmdDelay,R8		; Delay between commands so next one not NAKed
			call	#DelayMs

			ret
; End of SendChargerPackets

SendChargerPackets:
			tst.b	&lastChgChanged
			_IF		NZ					; Only if the last bulk or float value changed
				push	&TxBytePtr			; Save the present Tx pointer
				mov		#ChgTxByte,&TxBytePtr ; Point the Tx pointer at the charge ports
				mov		#BulkCmd,R10		; Send a bulk voltage packet
				mov		&prevBulk,R8
				call	#SendPipPacket		; Trashes R8 thru R11
				mov		#500,R8
				call	#DelayMs			; Allow time for this to be processed and Ack'd
				mov		#FloatCmd,R10		; Send a float voltage packet
				mov		&prevFloat,R8
				call	#SendPipPacket		; Trashes R8 thru R11
				pop		&TxBytePtr
			_ENDIF
			ret

FloatCmd	DB			4, 'PBFT'		; First byte is length of following string
BulkCmd		DB			4, 'PCVV'		; 48.0 to 58.4 V
			ALIGN		1


; Needed by the PI voltage controller
SendPipPacket:
;
; Send a PIP command packet`
; with command string pointed to by R10
; and voltage in R8 (in tenths of a volt)
;
; Trashes R8 thru R11
;
			; Send the PIP command
			push		R8					; Save the voltage (in tenths of a volt) on the stack

			call		#TxStringCrc		; Send string pointed to by R10. Trashes R8 thru R11

			ClearWatchdog

			mov			#0,R10
			pop			R9					; Pop voltage to R9
			mov			#100,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov			R9,R8
			add			#'0',R8
			call		#TxByteCrc			; Send the tens digit of voltage (trashes R8 thru R10)

			mov			R10,R9
			mov			#0,R10
			mov			#10,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov.b		R9,R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the units digit of voltage (trashes R8 thru R10)

			mov.b		#'.',R8
			call		#TxByteCrc			; Send the decimal point (trashes R8 thru R10)

			ClearWatchdog

			mov.b		R10,R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the tenths digit of voltage (trashes R8 thru R10)

			call		#TxCrc				; Send the two bytes of CRC and clear it
			mov.b		#$0D,R8
			call		#TxByte				; Send the carriage return without accumulating CRC

			ClearWatchdog

			ret


#endif

#if 1			// This is the version that goes with the PI current controller
SendChargerPackets:
;
; Send charger dynamic MNCHGC command packets
; with current from R8 (in whole amps)
;
; Trashes R8 thru R11
;
; Send PBFTvv.v<crc16><cr> and PCVVww.w<crc16><cr>
;	where vv.v is the Float voltage and ww.w is the Bulk voltage.
; Send PBFT0ccc<crc16><cr> where ccc is the desired current plus 500

			mov			#MunchCmd,R10		; Send a MNCHGC current packet
			; Send the PIP command
			push		R8					; Save the current (in whole amps) on the stack
			call		#TxStringCrc		; Send string pointed to by R10. Trashes R8 thru R11

			ClearWatchdog

			mov			#0,R10
			pop			R9					; Pop current to R9
			add			#500, R9			; Add 500 to make it dynamic
			mov			#100,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov			R9,R8
			add			#'0',R8
			push		R10					; Save remainder
			call		#TxByteCrc			; Send the hundreds digit of argument (trashes R8 thru R10)

			pop			R9					; Remainder to R9
			mov			#0,R10
			mov			#10,R8
			call		#UMSlashMod 		; R10:R9 / R8 -> R9, remainder R10. Clears R11
			mov.b		R9,R8
			add.b		#'0',R8
			push		R10					; Save remainder
			call		#TxByteCrc			; Send the tens digit of argument (trashes R8 thru R10)

			ClearWatchdog

			pop			R8					; Remainder to R8
			add.b		#'0',R8
			call		#TxByteCrc			; Send the units digit of argument (trashes R8 thru R10)

			call		#TxCrc				; Send the two bytes of CRC and clear it
			mov.b		#$0D,R8
			call		#TxByte				; Send the carriage return without accumulating CRC

			ClearWatchdog

			ret

MunchCmd	db			7, 'MNCHGC0'		; Always send to the master for now

; End of SendChargerPackets
#endif


;
; Update the SoC meter's advance value (so the SoC meter will reflect a change made to the discharge
; counter)
; Preserves R8 and R9, trashes R10, clears R11
;
UpdateSoC:
MinAdvance	EQU			20					; To avoid timer compare wraparound
			push		R8
			push		R9
			; Though we use DoD here, the PWM interrupt routine inverts the output so it represents SoC
			call		#DepthOfDischarge	; Get DoD as value 0-1000 (0 to 100.0%)
			cmp			#MinAdvance,R9		; Compare with minimum value
			_IF			LO					; If lower,
				mov			#MinAdvance,R9		; Enforce minimum value to avoid timer compare wrap
			_ENDIF
			cmp			#1000-MinAdvance,R9	; Compare with maximum value
			_IF			HS					; If higher or same,
				mov			#1000-MinAdvance,R9	; Enforce maximum value to avoid timer compare wrap
			_ENDIF
			mov			R9,&socPwmAdv		; Save in the pre-computed advance variable
			pop			R9
			pop			R8
			ret


; Some calculations so we can see how much space we have left, by reading the listing.
freespace	EQU		_CMDCHRTBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/(_CMDCHRTBL-PROG_START))

;---------------------------------------------------------------------------------
; Interrupt and entry-point jump table at the end of the third-last main-flash segment
;---------------------------------------------------------------------------------
				ORG		BSL2_START-$22	; FBDE for now
CMDCHRTBLEND	EQU		$				; Command character table ends immediately below lowest
										;  main-program entry point
jInterpretByte	br		#InterpretByte	; A branch to InterpretByte, independent of PROG_START

jUCA0TxIsr		br		#TxIsr			; UART transmit
jUCA0RxIsr		br		#RxIsr			; UART receive

jTA1TxRxIsr		br		#ChgTxRxIsr		; Combined TA1 CCR1 & CCR2
										; (BMU only: Chg transmit & receive capture/compare)
jTA1MeasureIsr	br		#MeasureBmuIsr	; Timer A1 CCR0
										; (BMU only: Measurement compare)
jInterpretInit	br		#InterpretInit	; A branch to InterpretInit, independent of PROG_START

jTA0TxRxIsr		br		#ScuTxRxIsr		; Combined TA0 CCR1 & CCR2
										; (BMU only: SCU transmit & receive capture/compare)
										; (CMU only: Measurement compare)
jTA0FllIsr		reti					; Timer A0 CCR0 (frequency locked loop capture).
				nop						;   This is handled directly by the BSL.
				ORG		BSL2_START-2	; FBFE for now
ProgPresence	DB		$AA				; For BSL2 to check before calling main program (InterpretByte)
ProgChecksum	DB		$FF				; Placeholder for checksum added by LyteFlash or SendProg

;---------------------------------------------------------------------------------
; Bootstrap loader, in the last two main-flash segments
;---------------------------------------------------------------------------------
				ORG		BSL2_START		; Start of second-last main-flash segment
; Include the Bootstrap loader
#include "../common/BSL2.s43"			// Include bootstrap-loader and interrupt vectors
				ORG		$FFFE			; The reset vector
				DW		jBSL			; Reset to BSL main entry in case there is a crash

				_CS_CHECK				; Check that the control-flow stack is balanced
				END
