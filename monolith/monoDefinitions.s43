;
; Command character definitions for the monitor
;

#include "../common/comDefinitions.s43"			; Include the definitions common to monitor
												; and TestICal

; ErrorChec(k)ing ( -- )						; Toggle bErrorChecking
			; The complete packet for a k command, with CRC, is kCB.
			; This will always toggle error checking.
			; When sending from a terminal program such as TeraTerm:
			; To turn on  error checking irrespective of present state, send k<enter>.
			; To turn off error checking irrespective of present state, send k<enter> kCB<enter>.
			; When sending from the node-red Monolith debug terminal,
			; or anywhere CRCs are added automatically,
			; To turn on  error checking irrespective of present state, send 2<enter>.
			; To turn off error checking irrespective of present state, send 2<enter> k<enter>.
			; 2<enter> works in this case because fk will be sent as the CRC.
			; This is effectively a no-op with a k in its CRC.
			; However if it is received by a BMU that does not already have error checking turned on,
			; it will also harmlessly respond with its state of charge, due to the 'f'.
			xCODE	'k',ErrorChecking,_ErrorChecking
			xor.b	#bErrorChecking,&interpFlags ; Toggle bErrorChecking bit in interpFlags
			ret

; Kill status sending ( boolean -- )		; 1 for no status, 0 for status
			xCODE	'K',KillStatus,_KillStatus
			allBitsIfNZ	Rtos,Rtos			; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bNotSendStatus,&monFlags ; Move only bNotSendStatus from Rtos to monFlags
			ret

#if 0		// Not used now, and clashes with calibrate command
; Charging ( boolean -- )				; 1 when charging or regenning, 0 when driving
			; This lets the CMU include undertemperature and exclude undervoltage as stress when charging,
			; and when masterless-charging is enabled via the 'o' command, this command
			; start and stops charging.
			xCODE	'c',Charging,_Charging
			allBitsIfNZ	Rtos,Rtos			; IF Rtos is zero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bCharging,&monFlags ; Move only bCharging from Rtos to monFlags
			ret
#endif

#if MASTERLESS_CHARGING
; ChargerC(o)ntrol ( voltMin voltMax -- )
			; This command only makes sense for the last CMU/BMU in the string, with an adapter
			; from its fibre-optic output to the serial input of a PIP inverter/charger.
			; If voltMax is non-zero, whenever you get a '1c' command, run a PI controller on stress
			; to control a PIP inverter/charger at 2400 baud.
			; If voltMax is zero, disable charger control and go back to status sending at 9600 baud.
			; voltMin is minimum charger voltage in tenths of a volt.
			; voltMax is maximum charger voltage in tenths of a volt.
			; e.g. 480 584o<cr> for charger control between 48.0 and 58.4 volts, the PIP's maximum range
			; 0o<cr> to go back to status sending.
			xCODE	'o',ChargerControl,_ChargerControl
			mov		Rtos,&chargerVoltMax		; Set the maximum charger voltage
			tst		Rtos
			_IF		Z							; If the maximum is zero
				bic.b	#bChargerControl,&monFlags	; Clear the bChargerControl bit in monFlags
			_ELSE
				bis.b	#bChargerControl,&monFlags	; Set the bChargerControl bit in monFlags
				mov		Rsec,&chargerVoltMin		; Set the minimum charger voltage
			_ENDIF
			ret
#endif // MASTERLESS_CHARGING

; Rx state ( -- )
			xCODE	'R'|'x' <<8,RxState,_RxState ; 'Rx' collides with 'Rp' 'R0' 'Jx' 'Jp' 'J0'
			mov		#'R'|'x'<<8,Rthd		; Type is Rx state
			mov.b	&ticksSinceLastRx,Rsec	; Result in ticks
;			mov		#3,Rtos					; Print 3 digits
			br		#_prettyPrint3			; Tail-call pretty-print of 3 digits and return

; Error ratio ( -- )					; Fraction of packets received on CMU port with bad CRC12
			; Units are: bad packets per 65536 packets
			xCODE	'E'|'r' <<8,ErrorRatio,_ErrorRatio ; 'Er' collides with 'Eb' 'Ej' 'Ez' 'E2'
			mov		#'E'|'r'<<8,Rthd		; Command is Er
			mov		&errorRatio,Rsec		; Get low word of error ratio
			add		#$7FFF,Rsec				; Add only 7FFF for rounding, so can reach 0 and can't ovflo
			mov		&errorRatio+2,Rsec		; Get high word of error ratio
			adc		Rsec					; Do rounding
			mov		#5,Rtos					; Print 5 digits
			call	#_prettyPrint			; Call pretty-print
			ret

; Comms error ( -- )					; Report temporary master's ID
_commsError	; No command character since it never needs to be interpreted and 'c' is used for Charging
			mov		#'c',Rthd				; Type is comms error
			mov		#0,Rsec					; Zero value (so no minus sign)
			mov		#0,Rtos					; Send no digits of value (will get '$' if hex)
			br		#_prettyPrint			; Tail-call pretty-print and return

; Stress ( -- )							; Report local stress
			xCODE	'j',Stress,_Stress		; 'j' for just local stress (not the full status)
			mov		#'j',Rthd				; Type is stress
			mov.b	&localStatus,Rsec		; Get local status
			and.b	#STRESS,Rsec			; Extract stress level, 0 to 15
;			mov		#3,Rtos					; Print 3 digits
			br		#_prettyPrint3			; Tail-call pretty-print of 3 digits and return

; Status ( -- )							; Report global status if a BMU, else local status
			xCODE	'p',Status,_Status		; 'p' for pain since we've already used 's' for select
			push.b	&interpFlags			; Save present number base
			bis.b	#bHexOutput,&interpFlags ; Set to hexadecimal output
			mov		#'p',Rthd				; Type is stress
			cmp.b	#255,&ID
			_IF		EQ						; If BMU
				mov.b	&globalStatus,Rsec		; Get global status
			_ELSE
				mov.b	&localStatus,Rsec		; Get local status
			_ENDIF
			and.b	#$7F,Rsec				; Clear the high bit
;			mov		#3,Rtos					; Print 3 digits
			call	#_prettyPrint3			; Tail-call pretty-print of 3 digits and return
			popBits_B #bHexOutput,&interpFlags ; Restore number base
			ret

; Query worst stress ( minStressToShow -- )
			xCODE	'q',queryWorstStress,_queryWorstStress
			cmp.b	Rtos,&worstStress
			_IF		LO
				ret
			_ENDIF
			push.b	&interpFlags				; Save present number base
			bic.b	#bHexOutput,&interpFlags	; Set to decimal output

			DELAY_IF_NEEDED					; Allow time for CR to be echoed upstream if needed
			mov		#EXIT,R8				; Send initial slosh (EXIT command or comment character)
			call	#TxByteCk				; which stops rest of packet being interpreted

			mov.b	&ID,Rsec				; Emit the ID
			call	#_emitNum3				; as 3 digits

			mov		#ColonQspace,R10
			call	#TxStringCk

			mov.b	&worstStress,Rsec		; Emit worstStress
			mov		#2,Rtos					; as 2 digits
			call	#_emitNum
			mov		#' ',R8					; Space separator
			call	#TxByteCk

			ClearWatchdog

			; Now send the index of the following measurement that caused the worst stress
			mov.b	&worstStressType,Rsec	; Send index of following measurement that caused worst stress
			mov		#1,Rtos					; as 1 digit
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			; Now send the worst over-voltage
			mov		&worstOV,Rsec			; Send worst over-voltage
			call	#_emitNum4				; as 4 digits
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			ClearWatchdog

			; Now send the worst under-voltage
			mov		&worstUV,Rsec			; Send worst under-voltage
			call	#_emitNum4				; as 4 digits
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			; Now send the worst over-temperature
			mov		&worstOT,Rsec			; Send worst over-temperature
			mov		#2,Rtos					; as 2 digits
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			ClearWatchdog

			; Now send the worst under-temperature
			mov		&worstUT,Rsec			; Send worst under-temperature
			mov		#2,Rtos					; as 2 digits
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			; Now send the worst absolute link voltage
			mov		&worstAL,Rsec			; Send worst absolute link voltage
			call	#_emitNum4				; as 4 digits
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			call	#TxEndOfPacket

			popBits_B #bHexOutput,&interpFlags ; Restore number base
			ret
ColonQspace	DB		3, ':q '				; First byte is length of following string
			ALIGN	1

; Reset worst stress ( -- )
			xCODE	'{',resetWorstStress,_resetWorstStress ; Frowny mouth :-{ because irreversible
			clr.b	&worstStress
			clr.b	&worstStressType
			clr		&worstOV
			mov		#9999,&worstUV
			mov		#-99,&worstOT
			mov		#99,&worstUT
			clr		&worstAL
			ret

; Min  ( id type value -- ) ; Gives the minimum voltage, temperature, stress or worstStress
; and the ID of the cell
		xCODE	'<',min,_min
			NO_ECHO_CMD	doMin0,doMin			; Use the no-echo wrapper macro
doMin0:
		mov		#0,Rthd				; Default ID
		mov		Rtos,Rsec			; Type
		mov		#$7FFF,Rtos			; Default value infinity
doMin:	; Emit another Min command with its last parameter min-ed with the
		; relevant local value. The second parameter tells which type of local value, voltage or temp.
		; The first parameter gives the ID of the cell having the max value.
 		_CASE
			_OF_EQ #'v',Rsec
				call	#GetCellV		; Get cell voltage in millivolts in R10
				push	#4				; Save the field width, 4 digits
			_ENDOF
			_OF_EQ #'t',Rsec
				call	#GetTemp		; Get temperature in degrees Celsius in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF_EQ #'j',Rsec
				mov.b	&localStatus,R10 ; Get stress level in R10
				and.b	#STRESS,R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF_EQ #'q',Rsec
				mov.b	&worstStress,R10 ; Get worst stress level in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
		mov		#$7FFF,R10			; Default case, unknown type, set R10 to infinity
		push	#1					; Save the field width, 1 digit
		_ENDCASE

		cmp		Rtos,R10			; Find min of parameter and local value
		_IF		L
			mov		R10,Rtos
			mov.b	&ID,Rthd			; If new min, update ID
		_ENDIF

		push	Rtos				; Save value
		push	Rsec				; Save type

		mov		Rthd,Rsec			; Put ID into Rsec
;		mov		#3,Rtos				; Use a 3 digit field width
		call	#_emitNum3			; Transmit the ID as text in the present number base

		mov		#':',R8				; Transmit a colon, an alias for tick
		call	#TxByteCk

		pop		R8					; Pop and transmit the type, 'v', 't', 'j' or 'q'
		call	#TxByteCk

		mov		#' ',R8				; Transmit a space
		call	#TxByteCk

		pop		Rsec				; Pop the min value
		pop		Rtos				; Pop the field width
		call	#_emitNum			; Transmit the value as text in the present number base

		mov		#'<',R8				; Transmit a "<"
		call	#TxByteCk

		br		#TxEndOfPacket		; Tail-call TxEndOfPacket and return
;		ret

; Max  ( id type value -- ) ; Gives the maximum voltage, temperature, stress or worstStress
; and the ID of the cell
		xCODE	'>',max,_max
			NO_ECHO_CMD	doMax0,doMax	; Use the no-echo wrapper macro
doMax0:
		mov		#0,Rthd				; Default ID
		mov		Rtos,Rsec			; Type
		mov		#$8000,Rtos			; Default value neg infinity
doMax:	; Emit another Max command with its last parameter max-ed with the
		; relevant local value. The second parameter tells which type of local value, voltage or temp.
		; The first parameter gives the ID of the cell having the max value.
 		_CASE
			_OF_EQ #'v',Rsec
				call	#GetCellV		; Get cell voltage in millivolts in R10
				push	#4				; Save the field width, 4 digits
			_ENDOF
			_OF_EQ #'t',Rsec
				call	#GetTemp		; Get temperature in degrees Celsius in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF_EQ #'j',Rsec
				mov.b	&localStatus,R10 ; Get stress level in R10
				and.b	#STRESS,R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF_EQ #'q',Rsec
				mov.b	&worstStress,R10 ; Get worst stress level in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
		mov		#$8000,R10			; Default case, unknown type, set R10 to neg infinity
		push	#1					; Save the field width, 1 digit
		_ENDCASE

		cmp		R10,Rtos			; Find max of parameter and local value
		_IF		L
			mov		R10,Rtos
			mov.b	&ID,Rthd			; If new max, update ID
		_ENDIF

		push	Rtos				; Save value
		push	Rsec				; Save type

		mov		Rthd,Rsec			; Put ID into Rsec
		call	#_emitNum3			; Transmit the ID as text in the present number base

		mov		#':',R8				; Transmit a colon, an alias for tick
		call	#TxByteCk

		pop		R8					; Pop and transmit the type, 'v', 't', 'j' or 'q'
		call	#TxByteCk

		mov		#' ',R8				; Transmit a space
		call	#TxByteCk

		pop		Rsec				; Pop the max value
		pop		Rtos				; Pop the field width
		call	#_emitNum			; Transmit the value as text in the present number base

		mov		#'>',R8				; Transmit a ">"
		call	#TxByteCk

		br		#TxEndOfPacket		; Tail-call TxEndOfPacket and return
;		ret


; Thresholds  ( stress0Voltage step 'V -- ) or (alarmStress 'aTh -- ) or
; (bypassVoltage 'b -- ) or (fullVoltage 'f -- ).
; Power-on defaults are equivalent to 3130 40'VTh  12'aTh  3410'bTh  3450'fTh (setpoint 7)
; Possible alternative                3330 20'Vth  13'aTh  3410'bTh  3400'fTh (setpoint 4)
		xCODE	'T'|'h' <<8,thresholds,_thresholds	; 'Th' collides with 'Tp' 'Tx' 'Lh' 'Lp' 'Lx'
 		_CASE
			_OF_EQ	#'V',Rtos			; Set overvoltage zero and step
				mov.b	Rsec,&ovStep		; ovStep = Rsec
				mov		Rthd,&ovZero		; ovZero = Rthd
			_ENDOF
			_OF_EQ	#'a',Rtos			; Set alarm stress and BMU contactor-dropout stress
				mov.b	Rsec,&alarmStress	; alarmStress = Rsec
			_ENDOF
			_OF_EQ	#'b',Rtos			; Set bypass voltage
				mov		Rsec,&bypassVoltage	; bypassVoltage = Rsec
			_ENDOF
			_OF_EQ	#'f',Rtos			; Set full voltage
				mov		Rsec,&fullVoltage	; fullVoltage = Rsec
			_ENDOF
		_ENDCASE
		ret


; Current (tenths-of-an-amp -- ) // Sent by BMU to CMUs
		xCODE	'i',Current,_Current
		cmp.b	#255,&ID
		_IF	NE							; If we're not a BMU
			mov		Rtos,&current			; Set the current
		_ENDIF
		clr.b	&ticksSinceLastI		; Zero ticks since last 'i' command
		ret

; Store discharge counter high word (dischargeHi -- )
		; Sent periodically by BMU to CMU 1, and sent by CMU 1 to BMU on receiving a 'G' command.
		; The BMU uses the CMU as battery-backed-up RAM to store the approximate depth of discharge so
		; it can restore it after the monolith has been shut down and hence BMU has been powered down.
		xCODE	'Z',ZtoreDischarge,_ZtoreDischarge
		mov		Rtos,&discharge+2		; Set the discharge counter high word to the received value
		ret

; Get discharge counter high word ( -- )
		; Sent by BMU to CMU 1 when BMU is reset. Sends a 'Z' command back to the BMU with the
		; high byte of the discharge counter.
		xCODE	'G',GetDischarge,_GetDischarge
		mov		#SelectBMU,R10			; Transmit "255s" to select the BMU only
		call	#TxStringCk
		ClearWatchdog

		mov		&discharge+2,Rsec
		mov		#5,Rtos					; 5 digit field width
		push.b	&interpFlags			; Save number base
		bis.b	#bHexOutput,&interpFlags; Set to hexadecimal output
		call	#_emitNum				; Transmit the number
		popBits_B #bHexOutput,&interpFlags ; Restore number base
		ClearWatchdog

		mov		#'Z',R8					; Transmit a "Z" for ZtoreDischarge
		call	#TxByteCk
		br		#TxEndOfPacket			; Tail-call TxEndOfPacket and return
;		ret

SelectBMU	DB	4, '255s'				; First byte is length of following string
			ALIGN	1

; Get state of charge ( -- )
		xCODE	'f',fuelSoc,_fuelSoc
		cmp.b	#255,&ID
		_IF		EQ						; BMUs only
			call	#DepthOfDischarge		; Get the depth of discharge as a number 0-1000 in R9
			mov		#'f',Rthd				; Type is fuel gauge (state of charge)
			mov		#1000,Rsec				; 100% - DOD = SOC
			sub		R9,Rsec					; SOC in tenths of a percent
			_IF		N						; If result is negative,
				clr		Rsec					; then saturate at zero
			_ENDIF
			mov		#4,Rtos					; Use 4 digits
			call	#_prettyPrint			; Call pretty-print
		_ENDIF
		ret

;
; GetFiltOcCellVolt ( -- )
; Transmit the filtered estimated open circuit cell voltage in millivolts (0 to 4348 mV)
;
		xCODE	'O',GetFiltOcCellVolt,_GetFiltOcCellVolt
		mov		&ocCellVoltX256+2,R9; Get upper word into R9
		mov		&ocCellVoltX256+0,R8; Get lower word into R8
		add		#128,R8				; Add half the divisor for rounding
		adc		R9
		rra8_l	R9,R8				; Divide by 256
		mov		R8, Rsec			; Number to print
		mov		#'O',Rthd			; Command being responded to is 'O'
		mov		#4,Rtos				; Use 4 digits
		call	#_prettyPrint		; Call pretty-print
		ret

;
; GetHiResFiltOcCellVolt ( -- )
; Transmit the filtered estimated open circuit cell voltage in 1/16ths of a millivolt (0 to 65535 mV/16)
; Voltages of 4096 to 4350 mV will wrap around and appear as voltages slightly greater than zero
;
		xCODE	'o',GetHiResFiltOcCellVolt,_GetHiResFiltOcCellVolt
		mov		&ocCellVoltX256+2,R9; Get upper word into R9
		mov		&ocCellVoltX256+0,R8; Get lower word into R8
		add		#8,R8				; Add half the divisor for rounding
		adc		R9
		REPT	4					; Unsigned divide by 16
			clrc
			rrc		R9
			rrc		R8
		ENDR
		mov		R8, Rsec			; Number to print
		mov		#'o',Rthd			; Command being responded to is 'O'
		mov		#6,Rtos				; Use 5 digits unsigned
		call	#_prettyPrint		; Call pretty-print
		ret

;
; GetOcCellVolt ( -- )
; Transmit the estimated open circuit cell voltage in millivolts (0 to 4348 mV)
;
		xCODE	'W',GetOcCellVolt,_GetOcCellVolt
		mov		&ocCellVolt,Rsec	; Get estimated open circuit cell voltage
		mov		#'W',Rthd			; Command being responded to is 'W'
		mov		#4,Rtos				; Use 4 digits
		call	#_prettyPrint		; Call pretty-print
		ret


; Send PIP command ( c-addr u u2 -- )
		; BMU only.
		; Send the string given by pointer c-addr and length u, out of one or both of the Chg ports,
		; as specified by u2 values of 1 = Chg1 only, 2 = Chg2 only, 3 = both.
		xCODE	'P'|'p' <<8,PipCommmand,_PipCommand ; 'Pp' collides with 'Ph' 'Px' 'Xh' 'Xp' 'Xx'
		cmp.b	#255,&ID
		_IF	EQ							; If I'm a BMU
			; Temporarily disable the timer functions of all Chg pins
			bic.b	#TxMiChg|TxMiChg2|RxChg|RxChg2,&ChgPortSEL
			bit		#2,Rtos
			_IF		NZ
				; Enable the timer function of the TxChg2 and RxChg2 pins
				bis.b	#TxMiChg2|RxChg2,&ChgPortSEL
				bis		#CCIS0,&ChgCCTLr		; Select input B for charger capture compare register
			_ENDIF
			bit		#1,Rtos
			_IF		NZ
				; Enable the timer function of the TxChg and RxChg pins
				; This comes last so if sending to both ports, we receive from RxChg, not RxCgh2
				bis.b	#TxMiChg|RxChg,&ChgPortSEL
				bic		#CCIS0,&ChgCCTLr		; Select input A for charger capture compare register
			_ENDIF

			push		&TxBytePtr			; Save the present Tx pointer
			mov			#ChgTxByte,&TxBytePtr ; Point the Tx pointer at the charge ports
			mov			Rthd,R10
			mov			Rsec,R11
			call		#TxStringCrcS		; Send string pointed to by R10, len R11. Trashes R8 thru R11
			call		#TxCrc				; Send the two bytes of CRC and clear it
			mov.b		#$0D,R8
			call		#TxByte				; Send the carriage return without accumulating CRC
			pop			&TxBytePtr			; Set the Tx pointer back to what it was
		_ENDIF
		ret


; Send a PIP command with no CRC, e.g. "PFTY5200"1Pw  ( c-addr u u2 -- )
		; BMU only.
		; Send the string given by pointer c-addr and length u, out of one or both of the Chg ports,
		; as specified by u2 values of 1 = Chg1 only, 2 = Chg2 only, 3 = both.
		xCODE	'P'|'w' <<8,PipCmdNC,_PipCmdNC ; 'Pw' collides with 'Po' 'Pg' 'Xw' 'Xo' 'Xg'
		cmp.b	#255,&ID
		_IF	EQ							; If I'm a BMU
			; Temporarily disable the timer functions of all Chg pins
			bic.b	#TxMiChg|TxMiChg2|RxChg|RxChg2,&ChgPortSEL
			bit		#2,Rtos
			_IF		NZ
				; Enable the timer function of the TxChg2 and RxChg2 pins
				bis.b	#TxMiChg2|RxChg2,&ChgPortSEL
				bis		#CCIS0,&ChgCCTLr		; Select input B for charger capture compare register
			_ENDIF
			bit		#1,Rtos
			_IF		NZ
				; Enable the timer function of the TxChg and RxChg pins
				; This comes last so if sending to both ports, we receive from RxChg, not RxCgh2
				bis.b	#TxMiChg|RxChg,&ChgPortSEL
				bic		#CCIS0,&ChgCCTLr		; Select input A for charger capture compare register
			_ENDIF

			push		&TxBytePtr			; Save the present Tx pointer
			mov			#ChgTxByte,&TxBytePtr ; Point the Tx pointer at the charge ports
			mov			Rthd,R10
			mov			Rsec,R11
			call		#TxBytes			; Send string pointed to by R10, len R11. Trashes R8-R11
											; No calculation or sending of CRC
			mov.b		#$0D,R8
			call		#TxByte				; Send the carriage return without accumulating CRC
			pop			&TxBytePtr			; Set the Tx pointer back to what it was
		_ENDIF
		ret

; Some characters need to be translated into RAM adresses of calibration values
		ALIGN	1
calAddressTable
		DB		'b' , infoBypFull	& $7F | $00
		DB		'a' , infoAdcTimIdx & $7F | $00
		DB		'I' , infoBoltMiCal	& $7F | $80
		DB		's' , infoTempSlope	& $7F | $80
		DB		'O' , infoBoltPlOff	& $7F | $00
		DB		'o' , infoCellOff	& $7F | $00
		DB		'c' , infoCapacity	& $7F | $80
		DB		'r' , infoCellRes	& $7F | $80
		DB		'V' , infoBoltPlCal	& $7F | $80
		DB		'v' , infoCellCal	& $7F | $80	; High bit set to indicate word quantity,
		DB		't' , infoTempOff	& $7F | $00	; clear for byte quantity
		DB		'n' , infoBoltMiOff	& $7F | $00
		DB		'i' , infoID		& $7F | $00
		DB		'd' , infoDataVers	& $7F | $00	; Data vers is not for writing
; Zero must not appear in the table as it is used to represent "unrecognised".
sizeCalAddressTable	EQU	$-calAddressTable

;
; TranslateToCalAddr ( ch -- addr )
;
TranslateToCalAddr:
		; Do the calibration address translations using the table above
		mov		#sizeCalAddressTable,R9 ; Initialise the loop counter and table index
		_REPEAT				; Begin loop
			mov.w	calAddressTable-2(R9),R10 ; Get two bytes from the table
			cmp.b	R10,Rtos	; Compare the address character with the low byte from the table
			_WHILE	NE			; While no match [ _WHILE xx = _IF xx  _CS_SWAP ]
				decd	R9			; Decrement loop-counter/table-index by 2
		_UNTIL	Z			; Until loop counter is zero
		clr		Rtos		; Finished loop with no match so set result to zero for "unrecognised"
			_ELSE				; Else there is a match so
				swpb	R10			; Get the high byte from the table
				mov.b	R10,Rtos	; Substitute it for the address character
			_ENDIF				; Endif match
		ret

;
; A worker routine for voltage calibration. We do this twice now for cell/battery and bolt/array
;

; The calibration scale factor will be the expected value divided by the reading.
; The expected value is an unsigned 12 bit integer of millivolts and
; the reading is an unsigned 12.2 bit fixed-point number of millivolts.
; We want the calibration scale factor to be represented as an unsigned 1.15 fixed-point number
; i.e. a number with 1 integer bit and 15 fractional bits.
; So we shift the expected value 17 places left before the division.
; R8 contains the measurement possibly scaled by 17/16
; R9 contains the relevant (cell or array/bolt) offset correction as a signed byte
; The cal value is returned in R9
voltScaleWork:
			sxt		R9							; Convert from signed byte to signed word
			add		R9,R8						; Perform offset correction, but not scale correction
			call	#ApplyTempCo				; Apply the temperature correction
			clr		R9							; 16 bits of zeroes
			mov		Rsec,R10
			rla		R10							; 17 zeroes; we have value << 17 in R10:R9
			mov		R8,R11						; The divisor is the voltage reading in R8
			rra		R11							; Add half the divisor to the dividend for rounding
			add		R11,R9
			adc		R10
			call	#UMSlashMod					; Gives quotient in R9, remainder in R10
			; R9 has the value we want to store
			ret

;
; Calibrate ( n ch --- )
; Perform a calibration whose type is ch ('v for voltage etc) and value is n
; For the voltage scale and offset calibrations, we want to apply the other correction (i.e. scale if
; we are calibrating offset, and vice versa) to get the best correction so far. This also allows for
; successive improvement calibration if that turns out to be useful.
;
			xCODE	'c',calibrate,_calibrate
			_CASE
			_OF_EQ_B	#'v',Rtos				; 'v': Cell voltage scale factor
				mov		&cellVRaw, R8				; 12.2 fixed-point result in R8
				call	#Mul17Div16Cmu				; Scale by 17/16 if we're not a BMU
				mov.b	&CellOff,R9					; This is the offset correction to use
				call	#voltScaleWork
				mov.w	R9,R8						; Get the calibration value into R8
				mov		#1,R9						; Save it as a word value
				mov		#infoCellCal,R10			; Save it as the cell scale factor
				call	#UpdFlash					; Save the R8 calibration value to info-flash
			_ENDOF

			_OF_EQ_B	#'V',Rtos				; 'V': Bolt+/Array voltage scale factor
				mov		&boltVPlRaw,R8				; Get raw 12.2 bit fixed point measurement in R8
				call	#Mul17Div16Cmu				; Scale by 17/16 if we're not a BMU
				mov.b	&BoltPlOff,R9				; This is the offset correction to use
				call	#voltScaleWork
				mov.w	R9,R8						; Get the calibration value into R8
				mov		#1,R9						; Save it as a word value
				mov		#infoBoltPlCal,R10			; Save it as the cell scale factor
				call	#UpdFlash					; Save the R8 calibration value to info-flash
			_ENDOF

			_OF_EQ_B	#'o',Rtos				; 'o': Cell voltage offset
				mov		&cellVRaw, R8				; 12.2 fixed-point result in R8
				call	#Mul17Div16Cmu				; Scale by 17/16 if we're not a BMU
				mov		&CellCal,R9					; Use this voltage scale for correction
				call	#Fx1_15UMul					; Correct for scale but not offset
				sub		R8,Rsec						; Calculate offset (expected - measured)
				mov.b	Rsec,R8						; Get the calibration value into R8
				mov		#0,R9						; Save it as a byte value
				mov		#infoCellOff,R10			; Save it as the cell offset
				call	#UpdFlash					; Save the R8 calibration value to info-flash
			_ENDOF

			_OF_EQ_B	#'O',Rtos				; 'O': Bolt+/Array voltage offset
				mov		&boltVPlRaw,R8				; Get raw 12.2 bit fixed point measurement in R8
				call	#Mul17Div16Cmu				; Scale by 17/16 if we're not a BMU
				mov		&BoltPlCal,R9				; Use this voltage scale for correction
				call	#Fx1_15UMul					; Correct for scale but not offset
				sub		R8,Rsec						; Calculate offset (expected - measured)
				mov.b	Rsec,R8						; Get the calibration value into R8
				mov		#0,R9						; Save it as a byte value
				mov		#infoBoltPlOff,R10			; Save it as the bolt plus offset
				call	#UpdFlash					; Save the R8 calibration value to info-flash
			_ENDOF

			_OF_EQ_B	#'t',Rtos				; 't': Temperature offset
				call	#GetTemp					; Get calibrated temp in half degC into R9
				mov.b	&TempOff,R8					; Subtract off our existing offset calibration
				sxt		R8
				sub		R8,R9
				push	R9							; Save uncalibrated measurement in half degrees
				; Rsec is supplied in tenths of a degree now. Div by 5 to get half degrees
				mov		#0,R10						; Put Rsec into R10:R9 as dividend
				mov		Rsec,R9
				add		#2,R9						; Add 2 for rounding
				mov		#5,R8						; Divide by 5 to bring to half degrees
				call	#UMSlashMod					; Result in R9
				pop		R8							; Restore uncal'd measurement
				sub		R8,R9						; Subtract measured half degrees from calibration
													; (expected) temperature
				mov.b	R9,R8						; Get the calibration value into R8
				mov		#0,R9						; Save it as a byte value
				mov		#infoTempOff,R10			; Save it as the temperature offset
				call	#UpdFlash					; Save the R8 calibration value to info-flash
			_ENDOF

			_OF_EQ_B	#'n',Rtos				; 'n': Bolt-/Shuntx20 voltage offset. Was "link" offset
				call	#MeasAndCorrBoltMi			; Measure and correct using the BoltMi corrections
				mov.b	&BoltMiOff,R9				; Subtract the existing offset (signed byte)
				sxt		R9
				sub		R9,R10
				sub		#2046,R10					; Zero volts is a 2046 reading

				; Multiply Rsec (signed) by 1.364
				push 	R10
				mov		Rsec,R8
				mov		#44696,R9					; ~= 1.364 * 2^15
				call	#MMStar						; Signed R10:R9 = signed R8 * unsigned R9
				add		#$4000,R9					; Add half the divisor for rounding
				adc		R10
				rla		R9							; To divide by 2^15, mult by 2 and keep the hi word
				rlc		R10
				mov		R10,Rsec
				pop		R10

				sub		Rsec,R10					; Subtract required reading * 1.364
				neg		R10
				_COND								; Start a short-circuit conditional
					cmp		#-$7F,R10					; Compare with -$7F
				_OR_ELSE	L						; If < -$7F
					cmp		#$80,R10					; Compare with $80
				_OR_IFS		GE						; or >= $80
					mov		#$80,R10					; Use $80 to indicate "not calibrated"
				_ENDIF
				mov.b	R10,R8						; Get the calibration value into R8
				mov		#0,R9						; Save it as a byte value
				mov		#infoBoltMiOff,R10			; Save it as the bolt minus offset
				call	#UpdFlash					; Save the R8 calibration value to info-flash
			_ENDOF

			_OF_EQ_B	#'i',Rtos
				; When preceded by XOFF (ctrl-S) and the desired first ID in decimal,
				; and followed by <cr> XON (ctrl-Q), it sets consecutive IDs in consecutive CMUs
				; and responds with the ID _after_ the last ID.
				cmp.b	#255,&ID
				_IF		EQ					; But if we're a BMU,
					ret							; silently ignore; BMUs have to stay ID=255
				_ENDIF
				bit.b	#bDontEcho,&interpFlags
				_IF		NZ					; If the dont-echo flag is set
					; Save our new ID to info-flash
					mov.b	Rsec,R8				; New value
					mov		#0,R9				; Size = byte
					mov		#infoID,R10			; Address of info-flash item
					call	#UpdFlash

					; Send another setIDs command with its parameter incremented by one.
					mov		Rsec,Rtos
					inc		Rtos				; Increment the parameter
					DPUSH	#3					; Use a 3 digit field width
					call	#_emitNum			; Transmit the number as text in the current number base

					mov		#TickIcStr,R10			; Transmit a 'ic
					call	#TxStringCk
					call	#TxEndOfPacket
				_ELSE						; Else dont-echo flag is clear
					; Send \? to remind user that Ctrl-S needs to be sent before an 'ic command.
					jmp		EmitQmark
				_ENDIF
				ret			; Don't fall through to _readCalValue
			_ENDOF

			_OF_EQ_B	#'a',Rtos				; 'a': optimal ADC timing, with debug display
				call	#FindOptAdc					; Find the optimum ADC clock. Get index in R10
				push 	R10							; Save the ADC timing index
				sub		#2*NumAdcClocks,SP			; Recover the devThisIdx array from FindOptAdc

				mov		#'M'|'2'<<8,Rthd			; M2 for MCLK/2
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'O'|'2'<<8,Rthd			; O2 for ADCOSC/2
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'O'|'3'<<8,Rthd			; O3 for ADCOSC/3
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'O'|'4'<<8,Rthd			; O4 for ADCOSC/4
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

 				mov		#'O'|'5'<<8,Rthd			; O5 for ADCOSC/5
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'O'|'6'<<8,Rthd			; O6 for ADCOSC/6
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'O'|'7'<<8,Rthd			; O7 for ADCOSC/7
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'O'|'8'<<8,Rthd			; 08 for ADCOSC/8
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'M'|'3'<<8,Rthd			; M3 for MCLK/3
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'M'|'4'<<8,Rthd			; M4 for MCLK/4
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'M'|'5'<<8,Rthd			; M5 for MCLK/5
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'M'|'6'<<8,Rthd			; M6 for MCLK/6
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'M'|'7'<<8,Rthd			; M7 for MCLK/7
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov		#'M'|'8'<<8,Rthd			; M8 for MCLK/8
				pop		Rsec
				mov		#5,Rtos
				call	#_prettyPrint

				mov.b	#'a',Rtos					; Restore the calibration-type character

				pop		R10							; Restore the ADC timing index
				mov.b	AdcTimingTbl(R10),R9		; Get byte value from table
				mov.b	R9, chanList+0				; Store it for each conversion channel
				mov.b	R9, chanList+2
				mov.b	R9, chanList+4
				mov.b	R9, chanList+6


				mov.b	&AdcTimIdx,R8				; Keep the existing TestICal timing in the LS nibble
				and.b	#$0F,R8
				rla4	R10							; Put the new Monolith timing in the MS nibble
				or_b	R10,R8						; Get the calibration value into R8
				mov		#0,R9						; Save it as a byte value
				mov		#infoAdcTimIdx,R10			; Save it as the ADC timing index
				call	#UpdFlash					; Save the R8 calibration value to info-flash
				; Fall through to readCalValue to display the winner
			_ENDOF
;
; Default case
				jmp		EmitQmark					; Unknown calibration type character

			_ENDCASE

			;jmp		_readCalValue			; Display the value just calibrated and return
												;	(by falling through)
			;
			; Keep 'c' command (above) and 'r' command (below) together
			; That is, don't insert a new command here
			;
;
; Read calibration value ( ch --- )
; Calibration type (e.g. 'v' for cell Voltage) in ch
			xCODE	'r',readCalValue,_readCalValue
			call 	#TranslateToCalAddr		; Convert letter to byte/word flag and low 7 bits of address
			mov.b	Rtos,Rsec				; Copy to Rsec
			bic.b	#$80,Rsec				; Strip the byte/word flag
			or_w	#infoDataStart&$FF80,Rsec ; OR the upper 9 bits to make it an info-flash address
			tst.b	Rtos
			_IF		NZ						; If not zero (zero means "unrecognised")
				push.b	&interpFlags			; Save present number base
				_IF		NN						; If high bit clear it's a byte
					mov		#3,Rtos					; Display 3 digits
					cmp		#infoAdcTimIdx+1,Rsec	; Test for ADC timing index or BypFull
					mov.b	@Rsec,Rsec				; Get byte sized cal value
					_IF		LO						; If we're reading ADC timing index or BypFull
						bis.b	#bHexOutput,&interpFlags ; Set to hexadecimal output
					_ENDIF
				_ELSE							; Else high bit set so it's a word
					mov		#5,Rtos					; Display 5 digits
					cmp		#infoCapacity,Rsec		; Test for battery capacity
					mov.w	@Rsec,Rsec				; Get word sized cal value
					_IF		EQ						; If we're reading capacity
						mov		Rsec,R9
						clr		R10
						mov		#10,R8					; Divide by 10 to bring to whole Ah
						call	#UMSlashMod				; R10:R9 / R8 -> R9
						mov		R9,Rsec
					_ENDIF
				_ENDIF							; Endif high bit set
				mov.b		#' ',Rthd			; Cmd type char (space). May be r or c command
				call	 	#_prettyPrint
				popBits_B	#bHexOutput,&interpFlags ; Restore previous number base
			_ELSE 							; Else is zero for "unrecognised"
EmitQmark
				mov		#QuestionStr,R10
				br		#TxString			; Print \? <ret> and exit
			_ENDIF							; Endif unrecognised
			ret

QuestionStr	DB			3,'\\?\r'			; Initial \ because '?' is a peek command
TickIcStr	DB			3,'\'ic'			; 'ic command to send downstream


;
; Write calibration value ( n ch --- )
;
; n is value to write. ch is calibration type (e.g. 'v for cell Voltage).
;
; Note: For the 'rw command, a ballpark estimate of LiFePO4 resistance in microohms would be 144000
; divided by the capacity in amp hours.
; Alternatively cell resistance can be measured as the change in battery voltage
; divided by the step change in current that caused it, divided by the number of cells.
; To obtain "HiTempCellRes", the measured cell resistance should be divided by
; 1 + 2^(1-T/10) where T is the cell temperature at which the measurement was made.
; e.g. at 20 degC, divide the measurement by 1.5 to obtain HiTempCellRes.
; e.g. at 25 degC, divide the measurement by 1.35 to obtain HiTempCellRes.
; e.g. at 30 degC, divide the measurement by 1.25 to obtain HiTempCellRes.

			xCODE	'w',writeCalValue,_writeCalValue
		_COND
			cmp.b	#'d',Rtos				; Don't allow data version to be changed like this
		_AND_IF	NE
			_COND
				cmp.b	#'i',Rtos				; Write an ID ?
			_OR_ELSE	NE
				cmp.b	#255,&ID				; BMUs have to stay ID=255
			_OR_IFS		NE

			call 	#TranslateToCalAddr		; Convert letter to byte/word flag and low 7 bits of address
			mov.b	Rtos,R10				; Copy to R10
			bic.b	#$80,R10				; Strip the byte/word flag
			or_w	#infoDataStart&$FF80,R10 ; OR the upper 9 bits to make it an info-flash address

			cmp		#infoCapacity,R10
			_IF		EQ						; If we're writing battery capacity
				rla		Rsec					; Multiply given value by 10
				mov		Rsec,R8					; to bring to tenths of an Ah
				rla2	Rsec					; *8
				add		R8,Rsec					; *10
			_ENDIF

			_COND							; If we're writing cell or bolt+ voltage scale cal constant
				cmp		#infoCellCal,R10
			_OR_ELSE EQ
				cmp		#infoBoltPlCal,R10
			_OR_IFS	EQ
				_COND							; If Rsec is between -30 and 30 inclusive
					cmp		#30+1,Rsec
				_AND_IF	L
					cmp		#-30,Rsec
				_AND_IF GE
					rla		Rsec					; Multiply Rsec by 10
					mov		Rsec,R8
					rla2	Rsec
					add		R8,Rsec
					add		@R10,Rsec				; Add the existing value of the cal constant to Rsec
				_ELSES							; Else
					cmp		#'v',Rsec				; If Rsec is 'v
					_IF		EQ
						mov		&infoCellCal,Rsec		; Set Rsec to the cell voltage scale cal const
					_ENDIF							; Endif
				_ENDIF							; Endif
			_ENDIF							; Endif

			tst.b	Rtos
			_IF		NZ						; If not zero for "unrecognised"
				_IF		NN						; If high bit clear
					mov		#0,R9					; Indicate byte sized cal value
				_ELSE							; Else high bit set so
					mov		#1,R9					; Indicate word sized cal value
				_ENDIF							; Endif high bit
				mov		Rsec,R8					; Data to be written
				call	#UpdFlash			; Write new value to flash
			_ELSE 							; Else is zero for "unrecognised"
				jmp		EmitQmark
			_ENDIF							; Endif unrecognised
			ret
		_ELSES
				jmp		EmitQmark
		_ENDIF

;
;
; Update a single word or byte into info-flash. Note that this is NOT a command definition;
; we can't have a bare "u" command in monolith, and there are no RAM copies to update from.
; R8 has new info value
; R9 is 1 for word, 0 for byte
; R10 has address of the flash word to be written
; Trashes R11, R12
;
			; Prepare to flash-program
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz

UpdFlash:
			sub		#infoDataEnd-infoDataStart,SP ; Allocate space on stack for info flash bytes
			mov		SP,R11					; Copy start of buffer to R10
			clr		R12						; Loop counter
			_REPEAT
				mov.b	infoDataStart(R12),0(R11)	; Copy a byte from info-flash to stack
				inc		R11
				inc		R12
				cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	EQ						; Loop until ramDataEnd

			add		SP,R10					; R10 points infoDataStart past RAM equivalent
			tst		R9
			_IF		NZ
				mov.w	R8,-infoDataStart(R10)		; Copy new info word to RAM equivalent
			_ELSE
				mov.b	R8,-infoDataStart(R10)		; Copy new info byte to RAM equivalent
			_ENDIF

			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Hold Watchdog Timer
			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1

			; Erase appropriate info flash segment.
			mov		#FWKEY,&FCTL3			; Clear LOCK
			mov		#FWKEY+ERASE,&FCTL1		; Enable single segment erase

			rra		&infoDataStart			; Dummy write: Start of cal data in info-flash

			mov		#FWKEY+WRT,&FCTL1		; Enable write (can leave on; only write block that can't)

			clr		R12						; Loop counter
			mov		SP,R10					; Point to start of RAM copy
			_REPEAT
				mov.b	@R10+,infoDataStart(R12)	; Write a byte to info-flash
				inc		R12
				cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	EQ						; Loop until ramDataEnd

			mov		#FWKEY,&FCTL1			; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3		; Set LOCK
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart watchdog timer
			;
			; Check that the flash programming worked
			;
			call	#compareInfoFlash		; Compare RAM cal data with what's in infoflash
			mov		#1+4+1,R11				; String length
			_IF		NE
				mov		#sFail,R10
			_ELSE
				mov		#sDone,R10
			_ENDIF
			add		#infoDataEnd-infoDataStart,SP ; Deallocate stack buffer; OK to modify flags
			br		#TxBytes			; Send string pointed to by R10, len R11. Trashes R8-R11
			;ret

sFail		db		'\\FAIL\r'
			ALIGN	1
sDone		db		'\\Done\r'
			ALIGN	1

;
; Compare the ~20 bytes of calibration data at 2(SP) with what's at infoDataStart (in info-flash).
; Returns with Z set if OK, Z clear if not.
; Trashes R10, R12
compareInfoFlash:
			mov		SP,R10
			incd	R10					; Skip return address
			clr		R12					; Loop counter
			_REPEAT
				cmp.b	@R10+,infoDataStart(R12)
				_WHILE	EQ ; Z
					inc		R12
					cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	EQ					; Loop until we get to infoDataEnd
				_ENDIF
			; The increment will have set Z if all compares well. The cmp will have cleared Z otherwise.
			ret

;
; Determine the best ADC clock value for this CMU when running Monolith.
; Assumes the CMU is bolted to a cell carrying no current so v and V measure a constant voltage.
; Can be used for BMUs if v and V (HazBat & HazArr) are measuring a constant voltage of 48 V or more.
; Trashes R8-12, R13, R15
;
FindOptAdc:

; Local variable stack pointer offsets
actCellV	EQU		0					; Our best guess of the actual cell voltage, which is the
										; average of 256 measurements using GetCellV and MCLK/3
										; Also used as a 32-bit sum of these values to find the average
										; The deviations from this are used to determine the noise
devThisIdx	EQU		4					; Array of total deviation word-sized results

; Conditional assembly used during testing
#define		USE_CELLV 0					; Set this if you want to use CellV instead of BoltPlV
										; We normally use BoltPlV because it is more noisy
numMeasures	EQU		16					; How many measurements to make with each clock. A power of 2.
logNumMeas	EQU		4					; Base 2 log of the above. 'ac takes 0.6 seconds per measure.

			sub		#4+2*NumAdcClocks,SP	; Make space for locals
			mov		SP,R9
			_FOR	#2+NumAdcClocks,R12
				clr		0(R9)				; Clear locals
				incd	R9
			_NEXT_DEC	R12
			; Measure using the timing that has the lowest worst-case noise for monolith
#if USE_CELLV
			mov.b	&AdcTimingTbl+0,&chanList+4	; Temporarily change the CellV ADC timing
#else
			mov.b	&AdcTimingTbl+0,&chanList+0	; Temporarily change the BoltPlV ADC timing
#endif
			_FOR	#numMeasures,R12	; Do this many measurements
				; We use BoltPlV because it is a noiser measurement than CellV,
				; because its track on a CMU runs parallel to some noisy other tracks.
				; We used to use CellV here, but we need to use the same measurement we use below
				; in case they have different readings e.g. because they are calibrated differently.
#if USE_CELLV
				call	#GetCellV			; Little-v is less noisy
#else
				call	#GetBoltPlV			; Big-V is more noisy
#endif
				add		R10,actCellV(SP)	; Accumulate sum
				adc		actCellV+2(SP)		; as 32-bit
				mov		#40,R8				; Wait 40 ms for next measurement
				call	#DelayMs
			_NEXT_DEC	R12
			; Find the average
			mov		actCellV+2(SP),R10	; Get sum into R10:R9
			mov		actCellV(SP),R9
			add		#numMeasures/2,R9	; Rounding
			adc		R10
#if logNumMeas == 8
			rra8_l	R10,R9				; Shift longword right 8 bits using macro, to divide by 256
#else
		REPT	logNumMeas				; Shift longword right the required number of bits
			clrc						; Unsigned
			rrc		R10
			rrc		R9
		ENDR
#endif
			mov		R9,actCellV(SP)		; Save average cell voltage as the actual word value in mV
			; We want the best total deviation from the "actual" cell voltage. We use the total
			; rather than the worst deviation since we've observed some infrequent large errors, and
			; others with frequent almost-as-large errors. We want to penalise the frequent errors more.
			; Take 256 measurements, and sum their deviations from actual in sumOfDev. We don't bother
			; dividing by 256, so there won't be an overflow of 16 bits unless the average error is
			; 256 mV or more.
			clr		R15					; R15 will range 0 to NumAdcClocks-1
			mov		SP,R13
			add		#devThisIdx,R13		; R13 points to the start of the devThisIdx array
			_REPEAT
#if USE_CELLV
				mov.b	AdcTimingTbl+1(R15),&chanList+4	; Use this ADC timing for CellV
#else
				mov.b	AdcTimingTbl+1(R15),&chanList+0	; Use this ADC timing for BoltPlV
#endif
				_FOR	#numMeasures,R12	; Do this many measurements
					; We use BoltPlV because it is a noiser measurement than CellV,
					; because its track on a CMU runs parallel to some noisy other tracks.
#if USE_CELLV
					call	#GetCellV			; Little-v is less noisy
#else
					call	#GetBoltPlV			; Big-V is more noisy
#endif
					sub		actCellV(SP),R10	; Get deviation from average
					abs		R10					; Don't care if pos or neg
					add		R10,0(R13)			; Accumulate the sum of the deviations into the array
					mov		#40,R8				; Wait 40 ms for next measurement
					call	#DelayMs
				_NEXT_DEC	R12
				incd	R13					; Point to next array entry
				inc		R15					; Next index
				cmp		#NumAdcClocks,R15
			_UNTIL	EQ
#if USE_CELLV
			mov.b	&chanList+0,&chanList+4	; Restore ADC timing for CellV
#else
			mov.b	&chanList+4,&chanList+0	; Restore ADC timing for BoltPlV
#endif
			; Now find the quietest result
			clr		R15
			mov		#-1,R10				; Default winner
			mov		#$FFFF,R8			; Worst so far
			mov		SP,R13
			add		#devThisIdx,R13		; R13 points to start of devThisIdx array
			_REPEAT
				cmp		@R13+,R8			; Compare lowest so far with table
				_IF		HS					; If the lowest so far is higher than this table entry
					mov		-2(R13),R8			; A new lowest noise
					mov		R15,R10				; Remember the table index
				_ENDIF
				inc		R15
				cmp		#NumAdcClocks,R15
			_UNTIL	EQ

			; The lowest noise result was with a table index of R10, corresponding to an ADC timing
			; index of R10+1
			add		#1,R10				; Use this value from now on; save to info flash soon
			add		#4+2*NumAdcClocks,SP ; Deallocate locals
			ret


; Cell temperature ( -- ) ; Not updated during bypassing so it is not merely CMU temperature
		xCODE	'T'|'c'<<8,CellTemp,_CellTemp ; 'Tc' collides with 'Ta' 'Tk' 'Ts' 'La' 'Lc' 'Lk' 'Ls'
		mov		#'T'|'c' <<8,Rthd		; Command being responded to
		mov.b	&cellTemperature,Rsec	; Get cell temperature
		sxt		Rsec					; Sign extend byte to word
		mov		#2,Rtos					; Print 2 digits
		br		#_prettyPrint			; Tail-call pretty-print and return

