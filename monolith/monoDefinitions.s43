;
; Command character definitions for the monitor
;

#include "../common/comDefinitions.s43"			; Include the definitions common to monitor
												; and TestICal

; checKsumming ( -- )						; Toggle bChecksumming
			; kk to turn checksumming off, k to turn it on (irrespective of present state)
			xCODE	'k',checksumming,_checksumming
			xor.b	#bChecksumming,&interpFlags ; Toggle bChecksumming bit in interpFlags
			ret

; Kill status sending ( boolean -- )		; 1 for no status, 0 for status
			xCODE	'K',KillStatus,_KillStatus
			allBitsIfNZ	Rtos,Rtos			; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bNotSendStatus,&monFlags ; Move only bNotSendStatus from Rtos to monFlags
			ret

#if 0		// Not used now, and clashes with calibrate command
; Charging ( boolean -- )				; 1 when charging or regenning, 0 when driving
			; This lets the CMU include undertemperature and exclude undervoltage as stress when charging,
			; and when masterless-charging is enabled via the 'o' command, this command
			; start and stops charging.
			xCODE	'c',Charging,_Charging
			allBitsIfNZ	Rtos,Rtos			; IF Rtos is zero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#bCharging,&monFlags ; Move only bCharging from Rtos to monFlags
			ret
#endif

#if MASTERLESS_CHARGING
; ChargerC(o)ntrol ( voltMin voltMax -- )
			; This command only makes sense for the last CMU/IMU in the string, with an adapter
			; from its fibre-optic output to the serial input of a PIP inverter/charger.
			; If voltMax is non-zero, whenever you get a '1c' command, run a PI controller on stress
			; to control a PIP inverter/charger at 2400 baud.
			; If voltMax is zero, disable charger control and go back to status sending at 9600 baud.
			; voltMin is minimum charger voltage in tenths of a volt.
			; voltMax is maximum charger voltage in tenths of a volt.
			; e.g. 480 584o<cr> for charger control between 48.0 and 58.4 volts, the PIP's maximum range
			; 0o<cr> to go back to status sending.
			xCODE	'o',ChargerControl,_ChargerControl
			mov		Rtos,&chargerVoltMax		; Set the maximum charger voltage
			tst		Rtos
			_IF		_Z							; If the maximum is zero
				bic.b	#bChargerControl,&monFlags	; Clear the bChargerControl bit in monFlags
			_ELSE
				bis.b	#bChargerControl,&monFlags	; Set the bChargerControl bit in monFlags
				mov		Rsec,&chargerVoltMin		; Set the minimum charger voltage
			_ENDIF
			ret
#endif // MASTERLESS_CHARGING

#if PROG_START < $F800		// Commented out if need to save space
; Rx state ( -- )
			xCODE	'&',RxState,_RxState 	; Note: 'r' is read calibration value in TestICal
			mov		#'&',Rthd				; Type is ticks &ince last Rx
			mov.b	&ticksSinceLastRx,Rsec	; Result in ticks
;			mov		#3,Rtos					; Print 3 digits
			br		#_prettyPrint3			; Tail-call pretty-print of 3 digits and return
#endif

; Comms error ( -- )						; Report temporary master's ID
_commsError	; No command character since it never needs to be interpreted and 'c' is used for Charging
			mov		#'c',Rthd				; Type is comms error
			mov		#0,Rsec					; Zero value (so no minus sign)
			mov		#0,Rtos					; Send no digits of value (will get '$' if hex)
			br		#_prettyPrint			; Tail-call pretty-print and return

; Status ( -- )								; Report global status if a BMU, else local status
			xCODE	'p',Stress,_Stress		; 'p' for pain since we've already used 's' for select
			cmp.b	#'P',-2(Rip)			; Dirty way of ignoring 'Pp' (PIP inverter) commands for
			_IF		_NE						; Mike's monolith that uses rev61 CMUs with later BMUs
				push.b	&interpFlags			; Save present number base
				bis.b	#bHexOutput,&interpFlags ; Set to hexadecimal output
				mov		#'p',Rthd				; Type is stress
				cmp.b	#255,&ID
				_IF		_EQ						; If BMU
					mov.b	&globalStatus,Rsec		; Get global status
				_ELSE
					mov.b	&localStatus,Rsec		; Get local status
				_ENDIF
				and.b	#$7F,Rsec				; Clear the high bit
	;			mov		#3,Rtos					; Print 3 digits
				call	#_prettyPrint3			; Call pretty-print of 3 digits
				popBits_B #bHexOutput,&interpFlags ; Restore number base
			_ENDIF
			ret

; QUOTE ( "ccc<quote>" -- c-addr u )
; Parse, from the command sequence, characters ccc delimited by " (double quote).
; Return c-addr and u that describe a string consisting of the characters ccc.
; c-addr points to the first character and u is the length of the string.
; The caller must not alter the returned string.
		xCODE	'"',QUOTE,_QUOTE	; Double-quote
		DPUSH	Rip			; Push the address of the first character
		DPUSH	#0			; Push a tentative zero length, Rtos := 0
		_BEGIN
			mov.b	@Rip+,Rw	; Read a character and increment the interpreter pointer
			cmp.b	#'"',Rw		; Check if the character is a double quote
			_WHILE	_NE			; While the character is not a double-quote
				cmp.b	#EXIT,Rw	; Check if at end of command packet, in case quote was omitted
				_WHILE	_NE			; While the character is not an EXIT command
					inc	Rtos			; Increment the length
		_AGAIN				; Loop back to _BEGIN
				_ENDIF				; End While not EXIT command (end of command packet)
				dec		Rip			; Back up so the EXIT command gets interpreted
			_ENDIF				; End While not a double-quote
		ret

; Query worst stress ( minStressToShow -- )
			xCODE	'q',queryWorstStress,_queryWorstStress
			cmp.b	Rtos,&worstStress
			_IF		_LO
				ret
			_ENDIF
			push.b	&interpFlags				; Save present number base
			bic.b	#bHexOutput,&interpFlags	; Set to decimal output

			DELAY_IF_NEEDED					; Allow time for CR to be echoed upstream if needed
			mov		#EXIT,R8				; Send initial slosh (EXIT command or comment character)
			call	#TxByteCk				; which stops rest of packet being interpreted

			mov.b	&ID,Rsec				; Emit the ID
			mov		#3,Rtos					; as 3 digits
			call	#_emitNum

			mov		#ColonQspace,R10
			call	#TxStringCk

		;	mov		#':',R8					; Colon separator
		;	call	#TxByteCk
		;	mov		#'q',R8					; 'q' as type of result
		;	call	#TxByteCk
		;	mov		#' ',R8					; Space separator
		;	call	#TxByteCk

			mov.b	&worstStress,Rsec		; Emit worstStress
			mov		#2,Rtos					; as 2 digits
			call	#_emitNum
			mov		#' ',R8					; Space separator
			call	#TxByteCk

			ClearWatchdog

			; Now send the index of the following measurement that caused the worst stress
			mov.b	&worstStressType,Rsec	; Send index of following measurement that caused worst stress
			mov		#1,Rtos					; as 1 digit
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			; Now send the worst over-voltage
			mov		&worstOV,Rsec			; Send worst over-voltage
			mov		#4,Rtos					; as 4 digits
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			ClearWatchdog

			; Now send the worst under-voltage
			mov		&worstUV,Rsec			; Send worst under-voltage
			mov		#4,Rtos					; as 4 digits
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			; Now send the worst over-temperature
			mov		&worstOT,Rsec			; Send worst over-temperature
			mov		#2,Rtos					; as 2 digits
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			ClearWatchdog

			; Now send the worst under-temperature
			mov		&worstUT,Rsec			; Send worst under-temperature
			mov		#2,Rtos					; as 2 digits
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			; Now send the worst absolute link voltage
			mov		&worstAL,Rsec			; Send worst absolute link voltage
			mov		#4,Rtos					; as 4 digits
			call	#_emitNum
			mov		#' ',R8					; Transmit a space
			call	#TxByteCk

			call	#TxEndOfPacket

			ActLedOn						; Set the (inverted) activity LED here to mimic old behaviour
			pop.b	&interpFlags			; Restore number base
			ret
ColonQspace	DB		3, ':q '				; First byte is length of following string
			ALIGN	1

; Reset worst stress ( -- )
			xCODE	'{',resetWorstStress,_resetWorstStress ; Frowny mouth :-{ because irreversible
			clr.b	&worstStress
			clr.b	&worstStressType
			clr		&worstOV
			mov		#9999,&worstUV
			mov		#-99,&worstOT
			mov		#99,&worstUT
			clr		&worstAL
			ret

; Min  ( id type value -- ) ; Gives the minimum voltage or temperature and the ID of the cell
		xCODE	'<',min,_min
			NO_ECHO_CMD	doMin0,doMin			; Use the no-echo wrapper macro
doMin0:
		mov		#0,Rthd				; Default ID
		mov		Rtos,Rsec			; Type
		mov		#$7FFF,Rtos			; Default value infinity
doMin:	; Emit another Min command with its last parameter min-ed with the
		; relevant local value. The second parameter tells which type of local value, voltage or temp.
		; The first parameter gives the ID of the cell having the max value.
 		_CASE
			_OF #'v',Rsec
				call	#cellV			; Get cell voltage in millivolts in R10
				push	#4				; Save the field width, 4 digits
			_ENDOF
			_OF #'t',Rsec
				call	#temp			; Get temperature in degrees Celsius in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'p',Rsec
				mov.b	&localStatus,R10 ; Get stress level in R10
				and.b	#$0F,R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'q',Rsec
				mov.b	&worstStress,R10 ; Get stress level in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
		mov		#$7FFF,R10			; Default case, unknown type, set R10 to infinity
		push	#1					; Save the field width, 1 digit
		_ENDCASE

		cmp		Rtos,R10			; Find min of parameter and local value
		_IF		_L
			mov		R10,Rtos
			mov.b	&ID,Rthd			; If new min, update ID
		_ENDIF

		push	Rtos				; Save value
		push	Rsec				; Save type

		mov		Rthd,Rsec			; Put ID into Rsec
		mov		#3,Rtos				; Use a 3 digit field width
		call	#_emitNum			; Transmit the ID as text in the present number base

		mov		#':',R8				; Transmit a colon, an alias for tick
		call	#TxByteCk

		pop		R8					; Pop and transmit the type, 'v' or 't'
		call	#TxByteCk

		mov		#' ',R8				; Transmit a space
		call	#TxByteCk

		pop		Rsec				; Pop the min value
		pop		Rtos				; Pop the field width
		call	#_emitNum			; Transmit the value as text in the present number base

		mov		#'<',R8				; Transmit a "<"
		call	#TxByteCk

		br		#TxEndOfPacket		; Tail-call TxEndOfPacket and return
;		ret

#if (PROG_START < $F000)
; Max  ( id type value -- ) ; Gives the maximum voltage or temperature and the ID of the cell
		xCODE	'>',max,_max
			NO_ECHO_CMD	doMax0,doMax	; Use the no-echo wrapper macro
doMax0:
		mov		#0,Rthd				; Default ID
		mov		Rtos,Rsec			; Type
		mov		#$8000,Rtos			; Default value neg infinity
doMax:	; Emit another Max command with its last parameter max-ed with the
		; relevant local value. The second parameter tells which type of local value, voltage or temp.
		; The first parameter gives the ID of the cell having the max value.
 		_CASE
			_OF #'v',Rsec
				call	#cellV			; Get cell voltage in millivolts in R10
				push	#4				; Save the field width, 4 digits
			_ENDOF
			_OF #'t',Rsec
				call	#temp			; Get temperature in degrees Celsius in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'p',Rsec
				mov.b	&localStatus,R10 ; Get stress level in R10
				and.b	#$0F,R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'q',Rsec
				mov.b	&worstStress,R10 ; Get stress level in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
		mov		#$8000,R10			; Default case, unknown type, set R10 to neg infinity
		push	#1					; Save the field width, 1 digit
		_ENDCASE

		cmp		R10,Rtos			; Find max of parameter and local value
		_IF		_L
			mov		R10,Rtos
			mov.b	&ID,Rthd			; If new max, update ID
		_ENDIF

		push	Rtos				; Save value
		push	Rsec				; Save type

		mov		Rthd,Rsec			; Put ID into Rsec
		mov		#3,Rtos				; Use a 3 digit field width
		call	#_emitNum			; Transmit the ID as text in the present number base

		mov		#':',R8				; Transmit a colon, an alias for tick
		call	#TxByteCk

		pop		R8					; Pop and transmit the type, 'v' or 't'
		call	#TxByteCk

		mov		#' ',R8				; Transmit a space
		call	#TxByteCk

		pop		Rsec				; Pop the max value
		pop		Rtos				; Pop the field width
		call	#_emitNum			; Transmit the value as text in the present number base

		mov		#'>',R8				; Transmit a ">"
		call	#TxByteCk

		br		#TxEndOfPacket		; Tail-call TxEndOfPacket and return
;		ret
#endif

; setPainThresholds  ( setpoint step type -- ) // Standard setting is 3490 20'VP. 76% charge 3353 3'VP
; Mainly intended for use with MASTERLESS_CHARGING
		xCODE	'P',setPainThresholds,_setPainThresholds	; Set stress-level thresholds
		cmp.b	#'p',0(Rip)			; Dirty way of ignoring 'Pp' (PIP inverter) commands for
		_IF		_NE					; Mike's monolith that uses rev61 CMUs with later BMUs
			_CASE
				_OF #'V',Rtos				; Set overvoltage zero and step
					mov		Rsec,&ovStep	; ovStep = Rsec
					add		Rsec,Rthd		; ovZero = Rthd - 7 * Rsec
					rla3	Rsec
					sub		Rsec,Rthd
					mov		Rthd,&ovZero
				_ENDOF
			_ENDCASE
		_ENDIF
		ret

; Current (tenths-of-an-amp -- ) // Sent by IMU to CMUs
		xCODE	'i',Current,_Current
		cmp.b	#255,&ID
		_IF	_NE							; If we're not an IMU
			mov		Rtos,&current			; Set the current
		_ENDIF
		clr.b	&ticksSinceLastI		; Zero ticks since last 'i' command
		ret

; Store discharge counter high word (dischargeHi -- )
		; Sent periodically by IMU to CMU 1, and sent by CMU 1 to IMU on receiving a 'G' command.
		; The IMU uses the CMU as battery-backed-up RAM to store the approximate depth of discharge so
		; it can restore it after the monolith has been shut down and hence IMU has been powered down.
		xCODE	'Z',ZtoreDischarge,_ZtoreDischarge
		mov		Rtos,&discharge+2		; Set the discharge counter high word to the received value
		ret

; Get discharge counter high word ( -- )
		; Sent by IMU to CMU 1 when IMU is reset. Sends a 'Z' command back to the IMU with the
		; high byte of the discharge counter.
		xCODE	'G',GetDischarge,_GetDischarge
		mov		#SelectIMU,R10			; Transmit "255s" to select the IMU only
		call	#TxStringCk
		ClearWatchdog

		mov		&discharge+2,Rsec
		mov		#5,Rtos					; 5 digit field width
		push.b	&interpFlags			; Save number base
		bis.b	#bHexOutput,&interpFlags; Set to hexadecimal output
		call	#_emitNum				; Transmit the number
		pop.b	&interpFlags			; Restore number base
		ClearWatchdog

		mov		#'Z',R8					; Transmit a "Z" for ZtoreDischarge
		call	#TxByteCk
		br		#TxEndOfPacket			; Tail-call TxEndOfPacket and return
;		ret

SelectIMU	DB	4, '255s'				; First byte is length of following string
			ALIGN	1

; Some characters need to be translated into RAM adresses of calibration values
		ALIGN	1
calAddressTable
		DB		'c' , infoCapacity	& $7F | $80
		DB		'r' , infoCellRes	& $7F | $80
		DB		'V' , infoBoltPlCal	& $7F | $80
		DB		'v' , infoVoltCal	& $7F | $80	; High bit set to indicate word quantity,
		DB		't' , infoTempCal	& $7F | $00	; clear for byte quantity
		DB		'i' , infoID		& $7F | $00
		DB		'd' , infoDataVers	& $7F | $00	; Data vers is not for writing
; Zero must not appear in the table as it is used to represent "unrecognised".
sizeCalAddressTable	EQU	$-calAddressTable

;
; TranslateToCalAddr ( ch -- addr )
;
TranslateToCalAddr:
		; Do the calibration address translations using the table above
		mov		#sizeCalAddressTable,R9 ; Initialise the loop counter and table index
		_BEGIN				; Begin loop
			mov.w	calAddressTable-2(R9),R10 ; Get two bytes from the table
			cmp.b	R10,Rtos	; Compare the address character with the low byte from the table
			_WHILE	_NE			; While no match [ _WHILE xx = _IF xx  _CS_SWAP ]
				decd	R9			; Decrement loop-counter/table-index by 2
		_UNTIL	_Z			; Until loop counter is zero
		clr		Rtos		; Finished loop with no match so set result to zero for "unrecognised"
			_ELSE				; Else there is a match so
				swpb	R10			; Get the high byte from the table
				mov.b	R10,Rtos	; Substitute it for the address character
			_ENDIF				; Endif match
		ret

;
; Calibrate ( n ch --- )
; Perform a calibration whose type is ch ('v for voltage etc) and value is n
; For the voltage scale and offset calibrations, we want to apply the other correction (i.e. scale if
; we are calibrating offset, and vice versa) to get the best correction so far. This also allows for
; successive improvement calibration if that turns out to be useful.
;
			xCODE	'c',calibrate,_calibrate
			_CASE

			_OFb	#'i',Rtos
				; When preceded by XOFF (ctrl-S) and the desired first ID in decimal,
				; and followed by <cr> XON (ctrl-Q), it sets consecutive IDs in consecutive CMUs
				; and responds with the ID _after_ the last ID.
				cmp.b	#255,&ID
				_IF		_EQ					; But if we're a BMU,
					ret							; silently ignore; BMUs have to stay ID=255
				_ENDIF
				bit.b	#bDontEcho,&interpFlags
				_IF		_NZ					; If the dont-echo flag is set
					; Save our new ID to info-flash
					mov.b	Rsec,R8				; New value
					mov		#0,R9				; Size = byte
					mov		#infoID,R10			; Address of info-flash item
					call	#UpdFlash

					; Send another setIDs command with its parameter incremented by one.
					mov		Rsec,Rtos
					inc		Rtos				; Increment the parameter
					DPUSH	#3					; Use a 3 digit field width
					call	#_emitNum			; Transmit the number as text in the current number base

					mov		#TickIcStr,R10			; Transmit a 'ic
					call	#TxStringCk
					call	#TxEndOfPacket
				_ELSE						; Else dont-echo flag is clear
					; Send \? to remind user that Ctrl-S needs to be sent before an 'ic command.
					jmp		EmitQmark
				_ENDIF
				ret			; Don't fall through to _readCalValue
			_ENDOF
;
; Default case
				jmp		EmitQmark					; Unknown calibration type character

			_ENDCASE

			;jmp		_readCalValue			; Display the value just calibrated and return
												;	(by falling through)
			;
			; Keep 'c' command (above) and 'r' command (below) together
			; That is, don't insert a new command here
			;
;
; Read calibration value ( ch --- )
; Calibration type (e.g. 'v' for cell Voltage) in ch
			xCODE	'r',readCalValue,_readCalValue
			call 	#TranslateToCalAddr
			mov.b	Rtos,Rsec				; Convert to info flash address in Rsec
			bic.b	#$80,Rsec
			or_w	#infoDataStart&$FF80,Rsec ; Copy higher bits from immediate address
			tst.b	Rtos
			_IF		_NZ						; If not zero (zero means "unrecognised")
				_IF		_NN						; If high bit clear
					mov		#3,Rtos					; Display 3 digits
					mov.b	@Rsec,Rsec				; Get byte sized cal value
				_ELSE							; Else high bit set so
					mov		#5,Rtos					; Display 5 digits
					cmp		#infoCapacity,Rsec		; Test for battery capacity
					mov.w	@Rsec,Rsec				; Get word sized cal value
					_IF		_EQ
						mov		Rsec,R9
						clr		R10
						mov		#10,R8				; Divide by 10 to bring to whole Ah
						call	#UMSlashMod			; R10:R9 / R8 -> R9
						mov		R9,Rsec
					_ENDIF
				_ENDIF							; Endif high bit
			_ELSE 							; Else is zero for "unrecognised"
EmitQmark
				mov		#QuestionStr,R10
				br		#TxString			; Print \? <ret> and exit
			_ENDIF							; Endif unrecognised
			mov.b		#' ',Rthd			; Cmd type char (space). May be r or c command
			call	 	#_prettyPrint
			ret

QuestionStr	DB			3,'\\?\r'			; Initial \ because '?' is a peek command
TickIcStr	DB			3,'\'ic'			; 'ic command to send downstream


;
; Write calibration value ( n ch --- )
;
; n is value to write. ch is calibration type (e.g. 'v for cell Voltage).
;
; Note: For the 'rw command, a ballpark estimate of LiFePO4 resistance in microohms would be 144000
; divided by the capacity in amp hours.
; Alternatively cell resistance can be measured as the change in battery voltage
; divided by the step change in current that caused it, divided by the number of cells.
; To obtain "HiTempCellRes", the measured cell resistance should be divided by
; 1 + 2^(1-T/10) where T is the cell temperature at which the measurement was made.
; e.g. at 20 degC, divide the measurement by 1.5 to obtain HiTempCellRes.
; e.g. at 25 degC, divide the measurement by 1.35 to obtain HiTempCellRes.
; e.g. at 30 degC, divide the measurement by 1.25 to obtain HiTempCellRes.

			xCODE	'w',writeCalValue,_writeCalValue
		_COND
			cmp.b	#'i',Rtos					; Write an ID ?
		_OR_ELSE	_EQ
			cmp.b	#'r',Rtos					; Cell internal resistance
		_OR_ELSE	_EQ
			cmp.b	#'c',Rtos					; Battery capacity
		_OR_IFS 	_EQ
			call 	#TranslateToCalAddr
			mov.b	Rtos,R10					; Convert to info flash address in R10
			bic.b	#$80,R10
			or_w	#infoDataStart&$FF80,R10	; Copy higher bits from immediate address
			cmp		#infoCapacity,R10			; Check for battery capacity
			_IF		_EQ							; If so
				rla		Rsec						; Multiply given value by 10
				mov		Rsec,R9						; to bring to tenths of an Ah
				rla2	Rsec						; *8
				add		R9,Rsec						; *10
			_ENDIF
			tst.b	Rtos
			_IF		_NZ						; If not zero for "unrecognised"
				_IF		_NN						; If high bit clear
					mov		#0,R9					; Indicate byte size
				_ELSE							; Else high bit set so
					mov.w	#1,R9					; Indicate word sized cal value
				_ENDIF							; Endif high bit
				mov		Rsec,R8					; Data to be written
				call	#UpdFlash			; Write new value to flash
			_ELSE 							; Else is zero for "unrecognised"
				jmp		EmitQmark
			_ENDIF							; Endif unrecognised
			ret
		_ELSE							; Not a valid ch for monolith 'w' command
			jmp		EmitQmark
		_ENDIF


; These are actually locals to the BSL2 macro
MClock		EQU		4000000			; MCLK (CPU clock) frequency in hertz (=DCOCLK/2)
MckPerFTGck EQU     (MClock+165000)/330000  ; MCLK cycles per Flash Timing Generator cycle
;
; Update a single word or byte into info-flash. Note that this is NOT a command definition;
; we can't have a bare "u" command in monolith, and there are no RAM copies to update from.
; R8 has new info value
; R9 is 1 for word, 0 for byte
; R10 has address of the flash word to be written
; Trashes R11, R12
;
			; Prepare to flash-program
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz

UpdFlash:
			sub		#infoDataEnd-infoDataStart,SP ; Allocate space on stack for info flash bytes
			mov		SP,R11					; Copy start of buffer to R10
			clr		R12						; Loop counter
			_BEGIN
				mov.b	infoDataStart(R12),0(R11)	; Copy a byte from info-flash to stack
				inc		R11
				inc		R12
				cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	_EQ						; Loop until ramDataEnd

			add		SP,R10					; R10 points infoDataStart past RAM equivalent
			tst		R9
			_IF		_NZ
				mov.w	R8,-infoDataStart(R10)		; Copy new info word to RAM equivalent
			_ELSE
				mov.b	R8,-infoDataStart(R10)		; Copy new info byte to RAM equivalent
			_ENDIF

			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Hold Watchdog Timer

			; Erase appropriate info flash segment.
			mov		#FWKEY,&FCTL3			; Clear LOCK
			mov		#FWKEY+ERASE,&FCTL1		; Enable single segment erase

			rra		&infoDataStart			; Dummy write: Start of cal data in info-flash

			mov		#FWKEY+WRT,&FCTL1		; Enable write (can leave on; only write block that can't)

			clr		R12						; Loop counter
			mov		SP,R10					; Point to start of RAM copy
			_BEGIN
				mov.b	@R10+,infoDataStart(R12)	; Write a byte to info-flash
				inc		R12
				cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	_EQ						; Loop until ramDataEnd

			mov		#FWKEY,&FCTL1			; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3		; Set LOCK
			;
			; Check that the flash programming worked
			;
			call	#compareInfoFlash		; Compare RAM cal data with what's in infoflash
			mov		#1+4+1,R11				; String length
			_IF    _NE
				mov		#sFail,R10
			_ELSE
				mov		#sDone,R10
			_ENDIF
			add		#infoDataEnd-infoDataStart,SP ; Deallocate stack buffer; OK to modify flags
			br		#TxBytes			; Send string pointed to by R10, len R11. Trashes R8-R11
			;ret

sFail		db		'\\FAIL\r'
			ALIGN	1
sDone		db		'\\Done\r'
			ALIGN	1

;
; Compare the ~20 bytes of calibration data at 2(SP) with what's at infoDataStart (in info-flash).
; Returns with Z set if OK, Z clear if not.
; Trashes R10, R12
compareInfoFlash:
			mov		SP,R10
			incd	R10					; Skip return address
			clr		R12					; Loop counter
			_BEGIN
				cmp.b	@R10+,infoDataStart(R12)
				_WHILE	_EQ ; _Z
					inc		R12
					cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	_EQ					; Loop until we get to infoDataEnd
				_ENDIF
			; The increment will have set Z if all compares well. The cmp will have cleared Z otherwise.
			ret

