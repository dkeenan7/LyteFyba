;*******************************************************************************
;	MSP430F20xx Software UART - Timer_A
;
;	Description: Use Timer_A CCR0 hardware output modes and SCCI data latch
;	to implement UART function @ 9600 baud. Software does not directly read and
;	write to RX and TX pins, instead proper use of output modes and SCCI data
;	latch are demonstrated. Use of these hardware features eliminates ISR
;	latency effects as hardware insures that output and input bit latching and
;	timing are perfectly synchronised with Timer_A regardless of other
;	software activity.
;	TACLK = SMCLK/8 = DCOCLK/2/8 = 250 kHz, MCLK = DCOCLK/1 = 4.00 MHz, ACLK = LFXT1/1 = unused
;
;				MSP430F20xx
;			 ---------------
;		 /|\|				|
;		  | |				|
;		  --|RST			|
;			|				|
;			|		TA0/P1.1|--------> TXDm (mark = low)
;			|	   SCLK P1.5|--------> TXDp (mark = high; via internal inverter from TA0)
;			|				| 9600 8N1 full duplex
;			|	  CCI1A/P1.2|<-------- RXD
;
;
;	September 2010
;	Based on code by:
;	M. Buccini / L. Westlund
;	Texas Instruments Inc.
;	October 2005
;*******************************************************************************
		LSTOUT-
#include	"io430.h"		// For #define TAIV_CCIFG1
		LSTOUT+



;
;
;	Conditions for 9600 Baud SW UART
#if 0
Mfreq		EQU		1000000					; Main clock in Hz
MckPerSMck	EQU		1						; Number of main clocks per SMCK
#else
Mfreq		EQU		4000000					; Main clock in Hz
MckPerSMck	EQU		2						; Number of main clocks per SMCK
#endif
SMckPerTAck	EQU		8						; Number of SMCK clocks per timer clock
MckPerTAck	EQU		MckPerSMck*SMckPerTAck	; Number of main clocks per timer clock
TAfrfeq		EQU		Mfreq/MckPerTAck		; Timer frequency in Hertz
Bitime		EQU		(TAfrfeq+4800)/9600		; 104.17 us bit length in timer clock periods
Bitime_5	EQU		(Bitime/2)-2			; 0.5 bit length less some




;-------------------------------------------------------------------------------
;TX_Byte	; Subroutine Transmits Character from R8
			; Trashes R9
;-------------------------------------------------------------------------------
			; Decrement instruction is used here as an atomic test-and-set instruction:

noAcqSem	inc.b	&TX_Sem					; Undo our decrement (see below; this is not entry point)
TX_Byte:
getTxSem	dec.b	&TX_Sem					; Attempt to get the transmit semaphore
			jnz		noAcqSem				; If decrements to zero, we got it, otherwise loop

gotTxSem:									; Internal entry point; see TX_ByteNW
			mov.b	R8,&TXData				; Now it's safe to save to TXData
intTxBy:									; Private entry point, see Tx_Done in TX_ISR
			mov.b	#8,&USICNT				; To keep USIIFG clear so SCLK (TXDp) will not be held
											; This is so that P1.5 will always be an inversion of P1.1

			mov.b	#10,&BitCntTx			; Load bit transition counter: 10 bits; interrupt 10 times,
											; just after the start of each bit sent

			; Need to disable interrupts here; there is a critical time period between
			; reading the current timer value (TAR) and writing the capture register (TACCRt)
			; and the timer control register (TACCTLt).
			dint							; NOTE: instruction following DINT is not protected!
			; We want the max number of clock cycles till both TAR and TACCTLt are correctly set up.
			; First number is sum of cycles in parentheses below. The +MckPerTAck-1 is for rounding up.
			; The +1 is in case the TAR increments just after we read it.
			mov		#((26+MckPerTAck-1)/MckPerTAck) +1, R9	; Not protected by dint
			add		&TAR,R9					; (3) Where the current count will be soon
			; If the CCIFG bit is clear, it means that the last stop bit has not yet expired,
			; so we must not set an earlier time than that.
			; The CCIFG bit cannot have been cleared by its interrupt because those interrupts
			; must be disabled if we've got here.
			bit		#CCIFG,&TACCTLt			; (5) Test transmit compare interrupt flag
			jnz		newStart				; (2) If not zero, set a new compare value
			cmp		&TACCRt,R9				; (4) Test (TAR+setup) - TACCRt
			jn		keepOldStop				; (2) If existing TACCRt is AFTER TAR+setup, keep TACCRt
newStart	mov		R9,&TACCRt				; (4) Some time till timer-compare starts start-bit
			; We can't afford to have interrupts enabled here; the timer counter must
			; not advance past TACCRt's value until the compare output mode is set correctly below
keepOldStop	eint							; (1) Instruction after eint always protected
			; CM_0 = no capture; CCIE = compare interrupt enable; NOT CAP = compare;
			; OUTMOD_1 means SET the output when the compare becomes equal (to start the start bit)
			mov.w	#CM_0 + OUTMOD_1 + CCIE, &TACCTLt ; (5) Set output mode for start bit
			; End of code protected by dint/eint.
			; Interrupts were disabled for 20 to 26 cycles
			
			bis.b	#LED,&P1OUT				; Set the LED for visual feedback. We might miss the start
											; bit, but it doesn't matter.
			ret

;-------------------------------------------------------------------------------
RX_TIOV_ISR	; Combined Receive (timer capture/compare 1) and timer overflow interrupt service routine
;-------------------------------------------------------------------------------
											; (6) for interrupt accepted
			cmp		#TAIV_CCIFG1,&TAIV		; (4) Combined interrupt: was it CC1?
			jeq		UART_RX					; (2) Yes, was CC1
			jl		just_reti				; No interruipt pending
			; Can't be CC2 interrupt source; MSP430F201x doesn't have this
			; So must be timer overflow
;
;	Regular timer overflow interrupt: cause the mainline code to measure voltages etc
;
			mov.b	#-1,&bMeasureTime		; Notify mainline that it's time to measure
			bic		#CPUOFF,0(SP)			; When return, wake CPU if needed
just_reti	reti

;	RXData location holds received byte
UART_RX		add.w	#Bitime,&TACCRr			; (5) Time to next bit
			bit.w	#CAP,&TACCTLr			; (5) Capture mode = start bit edge
			jz		RX_Bit					; (2) Start bit edge?
RX_Edge:
			bic.w	#CAP,&TACCTLr			; (5) Switch to compare mode
			; Already burned many cycles to this point. But it doesn't matter,
			; since the value in TACCRr was captured by the timer hardware.
			add.w	#Bitime_5,&TACCRr		; (5) First databit 1.5 bits from edge
			reti							; (5)
;
RX_Bit		bit.w	#SCCI,&TACCTLr			; (4) Sampled bit to carry
			rrc.b	&RXData					; (4) Store received bit
RX_Test		dec.b	&BitCntRx				; (4) All bits RXed?
			jnz		just_reti				; (2+5) If there's a next bit, just exit
			mov.b	#8,&BitCntRx			; Setup bit counter for next byte
			bis.w	#CAP,&TACCTLr			; Back to capture mode
;			eint							; Enable interrupts
			br		&RxByteCB				; Start the received character callback routine


;-------------------------------------------------------------------------------
TX_ISR:	; Transmit (timer capture/compare 0) interrupt service routine
;-------------------------------------------------------------------------------
; First interrupt BitCntTx is 10 (decrements to 9), start	bit just sent, LSB needs sending now
; 8th interrupt, BitCntTx is 3, data bit 6 just sent, MSB needs sending now
; 9th interrupt, BitCnt is 2, MSB just sent, stop bit needs sending now
; 10th interrupt, BitCntTx is 1 (decrements to 0), stop bit just sent, need to send idle state;
;	need to disable Tx interrupts, transmit is complete (safe to start another at end of stop bit)

											; (6) for interrupt accepted
			add.w	#Bitime,&TACCRt			; (5) Time to next bit, when next bit is due
			dec.b	&BitCntTx				; (4)
UART_TX		jz		TX_Done					; (2) Jump if stop bit just sent
			
			rra.w	&TXData					; (1) Next bit to C. NOTE: upper byte remains -1 always,
											;	so stop and idle bits are always treated like data 1's
TX_Mark		
			_IF		_NC						; (2) If bit is 0
				mov		#OUTMOD_1+CCIE,&TACCTLt ; (5) then set output high
			_ELSE							; (2)
				mov		#OUTMOD_5+CCIE,&TACCTLt	; (5) Else reset output low
			_ENDIF

			reti							; (5) Expecting more interrupts this byte

TX_Done:	bic.w	#CCIE,&TACCTLt			; (5) All Bits TX; disable Int.
			bic.b	#LED,&P1OUT				; (5) Clear the LED at the end of the transmit
			cmp.w	#$FFFF,&TXPrioData		; Is there any priority byte in the 2-byte buffer?
			jeq		TX_Done2				; Jump if none
			push	R9						; Must preserve registers
			mov.b	&TXPrioData+1,&TXData	; Move most recent to TXData
			mov.b	&TXPrioData,&TXPrioData+1 ; Move oldest to most recent
			mov.b	#$FF,&TXPrioData		; Mark oldest as being empty
			call	#intTxBy				; Call the internal TX_Byte to send
			pop		R9
			; Important: don't increment the semaphore here. When the last buffered byte completes, it
			; will get to TX_Done2 and increment the semaphore on this byte's behalf. Also, incrementing
			; the semaphore would allow the mainline to send another byte, which would corrupt this one.
			reti
TX_Done2	inc.b	&TX_Sem					; (4) Release the transmit semaphore
			reti							; (5)
			
;
; Wait for the currently transmitting byte (if any) to complete.
; Called by the BSL-password checker in OnRxByte before disabling interrupts and branching to BSLErase.
; Was called by SetID.
waitTxCmpl:
			cmp.b	#1,&TX_Sem				; Don't need test and set here
			jnz		waitTxCmpl				; Just wait for TX_Sem to become 1
			ret


;
; TX_ByteNW : No Wait version of TX_Byte for interrupt routines
; Called from OnRxByte when sending badness or echoing non-badness
TX_ByteNW:	dec.b	&TX_Sem					; Attempt to get the transmit semaphore
			jz		gotTxSem				; If decrements to zero, we got it. Jump into TX-Byte
			; Instead of busy waiting for the semaphore to become available, use the priority TX buffer
			inc.b	&TX_Sem					; Undo our decrement
			cmp.b	#$FF,&TXPrioData+1
			jeq		TXDnoJam1
			; If get here, at least 1 TX buffer slot is used:
			cmp.b	#$FF,&TXPrioData		; For
			jeq		TXDnoJam2				;	debugging
			nop								; Place breakpoint here to prove we never get here!
TXDnoJam2	mov.b	R8,&TXPrioData			; Use second TX buffer slot
			ret
TXDnoJam1	mov.b	R8,&TXPrioData+1		; Use first TX buffer slot
			ret
