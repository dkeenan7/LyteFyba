		COL		132			; Wide listings

		LSTOUT-
#include "msp430.h"
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
		LSTOUT+
		
allBitsNC	MACRO	dest
			subc	dest,dest	; Sets all bits to not carry
			ENDM
			
allBitsC	MACRO	dest
			subc	dest,dest	; Sets all bits to not carry
			inv		arg			; Sets all bits to carry
			ENDM
			
allBitsZ	MACRO	src,dest
			and		src,src		; Sets carry if src is not zero
			subc	dest,dest	; Sets all bits to not carry = zero
			ENDM
			
allBitsNZ	MACRO	src,dest
			and		src,src		; Sets carry if src is not zero
			subc	dest,dest	; Sets all bits to not carry = zero
			inv		arg			; Sets all bits to carry = not zero
			ENDM
			
bitStore	MACRO	src,mask,dest	; Trashes src
			xor		dest,src	; Get one bits in src for bits that need to toggle
			and		mask,src	; Mask so we only change those we want to change
			xor		src,dest	; Toggle bits as required
			ENDM

		NAME	main					; module name
		PUBLIC	main					; make the main label visible

#define		Rtrash	R14			// Junked in flashCStore

DATAVERS5	EQU		1			; True if data layout version 5
#if	DATAVERS5
InitRetAddr	EQU		$1022		; Return address when interpretByte is called for initialisation
ReadByte	EQU		$108C		; Calling-address to receive byte in R8
WriteByte	EQU		$10C4		; Calling-address to transmit byte in R8
BSLErase	EQU		$1038		; Jump-in-address for erasing flash and continuing a download
ID			EQU		$10F2		; Address of this Cell's/BMU's identification byte
VoltCalL	EQU		$10F8		; Address of Voltage scale calibration lo byte
VoltCalH	EQU		$10F9		; Address of Voltage scale calibration hi byte
TempCal		EQU		$10FA		; Address of Temperature offset calibration byte
LinkCal		EQU		$10FB		; Address of Link Voltage offset calibration byte
MHz4CalD	EQU		$10F6		; Uncompressed 4MHz calibration value for version 5 data layout
MHz4CalB	EQU		$10F7		; Unompressed 4MHz calibration value for version 5 data layout
#else	; Assume data layout version 4
; Addresses manually imported from the BSL-writer. Version 4. Keep up to date!
InitRetAddr	EQU		$1020		; Return address when interpretByte is called for initialisation
ReadByte	EQU		$108A		; Calling-address to receive byte in R8
WriteByte	EQU		$10D2		; Calling-address to transmit byte in R8
BSLErase	EQU		$1036		; Jump-in-address for erasing flash and continuing a download
ID			EQU		$1003		; Address of this Cell's/BMU's identification byte
VoltCalL	EQU		$1009		; Address of Voltage scale calibration lo byte
VoltCalH	EQU		$100F		; Address of Voltage scale calibration hi byte
TempCal		EQU		$10A1		; Address of Temperature offset calibration byte
LinkCal		EQU		$10BF		; Address of Link Voltage offset calibration byte
MHz4Cal		EQU		$10D7		; Compressed 4MHz calibration value for version 4 data layout
#endif


; Interpreter Register Usage
;	Registers 0 thru 3 are dedicated machine registers (PC SP SR CG).
#define 	Rip		R5		// Virtual machine instruction pointer
#define 	Rlit	R6		// Holds partial literals
#define 	Rw		R8		// Working register - temporary - anyone can use

#define		LEDWITHTX		1		; True to have LED come on with any transmit byte
#define		ROTATE3			1		; True for later boards that have TXDp, TXDm and BYPASS rotated

#if			ROTATE3
TXDm		EQU		1<<1			; TA0/P1.1
TXDp		EQU		1<<5			; SCLK/P1.5
BYPASS		EQU		1<<0			; P1.0
#else
; The below are how things used to be; can't really run this software on that old hardware
TXDm		EQU		1<<0			; Normally 1<<n with n < 4 for compactness (costs 1 word if not)
TXDp		EQU		1<<1			; Code requires TXD+ bit somewhere to left of TXD- bit
BYPASS		EQU		1<<5			; Bypass transistor on pin P1.5
#endif

RXD			EQU		1<<2			; Receive data on P1.2 (bit number >3 costs 3 words)
LED			EQU		1<<6			; LED on bit 6
info1MHzCalB EQU	0x1002			; Frequency calibration
info1MHzCalD EQU	0x1008			;	for 1 MHz (NO LONGER USED)

; ADC channel numbers
CellVChan	EQU		$7				; ADC channel number for cell voltage
TempChan	EQU		$A				; ADC channel number for temperature
LinkVChan	EQU		$3				; ADC channel number for link voltage
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)
NOBUF		EQU		1				; 1 for no buffer; 0 for buffer

; Serialio definitions
#define		TACCTLr		TACCTL1		// Receive using CCI1 (P1.2)
#define		TACCTLt		TACCTL0		// Transmit (and everything else) using TA0
#define		TACCRt		TACCR0		// Transmit compare register
#define		TACCRr		TACCR1		// Receive capture/compare register

; The following macro gem is due to David Keenan. It is based on a Taylor series expansion.
; It is valid for the domain 1-64, and range 0-6.
; NOTE: it depends in the assembler rounding down on division, even for negative results
; There is a similar simple formula for rounding towards zero
#define LOG2(x) (4 * (x-8) / (x+8) + 3)


;
;			Memory definitions
;
			ORG		$200
#if	!NOBUF
sampleBuf	DS		2*NumSamples	; ADC sample buffer; 4 or 16 samples	// FIXME: remove
#endif
bypassVolts	DS		2				; If non-zero, this is the bypass threshold in mV
RxByteCB	DS		2				; Code pointer for received byte callback
TXData		DS		2				; Byte to transmit in lower byte; always $FF in high byte
									;	NOTE: don't write to this directly except when protected by
									;	TX_Sem
; NOTE: these next two are accessed as a word. Keep on an even boundary, and only ever set to 00 or FF!
bSendBad	DS		1				; $FF if sending badness bytes at all
bMeasureTime DS		1				; $FF if time to measure

TXPrioData	DS		2				; Data for sending (if not $FF) before next TX_Byte
RXData		DS		1				; Received char
BitCntTx	DS		1				; Bit count 10 -> 1
BitCntRx	DS		1				; Bit count 8 -> 1
EchoState	DS		1				; Temp: this will go away
TX_Sem		DS		1				; Semaphore for TX_Byte. 1 = allowed to send.
bCheckForBad DS		1				; Non zero if this is the last cell in a chain and has alarm
currBadness	DS		1				; Current badness
lastSentBad	DS		1				; Last sent badness
ticksSinceLastSend DS 1				; Timer overflow events (~1/4 seconds) since last badness send
ticksSinceLastRx DS	1				; Timer overflow events since last badness received
passWordState DS	1				; State machine for password recogniser
hexFlag		DS		1				; 1 = hex mode (default)
CHKSUM		DS		1				; Packet xor checksum
bCmdBufRdy	DS		1				; Non zero if command buffer (TIB) is ready to process
			EVEN
ToIN		DS		2				; Pointer to current character being stored in Text Input Buffer
TIB			DS		1				; Start of Text Input Buffer, grows towards stack

;-------------------------------------------------------------------------------
			ORG		0F800h					; Program Reset
;-------------------------------------------------------------------------------


main:		mov.w	#0280h,SP				; Initialize stackpointer
StopWDT		mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer

;			MOV.B	&CALBC1_1MHZ, &BCSCTL1 ; Set range for 0.54 to 1.06 MHz
;			MOV.B	&CALDCO_1MHZ,&DCOCTL	; Set DCO step + modulation for 1.00 MHz
#if Mfreq = 1000000
			mov.b	&info1MHzCalB,&BCSCTL1	; Set range for 0.54 to 1.06 MHz
			mov.b	&info1MHzCalD,&DCOCTL	; Set DCO step + modulation for 1.00 MHz
#else										; Else frequency is 4MHz
#if			DATAVERS5
			mov.b	&MHz4CalB,&BCSCTL1		; Version 5: just copy
			mov.b	&MHz4CalD,&DCOCTL		;	the two bytes
#else
			mov.b	&MHz4Cal,R8				; Compressed 4MHz calibration data
			rla		R8						; Uncompress
			bis		#$8A00,R8				; OR in most significant bits
			swpb	R8						; Get MSB (might be important to write first)
			mov.b	R8,&BCSCTL1				; Write MSB
			swpb	R8
			mov.b	R8,&DCOCTL				; and LSB
#endif
#endif

			; DIVS_0 => SMCLK = DCOCLK/1	DIVS_1 -> SMCK = DOCLK/2
			; Other zero bits select MCLK = DCOCLK/1
			mov.b		#LOG2(MckPerSMck)*DIVS_1, &BCSCTL2

			; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
			; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
			; MC: 2 = continuous mode 1 = up mode
			; TAIE = interrupt enable (for timer overflow)
			mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2 + TAIE, &TACTL
			
			; Set up differential timer outputs for transmit data.
			; Tricky way of getting inverted TA0 to appear on P1.5 automatically
			; when TA0 appears on P1.1.
			; We use the clock inverter in the USI (Universal Serial Interface)
			; to invert TA0 and put it out as SCLK, in SPI master mode.
			; We don't use the shift register of the USI because there is
			; no way to get differential outputs from that without external hardware.
			mov.b	#USIPE5 + USIMST, &USICTL0	; SCLK out on P1.5, SPI Master mode, remove SW Reset
			mov.b	#USIDIV_0 + USISSEL_5 + USICKPL, &USICKCTL ; SCLK source is TA0, div by 1, inverted
			mov.b	#8, &USICNT					; To clear USIIFG so SCLK will not be held

			; Make TA0 (output of Timer-A capture/compare unit 0) appear on P1.1
			; We want to set the CCIFG so that TX_Byte won't
			; belive that this value is the end of a previous stop bit
			mov		&TAR,&TACCRt				; Make an output event
			add		#4,&TACCRt					;	happen in a dozen or so instructions
			; NOTE: the above has to be enough to get past clearing of TACCTLt below
			mov.b	#RXD+TXDm,&P1SEL			; Select timer functions CCI1A and TA0 (not I/O port)
			bis.b	#TXDp+TXDm+LED+BYPASS,&P1DIR ; TXD, LED and BYPASS are outputs
			clr.b	&P1OUT						; Clear LED and bypass
#if 1
			mov.w	#OUTMOD_0 + OUT, &TACCTLt	; TXD=1 Space; seems necessary to "wake up" divider
			mov.w	#OUTMOD_0, &TACCTLt			; TXD=0 Idle or Mark		(for the internal inverter)
#endif
			mov.w	#OUTMOD_5, &TACCTLt			; When the compare happens, set TXD=0 =Idle or Mark

			mov.b	#$FF,&TXData+1				; Initialise the top half of TXData to all 1s (stop bit,
												;	idle bit)
			mov.b	#1,TX_Sem					; Initialise transmit semaphore

;
; Setup RX
;
			mov.b	#08,&BitCntRx			; Load Bit Counter, 8 data bits
SetupRX		mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&TACCTLr	; Falling edge, Input A, Sync, Capture

;
; Setup TX
			mov.w	#$FFFF,&TXPrioData		; FF means no priority data to send

;
; Setup the stripped-down bytecode interpreter
;
			mov.b	#1,&hexFlag				; Hex mode by default
			clr.b	&CHKSUM
			mov		#TIB,&ToIN				; Packet pointer

;
; Miscellaneous initialisation
;
			mov		#OnRxByte,&RxByteCB		; Initialise the RX byte code pointer
			clr		&bypassVolts			; No special bypass voltage as yet
			clr.b	&currBadness			; Current badness is none
			clr.b	&lastSentBad			; Last badness we sent was zero
			clr.b	&bCheckForBad			; Not checking for badness and last BMU in chain
			clr.b	&ticksSinceLastSend
			clr.b	&ticksSinceLastRx
			mov.w	#-1,&bSendBad		; Initialise bSendBad and bMeasureTime
			mov.b	#3,&passWordState		; Waiting for first byte of ^b ^a ^d sequence
			clr.b	bCmdBufRdy				; No command waiting

			; Fall through to the idle loop

idleLoop:
			; Note: the below reads two byte addressable variables at once
			cmp.w	#-1,&bSendBad			; Check if sending regular badness, and time to send
			jne		noMeasure				; If not, skip measurement and set/clear of bypass
			clr.b	bMeasureTime
			call	#measures

noMeasure
			; Check if processing a completed command buffer
			tst.b	&bCmdBufRdy
			jz		noCmdExec
			MOV		&ToIN,R9
#if CHECKSUM
			TST.B	&CHKSUM
			_IF		_Z					; If good checksum
				DEC		R9				;	Prepare to overwrite the checksum with an EXIT bytecode
				CMP		#TIB,R9			;	Handle case of empty packet with no checksum
				_IF		_LO
					MOV		#TIB,R9
				_ENDIF
#endif
				MOV.B	#EXIT,0(R9) 	; Overwrite checksum or carriage return with an EXIT bytecode
				MOV		#TIB,Rip		; Interpret the packet as bytecode
				CALL	#_ENTER
#if CHECKSUM
			_ENDIF						; Endif (good checksum)
#endif
			MOV		#TIB,&ToIN			; Initialise packet buffer pointer
			CLR.B	&CHKSUM				; Clear the packet checksum
			clr.b	&bCmdBufRdy

			; It could be that there is measurement ready by now. Don't sleep if that is the case
			cmp		#-1,bSendBad		; OK to write to TIB again
			jeq		idleLoop

noCmdExec	bis		#CPUOFF+GIE,SR			; Turn off CPU, enable interrupts
			jmp		idleLoop


measures:
;
; Regular measurement goes here
; Called about 4 times per second
;
			inc.b	&ticksSinceLastSend		; Increment these counters
			inc.b	&ticksSinceLastRx
			_IF		_Z						; Wrapped around to 0?
				mov.b	#$FF,&ticksSinceLastRx	; Yes, saturate at $FF
			_ENDIF

			mov		#CellVChan<<12,R8
			call	#measAndCal
			mov		&bypassVolts,R8			; Get the current bypass threshold, if any
			tst		R8
			_IF		_Z
				mov		#3600,R8				; Default of 3.6 V
			_ENDIF
#if 1
			cmp		R8,R10
			_IF		_HS						; If the current cell voltage R10 >= R8 the bypass threshold
				bis.b	#BYPASS,&P1OUT		;   Turn on the bypass resistors
			_ELSE							; Else
				bic.b	#BYPASS,&P1OUT		;   Turn off the bypass resistors
			_ENDIF							; Endif
#else
			cmp		R10,R8					; Is the current cell voltage >= the bypass threshold?
			subc	R8,R8					; If so, carry was clear and we get -1 here, else 0
			xor.b	&P1OUT,R8				; Which bits differ
			and		#BYPASS,R8				; Only BYPASS left on, and only if wrong
			xor.b	R8,&P1OUT				; Change if necessary
#endif
			; Overvoltage badness: for every 50 mV over 3.60 V, we add one level of badness, to a maximum of 7 for > 3.95 V
			mov		R10,R9					; Measurement
			sub		#3650-49,R9				; Cell voltage - 3.6 V + 49 mV for rounding
			_IF		_L
				clr		R9						; Minimum of zero
			_ENDIF
			push	R10						; Save measurement
			clr		R10						; R10:R9 has meas - 3.6
			mov		#50,R8
			call	#UMSlashMod				; (meas - 3.6) / 50 -> R9
			mov		R9,R15					; Keep this partial badness

			; Undervoltage badness: for every 100 mv below 2.5 V, we add one level of badness, to a maximum of 7 for < 1.9 V
			pop		R10						; Original measurement
			mov		#2500+99,R9
			sub		R10,R9					; R9 has 2.5 V - meas plus 99 for rounding
			clr		R10						; R10:R9 has this
			_IF		_L
				clr		R9						; Minimum of zero
			_ENDIF
			mov		#100,R8
			call	#UMSlashMod				; (2.5 V - meas) / 100 -> R9
			cmp		R9,R15					; Which badness is worse?
			_IF		_GE
				mov		R15,R9				; Worst to R9
			_ENDIF
			
			; Temperature measurement
			push	R9
			mov		#TempChan<<12, R8
			call	#measAndCal
; Scale it back to degrees Celsius. Typically, T = (V-Voff)/.00355 where Voff = 0.986
; But the measurement M is 4096* V/1.5 = 2731*V.
; So T = (M/2731 - Koff1)*281.7 = M/9.694 - Koff2
; To divide by 9.694, multiply by 65536/9.694 = 6760, and keep the top half
			mov		R10,R8
			mov		#6760,R9
			call	#UMStar					; R10:R9 = meas*6760 so M/9.694 to R10
			sub		#273,R10				; M/9.694 - 273
			mov.b	&TempCal,R8
			sxt		R8
			sub		R8,R10					; R10 has temperature in degrees Celsius
			; Temperature badness: 1 for every 2 degrees over 60
			sub		#60-1,R10				; -1 for rounding
			_IF		_L
				clr		R10					; Minimum of 0
			_ENDIF
			rra		R10
			pop		R9						; Restore current worst badness
			cmp		R10,R9					; Is temp badness worse than current?
			_IF		_NC
				mov		R10,R9					; Yes, new worst
			_ENDIF


			; Link measurement, if appropriate
			cmp		#$80,&LinkCal			; Special "calibration failure" code?
			_IF		_NE						; Only measure link voltage if not this code
				; Link voltage measurement in mV
				; Circuit has 2:1 voltage divider with Vref at the bottom.
				; So meaure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
				; Reading = 2048 + (Vin/2)(4096/1.5)
				; R = 2048 + Vin * 1365.3 (Vin in volts)
				; R = 2048 + Vin * 1.3653 (Vin in mV)
				; Vin = (R - 2048)/1.3653 mV
				; To divide by 1.3653, multiply by 65536/1.3653 = 48001 and keep the top half
				push	R9
				mov		#LinkVChan<<12, R8
				call	#measAndCal
				sub		#2048,R10			; R10 has M-2048
				mov.b	&LinkCal,R8
				sxt		R8
				sub		R8,R10				; R10 has M-2048-LinkCal
				_IF		_L
					inv		R10					; Get absolute value
					inc		R10
				_ENDIF
				mov		R10,R8				; R8 has R-2048-LinkCal
				mov		#48001,R9
				clr		R10					; R10:R9 has 48001
				call	#UMStar				; R10 has absolute link voltage in mV
				; Link badness: 1 for every 50 mV over 100 mV
				sub		#100-49,R10
				_IF		_L
					clr		R10					; Minimum of 0
				_ENDIF
				mov		R10,R9
				clr		R10
				mov		#50,R8
				call	#UMSlashMod
				pop		R8					; Current worst badness
				cmp		R8,R9
				_IF		_NC
					mov		R8,R9
				_ENDIF
			_ENDIF

			cmp		#7,R9					; Is the overall badness worse than 7?
			_IF		_GE
				mov		#7,R9					; Yes, use 7
			_ENDIF
			mov.b	R9,&currBadness

			; Comms badness: 1 if no badness RX for 10 ticks and we are not ID 0
			cmp.b	#10,&ticksSinceLastRx	; Been 10+ ticks since last Rx?
			_IF		_C
				tst.b	&ID						; Only if ID
				_IF		_NZ						;	is nonzero...
					tst		R9						; Yes, are we at badness zero?
					_IF		_Z
						mov		#1,R9				; Yes, make it 1 for the comms error
					_ENDIF
				_ENDIF
			_ENDIF

			mov.b	badnessTable(R9),R9		; Look up the encoded badness
			cmp.b	R9,&lastSentBad			; Is this worse than the last badness we sent?
			jnc		sendBadnessNow			;	Jump if so to send the badness immediately

			cmp.b	#10,&ticksSinceLastRx	; Been 10+ ticks since last Rx?
			_IF		_C
				cmp.b	#4,&ticksSinceLastSend
				_IF		_C
sendBadnessNow		clr.b	&ticksSinceLastSend
					mov.b	R9,&lastSentBad			; Update remembered value
					mov.b	R9,R8			
					call	#TX_Byte				; Send the encoded badness
				_ENDIF
			_ENDIF
			
			ret

			; Encoded badness table. The badness information is transmitted in one byte,
			; with no checksum correction. To counter this, badness is encoded, so that only
			; eight of the 128 possible raw badness codes ($80 - $FF) are valid. Other codes
			; are treated as a corrupted attempt to send badness information; current badness
			; for this BMU is sent instead.
			; The table is indexed by raw badness value (i.e. the least significant 3 bits of
			; the encoded badness byte).
badnessTable DB		$80			; $80 is least badness
			DB		$91,$A2,$B3,$C4,$D5,$E6
			DB		$F7			; $F7 is the worst badness

;
;	Callback routine for received byte.
;	Process badness channel, and execute commands.
OnRxByte:
			push	R8
			push	R9
			mov.b	&RXData,R8
			tst.b	R8					; Test for badness command ($80-$F7)
			_IF		_L					; If negative (i.e. badness)
				clr		&ticksSinceLastRx	; Now no time since last received badness
				mov.b	R8,R9				; Copy incoming badness
				and		#7,R9				; Consider only raw badness bits
				cmp.b	R8,badnessTable(R9); Is it valid? (Tested after 2 intervening instructions)
				mov.b	&currBadness,R9		; Current badness
				mov.b	badnessTable(R9),R9	; Present encoded badness
				jne		sendMyBadness		; NO! So just send my badness instead
				cmp.b	R8,R9				; Compare incoming badness to ours
				_IF		_C					; If incoming is less bad than us,
sendMyBadness		mov		R9,R8				; then we are worse; send our badness
				_ENDIF
				mov.b	R8,&lastSentBad		; Remember that we sent this
			_ENDIF
			call	#TX_ByteNW			; echo/send the byte, no waiting
			tst.b	R8					; Is R8
			_IF		_L					;		a badness?
				tst.b	&bCheckForBad		; Are we checking
				_IF		_NZ					;	for badness (because we're the last BMU)?
					call	#m_alarm			; Yes, set or clear the alarm based on R8
				_ENDIF
				jmp		exitOnRx			; No further processing of badness byte
			_ENDIF
	;
	; Check for a password character
	; After decrementing passWordState below, 2 = waiting for ^B, 1 = waiting for ^A,
	; 0 = waiting for ^D and erase if received. We should not receive any negative value
	;
			dec.b	&passWordState
			jn		resetFSM			; This should never happen! Just reset FSM and
										; process as an ordinary command

			; Check for a continuing password match
			mov.b	&passWordState,R9
			cmp.b	PWtable(R9),R8		; Check against table
			jnz		resetFSM			; If mismatch, jump and reset FSM
			tst		R9					; Are we now at state 0?
			jnz		exitOnRx			; If not, this was a valid password byte, but not the last.
										;	Just exit this callback and wait for more
			; Jump to the code in the BSL which will erase main flash memory and wait for more bytes
			;	without using interrupts.
			; May be important: it could be bad to have receive interrupts sending badness bytes after
			;	this last password byte goes out; it could be interpreted as a byte to flash program!
			clr		&TACCTLr			; Clear at least the CCIE RX interrupt enable bit
			; Important: wait for the last password byte to be echoed before disabling interrupts!
			call	#waitTxCmpl

			dint
			clr		&TACTL				; Disable the timer completely; may use less power
			mov.b	#TXDp,&P1OUT		; Set TXD to idle, bypass and error LED off
			clr.b	&P1SEL				; Make P1.1 ordinary I/O now
			bic.b	#USIPE5,&USICTL0	; Make P1.5 ordinary I/O also
			clr		R15					; The BSL uses R15 as its FSM state variable
			mov		#$280,SP			; Give the BSL maximum stack
			br		#BSLErase			; Jump into the BSL to finish the download

resetFSM	mov.b	#3,&passWordState	; No password match; reset state machine

			; Process ordinary command bytes here, via the stripped down bytecode interpreter
			; It won't execute the buffer; that's deferred to mainline
			tst.b	&bCmdBufRdy			; Is a command buffer execution already in progress?
			jnz		exitOnRx			;	If so, don't accept more chars (would corrupt executing buf)
			call	#ACCEPT
	
exitOnRx	pop		R9
			pop		R8
			reti						; Callback functions end with reti, to preserve flags

PWtable:	db		'd'-$60, 'a'-$60, 'b'-$60	; This is the password in reverse order that the FSM
												;	is looking for
			EVEN


measAndCal:
			call		#measure				; Defined in ../common/measure.s43
;
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
			mov.b		&VoltCalL,R9			; Get voltage calibration lo byte
			mov.b		&VoltCalH,R10			; Get voltage calibration hi byte
			swpb		R10						; Assemble the two bytes into a word
			bis			R10,R9					; as multiplicand in R9
												; Multiplier is sum-of-samples, already in R8
			call		#UMStar					; Gives unsigned product in R10 (hi word) and R9 (lo word)
												; Note: calls assembler code that ends in ret
			inc			R10						; For correct rounding
			rra			R10						; Shift product hi word right one bit
	
			ret					; Finished

;
; UM*	Unsigned multiply
; Starts with 16 bit multiplicand in R8, multiplier in R9 and
; ends with 32 bit product in R10 (hi) and R9 (lo).
; Algorithm described in http://cs.hiram.edu/~walkerel/cs252/multiply.ppt
; 138 to 154 cycles

UMStar:							; (4) Call
			clr		R10			; (1) Clear hi word of product so far
UMStarPlus:	mov		#16,R11		; (2) Do 16 times

mullp		bit		#1,R9		; (1) Test low bit of multiplier
			jz		mulz		; (2) If it's a 1
			add		R8, R10		; (1)   add multiplicand to product hi word; Endif
mulz		rrc		R10			; (1) Shift product hi word (incl. carry) right
			rrc		R9			; (1) into product lo and simul. shift multiplier right
			dec		R11			; (1) Decrement loop counter
			jnz		mullp		; (2) Loop until zero
			ret					; (3)

;
; UM/MOD ( ud u1 -- u2 u3 )
; R10:R9 / R8 -> R9, remainder to R10. Clears R11
; Divide ud by u1, giving the remainder u2 and the quotient u3.
; All values and arithmetic are unsigned. An ambiguous condition exists
; if u1 is zero or if the quotient lies outside the range of a single
; unsigned integer.
; In this case we return $FFFF for both quotient and remainder.
; Algorithm is from eForth by Bill Muench.
; It is essentially the reverse of the multiplication algorithm above.
; 172 to 204 cycles (excluding overflow or div by zero)

UMSlashMod:						; (4) Call
			cmp		R8,R10		; (1) Overflow?
			jc		oflo		; (2) Jump to error exit if divide by zero or overflow.
			mov		#16,R11		; (2) Do 16 times
	
ummlp		rla		R9			; (1) Shift quotient left and simul. shift dividend lo
			rlc		R10			; (1)   into dividend hi
			jc		umm2		; (2) If carry OR
			cmp		R8,R10		; (1)
			jlo		umm1		; (2) no carry AND remainder-so-far >= divisor
umm2		sub		R8,R10		; (1)	Subtract divisor from remainder-so-far
			bis		#1,R9		; (1)	Set low bit of quotient-so-far
								;	  Endif
umm1		dec		R11			; (1) Decrement loop counter
			jnz		ummlp		; (2) Loop until zero
			ret					; (3)
	
oflo		mov	#-1,R9			; (1)
			mov	#-1,R10         ; (1)
			ret					; (3)


;
; Process alarm; R8 has unencoded badness. Trashes R8
m_alarm:
			cmp		#2,R8			; Carry set if badness >= 2
#if 1
			_IF		_HS
				MOV	#OUT,&TACCTLt
			_ELSE
				CLR	&TACCTLt
			_ENDIF
#else
			subc	R8,R8			; -1 if badness >= 2
			inv		R8				; 0 if badness >= 2, -1 otherwise
			and		#OUT,R8			; Clear all but OUT bit
			mov		R8,&TACCTLt		; Set TXn to 0 if badness >= 2
#endif
			ret


#include "serialio.s43"				// Comms routines
#include "../common/measure.s43"	// Voltage measurement functions
#include "BytecodeInterpreter2.s43" // Cutdown bytecode interpreter. No bytecodes defined in bytecode
#include "definitions.s43"			// Bytecode definitions




freespace	EQU		_OPCODETBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/2048)

;-------------------------------------------------------------------------------
;			Interrupt Vectors
;-------------------------------------------------------------------------------
			ORG		0FFF0h				; Timer A Vectors
			DW		RX_TIOV_ISR			; Combined CC1IFG (receive capture/compare) & TAIFG (overflow)
			DW		TX_ISR				; Timer A CC0IFG (transmit compare)
;			There are 10 bytes here that could be used if desperate
			ORG		0FFFEh				; MSP430 RESET Vector
			DW		0x1000				; Reset to BSL in case there is a crash



			END
