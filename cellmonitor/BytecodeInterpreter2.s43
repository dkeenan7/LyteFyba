; Contains both an outer (packet) interpreter with backspace editing
; and a cutdown inner (bytecode) interpreter.
; The bytecode interpreter does not allow nested bytecode definitions,
; i.e. a bytecode can only be defined in machine code, not bytecode.

#define		CHECKSUM	0		; 1 to require a checksum immediately before end-of-line/packet

;-------------------------------------------------------------------------------
;
; Status flag usage
;
; Bit 15 = literal in progress

; Macros for 3-register interpreter data stack
; Not used yet
; Not sure which choice of registers is best
#if 1
	#define 	Rtos	R7		// Top element of data stack
	#define 	Rsec	R4		// Second element from top
	#define 	Rthd	R13		// Third element from top
#else
	#define 	Rtos	R8		// Top element of data stack
	#define 	Rsec	R9		// Second element from top
	#define 	Rthd	R10		// Third element from top
#endif

DPUSH		MACRO	arg
			mov		Rsec,Rthd
			mov		Rtos,Rsec
			mov		arg,Rtos
			ENDM
			
DROP		MACRO
			mov		Rsec,Rtos
			mov		Rthd,Rsec
			ENDM
			
SWAP		MACRO
			xor		Rtos,Rsec
			xor		Rsec,Rtos
			xor		Rtos,Rsec
			ENDM
			
DUP			MACRO
			mov		Rsec,Rthd
			mov		Rtos,Rsec
			ENDM
			
OVER		MACRO
			mov		Rsec,Rthd
			mov		Rtop,Rsec
			mov		Rthd,Rtop
			ENDM

NIP			MACRO
			mov		Rthd,Rsec
			ENDM
			
TUCK		MACRO
			mov		Rtos,Rthd
			ENDM

ROT			MACRO
			xor		Rsec,Rthd
			xor		Rthd,Rsec
			xor		Rsec,Rthd
			xor		Rtos,Rsec
			xor		Rsec,Rtos
			xor		Rtos,Rsec
			ENDM

MinusROT	MACRO
			xor		Rtos,Rsec
			xor		Rsec,Rtos
			xor		Rtos,Rsec
			xor		Rsec,Rthd
			xor		Rthd,Rsec
			xor		Rsec,Rthd
			ENDM

;-------------------------------------------------------------------------------
; Opcode-table Macros

; The opcode lookup table is in high memory.
; It contains one word per bytecode from $60 to $7F, which is the address of the code that implements
; the operation.

_OPCODETBL	EQU		$FFF0-$40				; Immediately below lowest used interrupt vector

; The "x" at the start of the following macro names stands for "cross-compiling"
; to distinguish them from possible native versions on the MSP430 in other versions.
; The name "CODE" is from Forth.


; Assemble an opcode-table entry that has a machine-code definition.

xCODE	MACRO	OPCODE,OPCODENAM,_ADDRLBL
						LSTOUT-
		EVEN								; Force to word boundary
_ADDRLBL:									; Define the machine-code address label
OPCODENAM EQU	OPCODE						; Define the opcode name
		ORG		_OPCODETBL-($60*2)+(OPCODE)*2	; Point to correct opcode-table entry
						LSTOUT+
		DW		_ADDRLBL					; Assemble the address
						LSTOUT-
		ORG		_ADDRLBL					; Point back to where the machine code will be assembled
						LSTOUT+
						ENDM
#if 0
; Variables in RAM. These are copied in monitor.s43
hexFlag		DS		1				; 1 = hex mode (default)
CHKSUM		DS		1				; Packet xor checksum
bCmdBufRdy	DS		1				; Non zero if command buffer (TIB) is ready to process
			ALIGNRAM 1
ToIN		DS		2				; Pointer to current character being stored in Text Input Buffer
TIB			DS		32				; Start of Text Input Buffer, grows towards stack
#endif

;-------------------------------------------------------------------------------
; The inner (bytecode) interpreter

; Bytecode interpreter for 7 bit bytecodes
_ENTER
_NEXT	MOV.B	@Rip+,Rw	; Fetch the next bytecode
		CMP.B	#$60,Rw		; Treat all bytecodes other than `a-z{|}<DEL>
		JLO		DoUNDEF		;	as undefined, and try to interpret as digits
		
_RUN	RLA.B	Rw			; Multiply bytecode by 2
FncOPCD MOV _OPCODETBL-($60*2)(Rw),Rw ; Use 2*bytecode to index the opcode-table to get
							;	the code address
		CMP		#$FFFF,Rw	; Check for undefined bytecodes
		JNE		FncLIT		; If undefined and >= $60
NotDigit MOV	#_Space,Rw	;		Treat as literal-separator no-op

FncLIT	TST		SR			; Check for an implied push-literal
		JGE		DoOPCD		; If there's an operand-in-progress
							;	there's an implied LIT now
		BIC		#1<<15,SR	;	Clear the operand-in-progress flag
;		PUSH	Rtos		;	Push the operand now, before doing the
;		MOV		Rlit,Rtos	;	operation
		DPUSH	Rlit

DoOPCD	CALL	Rw			; Call the machine-code implementation of the bytecode
							; It must end with an RTS
		JMP		_NEXT

DoUNDEF ; Attempt to interpret undefined bytecodes as hex/decimal digits,
		; otherwise treat them as literal-separating no-ops.
		SUB.B	#'0',Rw	; '0'-'9','A'-'F' -> $0-$9,$11-$16
		JN		NotDigit	; Ignore undefined bytecodes below '0'
		CMP.B	#$0A,Rw
		_IF		_GE
			CMP.B	#$17,Rw
			JGE		NotDigit ; Ignore undefined bytecodes above 'F'
			CMP.B	#$11,Rw
			JL		NotDigit ; Ignore undefined between '9' and 'A'
			SUB.B	#'A'-('9'+1),Rw	; $11-$16 -> $0A-$0F
		_ENDIF
		
FncPFX4 TST		SR			; Test the operand-in-progress flag
		BIS		#1<<15,SR	; Set the operand-in-progress flag
		JN		DatMor4		; If there was no operand-in-progress

DatFst4 MOV		Rw,Rlit		;	Move 4-bit data to partial-operand register
		JMP		_NEXT		; Else (operand-in-progress)

DatMor4 rla		Rlit		;	Multiply the partial operand by 16 or 10
		mov		Rlit,R9		;	Save 2*Rlit in R9
		rla		Rlit		;	4*Rlit
		rla		Rlit		;	8*Rlit
		tst.b	&hexFlag
		_IF		_Z
			add		R9,Rlit	;	10*Rlit
		_ELSE
			rla		Rlit	;	16*Rlit
		_ENDIF
		add		Rw,Rlit		;	Add data into operand reg
DatEnd4 jmp		_NEXT		; Endif


;-------------------------------------------------------------------------------
; The outer (packet) interpreter
; ACCEPT	( char -- )	; Accept the character in R8 into the line buffer.
; Trashes R8 and R9
; Implements backspace editing and calls the inner interpreter
; to interpret the line when a valid checksum and a carriage return are received.
ACCEPT
;		PUSH	R8				; No need to save R8, and stack space is tight
		MOV		&ToIN,R9
		_CASE
		
		_OFb	#$0D,R8			; Carriage return = end of packet
#if CHECKSUM
			TST.B	&CHKSUM
			_IF		_Z					; If good checksum
				DEC		R9				;	Prepare to overwrite the checksum with an EXIT bytecode
				CMP		#TIB,R9			;	Handle case of empty packet with no checksum
				_IF		_LO
					MOV		#TIB,R9
				_ENDIF
#endif
				MOV.B	#EXIT,0(R9) 	; Overwrite checksum or carriage return with an EXIT bytecode
				MOV		#TIB,Rip		; Interpret the packet as bytecode
				CALL	#_ENTER
#if CHECKSUM
			_ENDIF						; Endif (good checksum)
#endif
			MOV		#TIB,&ToIN			; Initialise packet buffer pointer
			CLR.B	&CHKSUM				; Clear the packet checksum
		_ENDOF					; End Of carriage return
		
		_OFb	#$08,R8			; Backspace editing
			DEC		R9			; Decrement the pointer, but
			CMP		#TIB,R9		; don't go back past start of packet
			_IF		_LO
				MOV		#TIB,R9
			_ENDIF
			MOV		R9,&ToIN
		_ENDOF					; End Of backspace
		
		; Default case, if not CR or BS
			MOV.B	R8,0(R9)	;	Write the byte to the buffer
			INC		&ToIN		;		Increment the pointer
			XOR.B	R8,&CHKSUM	;	Accumulate the checksum		

		_ENDCASE				; End Case char

;		POP R8
		RET
		


