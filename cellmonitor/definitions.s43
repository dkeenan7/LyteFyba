;
; Bytecode definitions
;

; EXIT ( -- ); Return from a bytecode sequence

		xCODE	'|',EXIT,_EXIT ; Vertical bar
		incd	SP			; Drop the return address within the interpreter
		ret					; Return to whoever called the interpreter (_ENTER)
		
; HEX ( flag -- ) ; Set the hexadecimal (vs decimal) input mode flag

		xCODE	'h',HEX,_HEX
		mov.b	Rtos,&hexFlag
;		pop		Rtos
;		DROP
_Space	ret					; When _Space is called, be a no-op (for separating literals)

; CLIT ( -- c ) ; Character literal. Treat the next bytecode as a literal character.

		xCODE	'`',CLIT,_CLIT ; back-quote or tock
;		PUSH	Rtos
;		MOV.B	@Rip+,Rtos
		DPUSH	@Rip+
		ret
		
; EMIT ( c --)	; Emit the character on top of stack

		xCODE	'e',EMIT,_EMIT
		mov.b	Rtos,R8
		call	#TX_Byte
;		pop		Rtos
;		DROP
		ret
		
; aUtonomous mode badness sending (n --)
		xCODE	'u',auton,_auton
		mov.b	Rtos,&bSendBad
;		pop		Rtos
		DROP
justRet	ret
		
;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		; This is actually longer in bytecode
		xCODE		's',Select,_Select
		cmp.b		&ID,Rtos			; Correct ID?
;		pop			Rtos				; Pop the argument
		DROP							; Pop the argument
		jz			justRet				; If so, just continue interpreting rest of packet
		incd		SP
		RET								; Return to the outer interpreter (i.e. ignore rest of packet)

;
; Turn on or off the error LED (bool -- )
;
		xCODE	'l',errorLed,_errorLed
		call	#waitTxCmpl			; If this is called interactively, wait for CR to completely echo
		and		Rtos,Rtos			; Clears carry if was zero
		subc	Rtos,Rtos			; -1 if was 0, 0 otherwise
		inv		Rtos				; 0 if was 0, -1 otherwise
		xor.b	&P1OUT,Rtos			; Rtos has all the bits that are different
		and.b	#LED,Rtos			; Leave only LED bit standing
		xor.b	Rtos,&P1OUT			; Toggle if necessary
;		pop		Rtos				; Remove operand
		ret

;
; Turn on or off bypass resistors (bool -- )
;
		xCODE	'y',bypass,_bypass
		and		Rtos,Rtos			; Clears carry if was 0
		subc	Rtos,Rtos			; -1 if was 0, 0 otherwise
		inv		Rtos				; 0 if was 0, -1 otherwise
		xor.b	&P1OUT,Rtos			; Rtos has all the bits that are different
		and.b	#BYPASS,Rtos		; Leave only BYPASS bit standing
		xor.b	Rtos,&P1OUT			; Toggle if necessary
;		pop		Rtos				; Remove operand
		ret



		
;
; emitDec  ( n count -- ) ; Emit an integer n as count decimal digits
; Trashes R8-R12

		xCODE	'm',emitDec,_emitDec
		mov		Rtos,R12			; Count to R12
;		pop		Rtos
		tst		Rsec				; Is n negative?
		_IF		_L
			mov		#'-',R8				; Emit minus sign
			call	#TX_Byte
			inv		Rsec
			inc		Rsec				; Negate
		_ENDIF
		mov		Rsec,R9					; R10:R9 will have n initially
		; Leave Rtos on the machine stack for now, so we can use it as a temp
;		mov		R12,Rtos			; Copy count
		mov		#10,R8
		dec		R12					; Count-1
eDecLoop1
		clr		R10
		call	#UMSlashMod			; dividend/10 -> R9, remainder to R10
		push	R10					; Push remainder
		dec		R12
		jnz		eDecLoop1			; R9 keeps quotient as next dividend
		push	R9
		; Now we have n results on the stack; print these as decimal
eDecLoop2
		pop		R8
		add		#'0',R8
		call	#TX_Byte
		dec		Rtos
		jnz		eDecLoop2
;		pop		Rtos
		ret

;
; Pretty print n as a comment packet with m digits and follow with ch (ch n m--)
;
		xCODE	'p',prettyPrint,_prettyPrint
		mov		#'|',R8				; Initial vertical bar
		call	#TX_Byte			; (interpreted as comment character)
#if 0
		push	#postED1			; Push return address
		push	Rtos				; Push m
		push.b	&ID					; Put ID on stack
		mov		#3,Rtos				; 3 digits
		jmp		_emitDec			; Call _emitDec (return address already pushed)
postED1
#else
		push	Rthd				; Save ch
		push	Rsec				; Save n
		push	Rtos				; Save m
		mov.b	&ID,Rsec
		mov		#3,Rtos
		call	#_emitDec
#endif
		mov		#':',R8				; Colon separator
		call	#TX_Byte
#if 0
		; ret-addr-for-prettyPrint ch n m -- (m in Rtos)
		push	2(SP)				; Duplicate n. Note: SP is decremented before arg is read
		mov		4(SP),2(SP)			; Copy ch over old n
		mov		#postED2,4(SP)		; Move postED2 (return address) over old ch
		; ret-adr-for-prettyPrint postED2 ch n m -- (m in Rtos)
		jmp		_emitDec			; Emit the result (n and m are on the stack)
		mov		Rtos,R8				; ch to R8
		pop		Rtos
postED2
#else
		pop		Rtos				; Restore m
		pop		Rsec				; Restore n
		call	#_emitDec
		pop		R8					; Restore ch
#endif
		call	#TX_Byte
		mov		#'\r',R8			; Carriage return to R8
		call	#TX_Byte			; Emit // and return
		call	#waitTxCmpl			; Wait for transmit complete
		bis.b	#LED,&P1OUT			; Set the LED here to mimic old behaviour
									; Identifies the BMU that sent a response
		ret
		
;
; Low level voltage measurement (channel -- measurement)
; Channel has channel number shifted left 12 bits (e.g. $7000 for cell voltage)
; Channel 7 is currently cell voltage; 10 is temperature sensor
; Measurement is in millivolts (0 to 4095 mV)
;
		xCODE		'o',llVolt,_llVolt
		mov			Rtos,R8
		call		#measAndCal			; Measure and use calibration
		mov			R10,Rtos
		ret
		
;
; cellVolt ( -- )
; Transmit the cell voltage measurement in millivolts (0 to 4095 mV)
;
		xCODE		'v',cellVolt,_cellVolt
#if 0
		push		Rtos
		push		#'V'				; Units are volts
#endif
		mov			#CellVChan<<12,Rtos	; ADC channel for cell voltage divider
		call		#_llVolt
#if 0
		push		Rtos
		mov			#4,Rtos				; Print 4 digits
#else
		mov			#'V',Rthd			; Units are volts
		mov			Rtos,Rsec			; Result
		mov			#4,Rtos				; Print 4 digits
#endif
		jmp			_prettyPrint		; Pretty print and return

;
; Cell temperature measurement ( -- )
; Measurement is in degrees C
;
		xCODE		't',cellTemp,_cellTemp
#if 0
		push		Rtos
		push		#'C'				; Don't use degree symbol (0xF8, Terminal font only);
										;	it's treated as a badness
#endif
		mov			#TempChan<<12,Rtos	; ADC channel for temperature sensor
		call		#_llVolt
;
; Scale it back to degrees Celsius. Typically, T = (V-Voff)/.00355 where Voff = 0.986
; But the measurement M is 4096* V/1.5 = 2731*V.
; So T = (M/2731 - Koff1)*281.7 = M/9.694 - Koff2
; To divide by 9.694, multiply by 65536/9.694 = 6760, and keep the top half

		mov			Rtos,R9			; Don't pop; replace with number of digits to print
		mov			#6760,R8
		call		#UMStar
		; Most significant half is in R10
		; Temperature offset is now offset by 273
		sub			#273,R10
		mov.b		&TempCal,R8		; Temp offset calibration
		sxt			R8				; Sign extend
		sub			R8,R10
#if 0
		push		R10
#else
		mov			#'C',Rthd			; Don't use degree symbol (0xF8, Terminal font only);
										;	it's treated as a badness
		mov			R10,Rsec
#endif
		mov			#3,Rtos			; 3 digits
		jmp			_prettyPrint	; Pretty print and exit


;
; Link voltage measurement ( -- )
; Measurement is in mV
; Circuit has 2:1 voltage divider with Vref at the bottom.
; So meaure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
; Reading = 2048 + (Vin/2)(4096/1.5)
; R = 2048 + Vin * 1365.3 (Vin in volts)
; R = 2048 + Vin * 1.3653 (Vin in mV)
; Vin = (R - 2048)/1.3653 mV
; To divide by 1.3653, multiply by 65536/1.3653 = 48001 and keep the top half

		xCODE		'n',linkVolt,_linkVolt
#if 0
		push		Rtos
		push		#'m'			; Units are millivolts
#endif
		mov.b		&LinkCal,R8		; Link offset calibration
		cmp			#$80,R8			; $80 is a special value representing "calibration failure"
		_IF			_EQ				; If link calibration value is $80
			clr		R10					; then use value 0
		_ELSE
			mov			#LinkVChan<<12,Rtos	; Shifted ADC channel for link voltage divider
			call		#_llVolt
			sub			#2048,Rtos
			mov.b		&LinkCal,R8		; Link offset calibration
			sxt			R8				; Sign extend
			sub			R8,Rtos
			_IF			_NN
				mov			Rtos,R8
				mov			#48001,R9
				call		#UMStar
				; Most significant half is in R10
			_ELSE
				inv			Rtos
				inc			Rtos			; Negate
				mov			Rtos,R8
				mov			#48001,R9
				call		#UMStar
				inv			R10				; Only interested in top half
				inc			R10				; Negate back
			_ENDIF
		_ENDIF
#if 0
		push		R10
#else
		mov			#'m',Rthd			; Units are millivolts
		mov			R10,Rsec			; Result
#endif
		mov			#4,Rtos				; Print 4 digits... would 3 be enough?
		jmp			_prettyPrint




; SetID ( -- ) 	; Set our ID according to where we are in the serial comms chain
;
; We wait up to 1.5 byte times for the start of a byte from our upstream neighbour.
; If no byte is received, we adopt an ID of zero and immediately send it downstream
; so others know not to use it, and we write it to info-flash.
;
; If a byte _is_ received, it is taken to be an ID that is already in use and
; we tentatively set our ID to one more than it.
;
; The structure of the serial code in info-flash is such that any byte read is also
; immediately sent downstream. This ensures that the others downstream keep reading and waiting.
;
; We continue waiting for bytes and echoing them downstream and incrementing our tentative ID
; until no byte is received within 1.5 byte times.
; We then adopt the tentative ID as our own, immediately send it downstream
; so others know not to use it, and we write it to info-flash.
;
; To change existing IDs, you need to bootstrap-load the BSL-writer to erase the IDs,
; then bootstrap-load this interpreter again before issuing this SetID command.
;
; The total time for N cells to set up IDs is about 1.5 * N byte times, or around 175 ms
; for 114 cells at 9600 baud.

		xCODE		'i',SetID,_SetID
		bis.b		#LED,&P1OUT			; Set the error LED
		mov			#OnRxID,&RxByteDest	; Point received bytes to OnRxID instead of OnRxByte
		clr.b		R8					; Tentative ID starts at 0
		mov			#Bitime*8*3/2,R9	; 1.5 byte times in timer ticks
		add			&TAR,R9				; Target timer expiry time

nextID
; Here we need to check whether the timer register TAR has exceeded the time in TAR.
; We need to be careful, and use either signed or unsigned arithmetic depending on the target time value
		cmp			#$4000,R9			; Is the target time <u $4000?
		jnc			timeCmpSigned		; If so use a signed comparison
		cmp			#$C000,R9			; Is the target time >u $C000?
		jc			timeCmpSigned		; If so, use signed compare
		cmp			R9,&TAR				; Compare target time with current time
		jnc			nextID				; Branch if unsigned less to the start of this loop
timeCmpSigned
		cmp			R9,&TAR				; Compare again
		jl			nextID				; Branch if signed less to the start of this loop
		
		;
		; Timeout with no received ID byte. ID is now definite. Send immediately so others dont use it
		;
		call		#TX_Byte			; Transmit this ID upstream

		;
		; Now flash-program this ID
		mov			#ID,R9
		call		#flashCStore
		mov			#OnRxByte,&RxByteDest	; Restore RX callback code pointer
		ret

;
; This callback gets called when we receive a byte during the SetID command
;
OnRxID:
		tst.b		&RXData				; Test for badness
		jl			jOnRxByte			; Some badness snuck in. Process it as badness, not an ID
		mov			#Bitime*8*3/2,R9	; 1.5 byte times in timer ticks
		add			&TAR,R9				; New target timer expiry time
		call		#TX_Byte			; Echo downstream so they don't use this ID either
		mov.b		&RXData,R8			; This is the ID that an upstream BMU has 
		inc.b		R8					; Add one to the byte, to obtain a new tentative ID
		reti							; Return to the loop checking for timeout
jOnRxByte br		#OnRxByte

;-------------------------------------------------------------------------------
; Flash programming macros

; The LOCKA bit in FCTL3 was made a *toggle*, for backward compatibility.
; Use these macros to clear and set safely.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm


flashCStore:
			; Assembly language flash writer
			; Byte  in R8, address in R9. Trashes Rtrash
			;
			; Check if it is possible to flash-program this ID
			;
			mov.b		R8,Rtrash			; Need to check for 1 bits in new ID
			bic.b		@R9,Rtrash		    ;	that are already 0s in the existing byte
			tst.b		Rtrash				; Set Z flag if result is 0; bic doesn't
			jnz			cantFlsh			; Impossible flash-write; can't do it
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3
			MOV 	#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV 	#FWKEY,&FCTL3       	; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write block that can't be)
			CLRLOCKA
			mov.b	R8,0(R9)				; Flash-write it
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming
			SETLOCKA
			MOV		#FWKEY,&FCTL1			; Disable flash write
			bic.b	#LED,&P1OUT				; Clear the error LED: done!
			ret
cantFlsh	bis.b	#LED,&P1OUT				; Set the error LED to indicate failure
			ret


