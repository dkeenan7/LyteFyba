;
; Bytecode definitions
;

; EXIT ( -- ); Return from a bytecode sequence

		xCODE	'|',EXIT,_EXIT ; Vertical bar
		incd	SP			; Drop the return address within the interpreter
		ret					; Return to whoever called the interpreter (_ENTER)
		
; HEX ( flag -- ) ; Set the number base to hexadecimal

		xCODE	'h',HEX,_HEX
		mov.b	#16,&base
_Space	ret					; When _Space is called, be a no-op (for separating literals)

; DECIMAL ( flag -- ) ; Set the number base to decimal

		xCODE	'd',DECIMAL,_DECIMAL
		mov.b	#10,&base
		ret					; When _Space is called, be a no-op (for separating literals)

; CLIT ( -- c ) ; Character literal. Pronounced "see lit".
; Treat the next bytecode as a literal character.

		xCODE	'`',CLIT,_CLIT ; back-quote or tock
;		PUSH	Rtos
;		MOV.B	@Rip+,Rtos
		DPUSH	@Rip+
		ret
		
; EMIT ( c --)	; Emit the character on top of stack

		xCODE	'm',EMIT,_EMIT
		mov.b	Rtos,R8
		call	#TX_Byte
;		pop		Rtos
;		DROP
		ret
		
; autonomous mode Badness sending (n --)
		xCODE	'b',autoBad,_autoBad
		allBitsIfNZ	Rtos,Rtos			; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		mov.b	Rtos,&bSendBad
;		pop		Rtos
;		DROP
		ret
		
;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		; This is actually longer in bytecode
		xCODE		's',Select,_Select
		cmp.b		&ID,Rtos			; Correct ID?
;		pop			Rtos				; Pop the argument
;		DROP							; Pop the argument
		jz			justRet				; If so, just continue interpreting rest of packet
		incd		SP					; Return to the outer interpreter (i.e. ignore rest of packet)
justRet	ret								

;
; Turn on or off the error LED (bool -- )
;
		xCODE	'e',errorLed,_errorLed
		call	#waitTxCmpl			; If this is called interactively, wait for CR to completely echo
		allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#LED,&P1OUT ; Move only the #LED bit from Rtos to &P1OUT. Trashes Rtos.

;		pop		Rtos				; Remove operand
		ret

;
; Turn on or off bypass resistors (bool -- )
;
		xCODE	'y',bypass,_bypass
		allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#BYPASS,&P1OUT ; Move only the #BYPASS bit from Rtos to &P1OUT. Trashes Rtos.
;		pop		Rtos				; Remove operand
		ret

;
; emitNum  ( n count -- ) ; Emit an integer n as count digits in the current number base
; Trashes R8-R12
		
		xCODE	'n',emitNum,_emitNum
		mov		Rtos,R12			; Count to R12
		bit.b	#2,&base			; Distinguish decimal from hex (the only bases allowed)
		_IF		_NZ					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov		#'-',R8				; Emit minus sign
				call	#TX_Byte
				inv		Rsec				; Negate
				inc		Rsec
			_ENDIF
		_ENDIF
		mov		Rsec,R9				; Dividend in R10:R9 will have n initially
		mov.b	&base,R8			; Divisor in R8 is number base
		dec		R12					; Count := Count-1
		_BEGIN
			clr		R10
			call	#UMSlashMod			; dividend/base -> R9, remainder to R10
			push	R10					; Push remainder
			dec		R12
		_UNTIL	_Z					; R9 keeps quotient as next dividend
		push	R9
		; Now we have n results on the stack; print these as hex/decimal
		_BEGIN
			pop		R8
			clrc						; Because dadd is always done with carry on MSP430
			dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
			dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			call	#TX_Byte
			dec		Rtos
		_UNTIL	_Z
		ret

;
; Pretty print n as a comment packet with m digits and follow with ch (ch n m--)
;
		xCODE	'p',prettyPrint,_prettyPrint
		push.b	&base				; Save current base
		mov.b	#10,&base			; Set to decimal
		
		mov		#'|',R8				; Initial vertical bar
		call	#TX_Byte			; (interpreted as comment character)
		
		push	Rthd				; Save ch
		push	Rsec				; Save n
		push	Rtos				; Save m
		
		mov.b	&ID,Rsec
		mov		#3,Rtos
		call	#_emitNum
		
		mov		#':',R8				; Colon separator
		call	#TX_Byte
		
		pop		Rtos				; Restore m
		pop		Rsec				; Restore n
		call	#_emitNum
		
		pop		R8					; Restore ch
		call	#TX_Byte
		
		mov		#'\r',R8			; Carriage return to R8
		call	#TX_Byte			; Emit
		
		call	#waitTxCmpl			; Wait for transmit complete
		bis.b	#LED,&P1OUT			; Set the LED here to mimic old behaviour
									; Identifies the BMU that sent a response
		pop.b	&base				; Restore previous base
		ret
		
;
; Low level voltage measurement (channel -- measurement)
; Channel has channel number shifted left 12 bits (e.g. $7000 for cell voltage)
; Channel 7 is currently cell voltage; 10 is temperature sensor
; Measurement is in millivolts (0 to 4095 mV)
;
		xCODE		'a',llVolt,_llVolt
		mov			Rtos,R8
		call		#measAndCal			; Measure and use calibration
		mov			R10,Rtos
		ret
		
;
; cellVolt ( -- )
; Transmit the cell voltage measurement in millivolts (0 to 4095 mV)
;
		xCODE		'v',cellVolt,_cellVolt
		mov			#CellVChan<<12,Rtos	; ADC channel for cell voltage divider
		call		#_llVolt

		mov			#'V',Rthd			; Units are volts
		mov			Rtos,Rsec			; Result
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Cell temperature measurement ( -- )
; Measurement is in degrees C
;
		xCODE		't',cellTemp,_cellTemp
		mov			#TempChan<<12,Rtos	; ADC channel for temperature sensor
		call		#_llVolt
;
; Scale it back to degrees Celsius. Typically, T = (V-Voff)/.00355 where Voff = 0.986
; But the measurement M is 4096* V/1.5 = 2731*V.
; So T = (M/2731 - Koff1)*281.7 = M/9.694 - Koff2
; To divide by 9.694, multiply by 65536/9.694 = 6760, and keep the top half

		mov			Rtos,R9			; Don't pop; replace with number of digits to print
		mov			#6760,R8
		call		#UMStar
		; Most significant half is in R10
		; Temperature offset is now offset by 273
		sub			#273,R10
		mov.b		&TempCal,R8		; Temp offset calibration
		sxt			R8				; Sign extend
		sub			R8,R10
		mov			#'C',Rthd			; Don't use degree symbol (0xF8, Terminal font only);
										;	it's treated as a badness
		mov			R10,Rsec
		mov			#3,Rtos			; 3 digits
		jmp			_prettyPrint	; Tail-call pretty-print and return


;
; Link voltage measurement ( -- )
; Measurement is in mV
; Circuit has 2:1 voltage divider with Vref at the bottom.
; So meaure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
; Reading = 2048 + (Vin/2)(4096/1.5)
; R = 2048 + Vin * 1365.3 (Vin in volts)
; R = 2048 + Vin * 1.3653 (Vin in mV)
; Vin = (R - 2048)/1.3653 mV
; To divide by 1.3653, multiply by 65536/1.3653 = 48001 and keep the top half

		xCODE		'l',linkVolt,_linkVolt
		mov.b		&LinkCal,R8		; Link offset calibration
		cmp.b		#$80,R8			; $80 is a special value representing "calibration failure"
		_IF			_EQ				; If link calibration value is $80
			mov		#15000,R10			; then use special value that will print as ?000
		_ELSE
			mov			#LinkVChan<<12,Rtos	; Shifted ADC channel for link voltage divider
			call		#_llVolt
			sub			#2048,Rtos
			mov.b		&LinkCal,R8		; Link offset calibration
			sxt			R8				; Sign extend
			sub			R8,Rtos
			_IF			_NN
				mov			Rtos,R8
				mov			#48001,R9
				call		#UMStar
				; Most significant half is in R10
			_ELSE
				inv			Rtos
				inc			Rtos			; Negate
				mov			Rtos,R8
				mov			#48001,R9
				call		#UMStar
				inv			R10				; Only interested in top half
				inc			R10				; Negate back
			_ENDIF
		_ENDIF
		mov			#'m',Rthd			; Units are millivolts
		mov			R10,Rsec			; Result
		mov			#4,Rtos				; Print 4 digits... would 3 be enough?
		jmp			_prettyPrint		; Tail-call pretty-print and return

#if 1
; Link voltage offset Calibration (--)
; Assumes zero link voltage due to zero link current
;
		xCODE	'c',calLink,_calLink
		mov		#LinkVChan<<12,Rtos
		call	#_llVolt
		sub		#2048,Rtos				; Zero volts for link voltage is a 2048 reading
		cmp		#$FF81,Rtos				; -$7F
		jl		nonCal					; If <s -$7F, use the $80 non-calibrated value
		cmp		#$80,Rtos
		jl		realCal					; If >s -$7F and <s $80, use as real calibration value
nonCal	mov		#$80,Rtos
realCal
		mov		#LinkCal,R9				; Address of byte to flash
		mov		Rtos,R8					; Value to flash
		jmp		flashCStore				; Write the calibration value and exit


;-------------------------------------------------------------------------------
; Flash programming macros

; The LOCKA bit in FCTL3 was made a *toggle*, for backward compatibility.
; Use these macros to clear and set safely.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm


flashCStore:
			; Assembly language flash writer
			; Byte  in R8, address in R9. Trashes Rtrash
			;
			; Check if it is possible to flash-program this ID
			;
			call	#waitTxCmpl				; Wait for any byte to transmit (likely CR echo)
			mov.b	R8,Rtrash				; Need to check for 1 bits in new ID
			bic.b	@R9,Rtrash				;	that are already 0s in the existing byte
			tst.b	Rtrash					; Set Z flag if result is 0; bic doesn't
			jnz		cantFlsh				; Impossible flash-write; can't do it
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3
			MOV 	#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV 	#FWKEY,&FCTL3       	; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write block that can't be)
			CLRLOCKA
			mov.b	R8,0(R9)				; Flash-write it
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming
			SETLOCKA
			MOV		#FWKEY,&FCTL1			; Disable flash write
			bic.b	#LED,&P1OUT				; Clear the error LED: done!
			ret
cantFlsh	bis.b	#LED,&P1OUT				; Set the error LED to indicate failure
			ret
#endif

#if 0
			xCODE		'j',jumpFence,_jumpFence	; "Jump-fence" temporary debugging command
			mov			#5,R11				; 5 lines
fenceLp1	mov			#10,R10				; 10 sets of 3 chars
			mov			#'|',R8				; First byte must be comment char; "fence post"
fenceLp2	call		#TX_Byte
			tst			R10
			jz			fenceEol
			mov			#'=',R8				; "fence rail"
			call		#TX_Byte
			mov			#'-',R8				; different "fence rail"
			call		#TX_Byte
			dec			R10
			mov			R10,R8				; Get count
			add			#'0',R8				; Make it a digit
			jmp			fenceLp2			; Use as next "fencepost"
fenceEol	mov			#$0D,R8				; Carriage return to end the line
			call		#TX_Byte
			; Not sure if need delay here
			dec			R11
			jnz			fenceLp1			; Repeat for more lines
			ret
#endif