			COL		154				; Wide listings
; 29/Sep/2015: split off from monolith.s43

; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve calibration data.
;
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Output options to:
;  Allow C-SPY-specific extra output file
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	wmonolith.bin
;	Output format: raw-binary
;
; This software has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for solar power systems.
;
; "WMonolith" is special solar power system operating software for our Cell Management Unit (CMU)
; and Battery Management Unit (BMU) based on an MSP430 microcontroller.

#define MONOLITH				// For some conditional assembly in otherwise common code.
								// Changes StatusFreq from 16 Hz to 2 Hz.
								// Enables SoC meter PWM.
								// Causes ID 255 (instead of ID 0) to respond to fuel gauge commands
								// 'f' (SoC) and 'g' (DoD).

ShutdownTime	EQU		15*StatusFreq ; Shut down after approx 15 seconds of stress 15.

			LSTOUT-
#include "msp430.h"							// MSP430 Special Function Register definitions
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Assembler macros for obscure instruction sequences
#include "../common/common.h"				// Definitions common to monitor, TestICal and BSL

; Some definitions so the measure.s43 code will work
; TestICal defines these as their RAM counterparts instead of info-flash
VoltCal 	EQU	infoVoltCal
VoltOff		EQU infoVoltOff
BoltPlCal 	EQU	infoBoltPlCal
BoltPlOff	EQU infoBoltPlOff
TempCal		EQU	infoTempCal
LinkCal		EQU	infoLinkCal

			NAME	main		; Module name
			PUBLIC	main		; Make the "main" label visible for IAR debugger

ProductCode	EQU		'W'				; T for TestICal, R for monitoR, L for monoLith, W for Wmonolith

ID			EQU		infoID			; We use the info-flash copy of the ID for s, x, prettyPrint
									; commands. TestICal uses the ram copy

; Conditional assembly
#define		WATCHDOG	1			// True if watchdog timer is to be used (only turn off for debugging)
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer.
									// Buffered ADC is mainly useful for debugging.

; Constants

; Stress calculations
; The stress set-point for charger back-off is 7.
; This set-point of 7 should be implemented in the SCU's PI controller.
; So 8 is the lowest dis-stress. Alarm is given at stress 12. Battery contactor dropout at 15.
#define WHINGE 0
#if !WHINGE
// OV = Over Voltage: One stress unit for each 40 mV in excess of 3.128 V, to a max of 15 at >= 3.728 V
// OV setpoint is 3.408 to 3.448 V. Bypass at 3.368. Alarm at 3.608. Drop out battery cont at 3.728
OV_ZERO		EQU		3128		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		40			; mV difference between one OV stress level and the next
; These were an attempt to float at the 75% step
;// OV = Over Voltage: One stress unit for each 3 mV in excess of 3.332 V, to a max of 15 at >= 3.377 V
;// OV setpoint is 3.353 to 3.356 V. Alarm at 3.365 V. Drop out source contactors at 3.368 V.
;OV_ZERO		EQU		3332		; Threshold in mV between OV stress levels -1 and 0
;OV_STEP		EQU		3			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 20 mV below 3.380 V, to a maximum of 15 at <= 3.08 V
// UV setpoint is 3.24 to 3.22 V (around 20% SoC). Alarm at 3.14 V. Drop out bat contactor at 3.08.
UV_ZERO		EQU		3380		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-20			; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 32C, to a max of 15 at >= 62 degC
// OT setpoint is 46 to 48 degC. Alarm at 56 degC. Dropout bat contactors at 62 degC.
OT_ZERO		EQU		33			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		2			; Degrees C difference between one OT stress level and the next
// UT = Under Temperature: One stress unit for every 2 degree C below 24C, to a max of 15 at <= -6 degC
// UT setpoint is 10 to 8 degC. Alarm at 0 degC. Bat contactor dropout at -6 degC.
UT_ZERO		EQU		24			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-2			; Degrees C difference between one UT stress level and the next
// AL = Absolute Link voltage: Disabled because the hardware does not measure it reliably.
// Plan to implement positive and negative bolt voltages in future.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		3000		; mV difference between one AL stress level and the next

#else
// OV = Over Voltage: One stress unit for each 10 mV in excess of 3.500 V, to a max of 15 at >= 3.65 V
// OV setpoint is 3.57 to 3.58 V. Alarm at 3.61 V.
OV_ZERO		EQU		3400		; Threshold in mV between OV stress levels -1 and 0
OV_STEP		EQU		10			; mV difference between one OV stress level and the next
// UV = Under Voltage: One stress unit for each 40 mV below 2.500 V, to a maximum of 15 at <= 1.90 V
// UV setpoint is 2.18 to 2.22 V. Alarm at 2.06 V.
UV_ZERO		EQU		3200		; Threshold in mV between UV stress levels -1 and 0
UV_STEP		EQU		-50			; mV difference between one UV stress level and the next
// OT = Over Temperature: One stress unit for every 1 degree C above 40C, to a max of 15 at >= 55degC
// OT setpoint is 47 to 48 degC. Alarm at 51 degC.
OT_ZERO		EQU		40			; Threshold in degrees C between OT stress levels -1 and 0
OT_STEP		EQU		1			; Degrees C difference between one OT stress level and the next
// UT = Under Temperature: One stress unit for every 1 degree C below 11C, to a max of 15 at <= -4degC
// UT setpoint is 4 to 3 degC. Alarm at 0degC.
UT_ZERO		EQU		11			; Threshold in degrees C between UT stress levels -1 and 0
UT_STEP		EQU		-1			; Degrees C difference between one UT stress level and the next
// AL = Absolute Link voltage: One stress unit for every 20 mV above 0 mV, to a max of 15 at >= 300 mV
// AL setpoint is 140 to 160 mV. Alarm at 220 mV.
AL_ZERO		EQU		0			; Threshold in mV between AL stress levels -1 and 0
AL_STEP		EQU		3000		; mV difference between one AL stress level and the next
#endif

; FULLLEV	EQU	OV_ZERO+7*OV_STEP	; Considered Full (charge termination and coulomb counter reset)
									;	3408 mV. Stress 6/7 threshold
; BYPLEV	EQU	OV_ZERO+6*OV_STEP	; Bypass threshold 3368 mV. Corresp. to stress 5/6 threshold

MinAlarmStress EQU	12			; Minimum stress to light error LED and beep
MinContStress EQU	12			; Minimum stress to drop out source or load contactors (BMU only)
								; There are no separate source or load contactors in wmonolith --
								;  only battery contactors that drop out at stress 15.

ComErrTicks	EQU		9			; Minimum ticks without receiving valid status byte before
								;	taking on master duties and reporting comms error (if ID not 1)

; Status byte bit masks - Used for localStatus in RAM as well as RXed and TXed status bytes
COM_ERR		EQU		1<<6			; Communications error
UV_AF		EQU		1<<5			; Stress type is UnderVoltage (ignore on charge) when bit 4 is clear
									;	or cells are All considered Full when bit 4 is set
OV_UT		EQU		1<<4			; Stress type is OverVoltage or UnderTemp (ignore on discharge)
ALL_FULL	EQU		1<<4 | 1<<5		; When both type bits are set it means All considered Full
									;   (reset to 0% DoD) as well as OverVoltage (ignore on discharge)
									; When both type bits are clear it means OverTemp (never ignore)
S_TYPE		EQU		$30				; Stress type field mask. Bits 4-5
STRESS		EQU		$0F				; Stress level field mask. Bits 0-3

SourceCtor	EQU		BatNegCtor			; Source contactor MOSFET and orange LED
LoadCtor	EQU 	AcLfPvCtor			; Load contactor MOSFET and cyan/white LED

;
; RAM allocation
;
				ORG		$200		; Start of RAM. Ends at InitSP-1
; This area is common to all main programs and used by the BSL and is not block erased on a reset
bsl2state		DS		2			; Password recogniser state for BSL2
resetCounter	DS		2			; Number of resets since the last "^" command
resetBuffer		DS		16			; Circular buffer recording the reason for the last 16 resets
discharge		DS		4			; Accumulator for depth of discharge determination.
									; Shunt amplifier measures 1/5 A units, but there is a shift right
									;	before the current is stored in variable 'current' and used for
									;	DOD calculation
									; Unit is 1/10 A for 1/2 s = 1/20 coulomb = 1/72 milliamphour.
									; So 32 bits allows 60,000 Ah, but 24 bits would only allow 233 Ah.
oldFllTime		DS		2			; Used by Frequency Locked Loop. NOTE: do not put this after
									;	comNoEraseEnd, as it will affect the first FLL interrupt
measureCount	DS		2			; Incremented by FLL interrupt routine, on ACLK rising edge, 4096 Hz
oldMeasureCount DS		2			; Value of measureCount at the last measure
oldRtcMeasCnt	DS		2			; Hi 4 bits of measureCount at the last advance of RTC seconds count

; Command Character Interpreter flags
interpFlags		DS		1			; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1<<0		; Should numeric output be in hexadecimal, not decimal?
bChecksumming	EQU		1<<1		; Are we sending checksums and checking received checksums?
bDontInterpret	EQU		1<<2		; Are we interpreting?
bDontEcho		EQU		1<<3		; Are we echoing characters? (not yet implemented in TestICal)
bModbusOutput	EQU		1<<4		; Should PrettyPrint output be formatted as a Modbus/ASCII response?
bEchoResponses	EQU		1<<5		; True to echo complete Modbus responses
bQuiet			EQU		1<<6		; True to silence piezo

				ALIGNRAM 1
comNoEraseEnd	; End of unerased variables; start of erased variables

#if	ADCBUF
				ALIGNRAM 1
sampleBuf		DS		2*NumSamples ; ADC sample buffer; 4 or 16 samples
#endif

monFlags		DS		1			; Monitor flags, bitmask definitions follow
bNotSendStatus	EQU		1<<0		; Zero if sending status bytes at all
bNotMeasureTime EQU		1<<1		; Zero if time to measure
bCharging		EQU		1<<2		; 1 if charging or regen. See 'c' command.
bChargerControl	EQU		1<<3		; 1 in charger control mode (masterless operation). See 'o' command.
bBadInsulation	EQU		1<<4		; 1 if the last insulation test failed. (BMU only)

masterFlags		DS		1			; Master (command injector) flags; bitmask definitions follow
bBlocked		EQU		1<<0		; 1 if blocked.
bSendZ			EQU		1<<1		; 1 if Z command is due to be sent
bSendi			EQU		1<<2		; 1 if 'i' command is due
bSendInit		EQU		1<<3		; 1 if initialisation string should be sent
bTimeout		EQU		1<<4		; 1 if unblocked via timeout; may or may not have to send a CR to
									;	clear a stalled command if we have something to inject (may not
									;	be ready now, hence we need this separate bit)
masterUnblockTicks DS	1			; When the master is blocked, this field indicates what the tick
									; counter will read when the timeout expires

localStatus		DS		1			; Bits 0-3 stress, 4 ignore-on-dis, 5 ignore-on-chg, 6 comms error
globalStatus	DS		1			; BMU only. For SCUs that don't accept status bytes but use 'p' cmd
ticksSinceLastRx DS		1			; Timer overflow events since last valid status received
ticks			DS		1			; To time various medium frequency tasks. Allowed to wrap
passWordState	DS		1			; State machine for password recogniser

; Charger controller variables

shutdownTimer	DS		1			; To allow time for charging to start, when restarting
									;   after a low voltage shutdown.
				ALIGNRAM 1
chargerVoltMin	DS		2			; Charger voltage minimum (tenths of a volt). Set by 'o' command.
chargerVoltMax	DS		2			; Charger voltage maximum (tenths of a volt). Set by 'o' command.
piPrevOutput	DS		2			; State of PI controller
piPrevError		DS		2			; State of PI controller
ChargerVoltMin	EQU		530			; Lower limit of PI controller output. In tenths of a volt.
ChargerVoltMax	EQU		570			; Upper limit of PI controller output. In tenths of a volt.
;ChargerVoltMin	EQU		526			; Lower limit of PI controller output. In tenths of a volt.
;ChargerVoltMax	EQU		546			; Upper limit of PI controller output. In tenths of a volt.
current			DS		2			; Current most recently reported by BMU, in tenths of an amp (signed)
temperature		DS		2			; Temperature most recently measured, in degrees Celsius (signed)
smoothStressX4	DS		1			; Moving average of stress used by BMU to control contactors

; Serial-io variables
	; Cell monitoring units comms variables
	; Note that the CMU variables have no prefix while the others have "scu" and "chg".
				ALIGNRAM 1
txData			DS		2			; Byte to transmit in lower byte; always $FF in high byte
rxData			DS		1			; Received char
bitCntTx		DS		1			; Bit count 10 -> 1
bitCntRx		DS		1			; Bit count 8 -> 1
txCksum			DS		1			; Transmit checksum
txCrc			DS		2			; Transmit cyclic redundancy check

RxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
TxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
rxBuf			DS		RxSz		; Receive queue buffer
rxWr			DS		1			; Receive queue write index
rxRd			DS		1			; Receive queue read index
txBuf			DS		TxSz		; Transmit queue buffer
txWr			DS		1			; Transmit queue write index
txRd			DS		1			; Transmit queue read index

	; System control unit comms variables
				ALIGNRAM 1
scuBitTime		DS		2			; Determines bit rate.
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
scuTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
scuRxData		DS		1			; Received char
scuBitCntTx		DS		1			; Bit count 10 -> 1
scuBitCntRx		DS		1			; Bit count 8 -> 1
scuTxCksum		DS		1			; Transmit checksum

ScuRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
ScuTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
scuRxBuf		DS		ScuRxSz		; Receive queue buffer
scuRxWr			DS		1			; Receive queue write index
scuRxRd			DS		1			; Receive queue read index
scuTxBuf		DS		ScuTxSz		; Transmit queue buffer
scuTxWr			DS		1			; Transmit queue write index
scuTxRd			DS		1			; Transmit queue read index

	; Charger/inverter comms variables
				ALIGNRAM 1
chgBitTime		DS		2			; Determines bit rate.
									; Use BitTime96 or BitTime24 constant from InterruptComms.s43.
chgTxData		DS		2			; Byte to transmit in lower byte; always $FF in high byte
chgRxData		DS		1			; Received char
chgBitCntTx		DS		1			; Bit count 10 -> 1
chgBitCntRx		DS		1			; Bit count 8 -> 1
chgTxCksum		DS		1			; Transmit checksum

ChgRxSz			EQU		32			; Receive queue size. Must be a power of 2 no greater than 256
									; 8 is sufficient to prevent dropped cmd and response characters
ChgTxSz			EQU		32			; Transmit queue size. Must be a power of 2 no greater than 256
									; 4 is sufficient to reduce dropped status to less than one a minute
				ALIGNRAM 1
chgRxBuf		DS		ChgRxSz		; Receive queue buffer
chgRxWr			DS		1			; Receive queue write index
chgRxRd			DS		1			; Receive queue read index
chgTxBuf		DS		ChgTxSz		; Transmit queue buffer
chgTxWr			DS		1			; Transmit queue write index
chgTxRd			DS		1			; Transmit queue read index


rxCksum			DS		1			; Received packet xor checksum

				ALIGNRAM 1
ovZero			DS		2			; Overvoltage zero, set by 'VP command (param1 - 7 * param2)
ovStep			DS		2			; Overvoltage step, set by 'VP command (param2)

				ALIGNRAM 1
eraseEnd		EQU		$			; End of the erased variables

socPwmAdv		DS		2			; Amount to add to TACCTL2 for next compare value for SoC meter
									; A kind of trip-meter for this cell's stress
worstStress		DS		1			; Worst local stress since the last resetWorstStress command
worstStressType	DS		1			; Type of measurement that caused worst stress
worstOV			DS		2			; Worst over-voltage since the last resetWorstStress command
worstUV			DS		2			; Worst under-voltage since the last resetWorstStress command
worstOT			DS		2			; Worst over-temperature since the last resetWorstStress command
worstUT			DS		2			; Worst under-temperature since the last resetWorstStress command
worstAL			DS		2			; Worst absolute link voltage since the last resetWorstStress command
; The 5 variables above are also treated as an array indexed from worstStress, so order matters

; Command Character Interpreter variables
				ALIGNRAM 1
ToIN			DS		2			; Pointer to present character being stored in Text Input Buffer
TIB				DS		48			; Text Input Buffer (packet buffer)
TIBEnd

; "Real time clock"
rtcDay			DS		1			; Day of week 0 = Sunday, 6 = Saturday
rtcHour			DS		1			; Hour (0=midnight, 12 = noon, 23 = 11 pm)
rtcMin			DS		1			; Minute (0-59)
rtcSec			DS		1			; Second (0-59)

TxBytePtr		DS		2			; Pointer to TxByte handler. Initially CmuTxByte, except for BMUs
									;	which initialise it to ScuTxByte

; Must leave room for stack (about 36 bytes minimum)
STACKSPACE		EQU		InitSP-$	; Look at listing to see what this is

;-------------------------------------------------------------------------------
				ORG		PROG_START	; In main-flash
;-------------------------------------------------------------------------------

#include "../common/CmdCharInterpreter.s43" // RPN interpreter with one-or-two-character commands
#include "../common/InterruptComms.s43"	// Comms routines
#include "../common/ComComms.s43"	// Common comms functions
#include "../common/measure.s43"	// Voltage measurement functions
#include "../common/math.s43"		// Multiply and divide routines
#include "wmonoDefinitions.s43"		// Command character definitions
#include "wmaster.s43"				// AccMaster function for injecting commands

;-------------------------------------------------------------------------------
; InterpretInit
;-------------------------------------------------------------------------------

InterpretInit:                              ; This is called by the BSL, on reset.
InterpretByte:								; Should not be called -- but just in case
main:										; For IAR Embedded Workbench IDE debugger
			dint							; Disable interrupts while initialising various things that
											;	will use interrupts. Note that this will temporarily
											;	stop the FLL.
			ClearWatchdog					; Clear and enable Watchdog Timer 32k cyc. BSL sets 64 cyc.
			mov.w	#InitSP,SP				; Initialize stackpointer, likely not necessary

			; Clear all variables in RAM except resetBuffer and BMU's fuel gauge discharge accumulator
			; and worstStress (and ToIN/TIB)
			; In other words: erase from comNoEraseEnd up to but not including eraseEnd
			_DO		#eraseEnd-comNoEraseEnd,R8
				clr		comNoEraseEnd-2(R8)
			_mLOOP	#2,R8

			; Don't initialise system clock registers. BSL2 and the FFL have set them.

			cmp.b	#255,&ID					; Is this a BMU?
			_IF		_EQ
				mov		#ScuTxByte,&TxBytePtr		; By default, TxByte goes to the SCU port for a BMU
			_ELSE
				mov		#CmuTxByte,&TxBytePtr		; In other cases, particularly CMUs, TxByte goes to
													;	the CMU port
			_ENDIF

;
;	Initialise io ports
;
			; Port 1 already set up by BSL.

			; Initialise port 2
			mov.b	#0,&P2OUT					; Set all outputs low.
			bis.b	#ErrLed,&P2DIR 				; Set ErrLed as output
			bis.b	#TxMiChg_57k6B|TxMiChg2_RlyP_57k6A,&ChgPortDIR ; Set Txs as outputs
												; Do not disturb bits 6, 7 (XIN, XOUT)
			bis.b	#RxChg|TxMiChg_57k6B,&ChgPortSEL	; Select timer functions for Rx and Tx pins
												; Do not disturb bits 6, 7 (XIN, XOUT)
			cmp.b	#255,&ID
			_IF		_NE							; If we're not a BMU
				bis.b	#Bypass,&BypPortDIR 		; Set Bypass as output
			_ENDIF

			; Initialise port 3. CMUs don't use this port, but no harm in setting it up.
			; Don't change the state or direction of any BMU contactor outputs or you might cut off
			; power to the BMU.
			cmp.b	#255,&ID
			_IF		_NE						; If we're a CMU
				mov.b	#$FF,&P3REN				; Enable pullup/pulldown resistors to save power, for
												;   any pin which may remain a floating input in a CMU.
			_ENDIF
			; Don't change the state of contactor outputs unless this is a power-on reset
			; or you might cut off your own power.
			mov		&resetCounter,R8
			dec		R8
			and		#$0F,R8
			mov.b	resetBuffer(R8),R8
			bit.b	#PORIFG,R8				; Check for power-on reset
			_IF		_NZ						; If it was a power-on
				mov.b	#0,&P3OUT				; Turn off all contactors
			_ENDIF
			; Set contactor outputs as outputs in case they aren't already.
			mov.b	#PreCtor|BatPosCtor|BatNegCtor|AcLfPvCtor|RtPvCtor,&P3DIR
			bic.b	#TxMiScu,&ScuPortOUT		; Set Tx low
			bis.b	#TxMiScu,&ScuPortDIR		; Set Tx as output
			bis.b	#RxScu|TxMiScu,&ScuPortSEL	; Select timer functions for Rx and Tx pins

;
;	Initialise timer and interrupt comms
;
			; Don't initialise the UART. Everything is already set up from BSL, except for interrupts.
			; But we don't want to enable TX ints before anything is in the circular buffer.
			bis.b		#UCA0RXIE, &IE2

			; Initialise the Timers if we are a BMU
			cmp.b	#255,&ID					; If we're a BMU
			_IF		_EQ
				; TA0CTL are set up correctly by the BSL
				; Initialise timer TA1
				; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
				; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
				; MC: 2 = continuous mode 1 = up mode
				; TAIE = interrupt enable (for timer overflow)
				mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2, &TA1CTL

				mov.w	#OUTMOD_5, &ScuCCTLt		; Initialise transmit capture/compare register
				mov.w	#BitTime96,&scuBitTime		; Set the SCU bit time for 9600 baud
				mov.b	#$FF,&scuTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
				mov.b	#8,&scuBitCntRx				; Load Rx bit Counter, 8 data bits
	;			clr.b	scuTxCksum					; Clear transmit checksum. Already cleared by loop above
				mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ScuCCTLr	; Falling edge, Input A, Sync, Capture

				mov.w	#OUTMOD_5, &ChgCCTLt		; Initialise transmit capture/compare register
				mov.w	#BitTime96,&chgBitTime		; Set the charger bit time for 9600 baud
				mov.b	#$FF,&chgTxData+1			; Init top half of txData to all 1s (stop bit, idle bit)
				mov.b	#8,&chgBitCntRx				; Load Rx bit Counter, 8 data bits
	;			clr.b	chgTxCksum					; Clear transmit checksum. Already cleared by loop above
				mov.w	#CM_2+CCIS_0+SCS+CAP+CCIE,&ChgCCTLr	; Falling edge, Input A, Sync, Capture
			_ENDIF

			; Already cleared by loop above
;			clr.b	&rxWr						; Initialise the TX and RX queue indexes
;			clr.b	&rxRd
;			clr.b	&txWr
;			clr.b	&txRd

;
; Initialise the charger controller
;
			; Already cleared by loop above
;			clr.b	&shutdownTimer				; Initialise shutdown timer
			cmp.b	#255,&ID					; If we're a BMU
			_IF		_EQ
				mov.w	#ChargerVoltMin,&chargerVoltMin ; Initialise charger voltage min
				mov.w	#ChargerVoltMax,&chargerVoltMax ; Initialise charger voltage max
				bis.b	#bChargerControl,&monFlags	; Set by o command
				bis.b	#bCharging,&monFlags		; Set by c command
			_ENDIF
;			clr.w	&piPrevOutput				; Initialise PI controller state
;			clr.w	&piPrevError				;
;			clr.w	&chargerPrevCurr			; Initialise charger current

			mov.w	#OV_ZERO,&ovZero
			mov.w	#OV_STEP,&ovStep

;
; Initialise the ADC10
;
			cmp.b	#255,&ID					; If we're not a BMU
			_IF		_NE
				; Enable cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				mov.b		#(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ELSE
				; Enable cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				; No longer TouchVChan
				mov.b		#(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ENDIF
			; Initialise ADC10
			; SREF_1	= +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temp)
			; REFOUT	= connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			mov			#SREF_1+ADC10SHT_3+REFOUT+REFON,&ADC10CTL0
			; Other ADC10 initialisation is done every time "measure" is called, to save code space

;
; Initialise the command character interpreter
;
			;	Already cleared by loop above
;			clr.b	&RXCksum				; Clear received packet xor checksum
			cmp.b	#255,&ID					; If we're not a BMU
			_IF		_NE
				mov.b	#bChecksumming,&interpFlags ; Default checksumming on
			_ELSE
				mov.b	#bChecksumming | bDontEcho | bEchoResponses,&interpFlags ; Don't want to echo
													; command packets, do want to see responses
			_ENDIF
;			bic.b	#bHexOutput,&interpFlags	; Default numeric output to be in decimal, not hexadecimal
;			bic.b	#bDontInterpret,&interpFlags ; Do interpret
;			bic.b	#bDontEcho,&interpFlags	; Do echo
			mov		#TIB,&ToIN				; Initialise write pointer into text input buffer

; PWM initialisation
			call	#UpdateSoC					; Initialise the pre-computed counter advance value

;
; Miscellaneous initialisation
;
			mov.b	#4,&passWordState		; Waiting for first byte of ^E ^D ^C ^B sequence
			eint							; Enable interrupts now that all initialisation is complete


; Do precharge and get the main contactor on, so we stay powered up
; even when the human lets go of the green button.
			cmp.b	#255,&ID
			_IF		_EQ							; If we're a BMU
				call	#DoPrecharge
			_ENDIF

; If we're a BMU, ensure CMUs are using and expecting checksums, and sending status bytes,
; then retrieve the high word of the discharge accumulator from CMU 1
; This is now done in AccMaster, using the bSendInit masterFlag.
			cmp.b	#255,&ID
			_IF		_EQ
				bis.b	#bSendInit,&masterFlags
			_ENDIF

; Main loop
			_BEGIN
				; For BMUs only (ID=255), check for input from the SCU Rx port, and send these to the
				; "master" accept function, to echo to CMU Tx and inject Z/i commands as required
				cmp.b	#255,&ID
				_IF		_EQ
					call	#ScuRxByteNW			; Check if received SCU data
					_IF		_NZ
						call	#CmuTxByte				; Echo to CMU Tx port; preserves R8
						call	#DoPassword				; Check for BSL password bytes from SCU port
					_ELSE
						clr		R8						; Indicate to AccMaster that no char is avail
					_ENDIF
					call	#AccMaster				; Call the "master" accept function, char or not
				_ENDIF

				; Check for a command or status character from the CMU port
				; For both CMUs and the BMU, read from CMU Rx
				call	#RxByteNoWait			; Check if received CMU data
				_IF		_NZ
					tst.b	R8
					_IF		_NN
						call	#DoEcho					; Echo the command or password byte if required
						cmp.b	#255,&ID				; Check ID
						_IF		_NE						; If I'm not a BMU
							call	#DoPassword				; Check for BSL password bytes from CMU port
						_ENDIF
						call	#ACCEPT					; Process command bytes (could be slow)
					_ELSE								; Else was status byte
						call	#DoStatus					; Forward possibly-updated status bytes
					_ENDIF
				_ELSE
					call	#UpdateRtc					; Update "real time clock" if needed

					; Check if time to measure. The FLL interrupt (happens 4096 times per second) is
					;	incrementing &measureCount. We want to know if this count has advanced more than
					;	4096/StatusFreq since the last measure (when &measureCount was saved as
					;	&oldMeasureCount)
					mov		&oldMeasureCount,R8
					add		#(4096/StatusFreq),R8		; Where it will be at measure time (minimum)
					sub		&measureCount,R8			; Subtract where it is now
					_IF		_NN							; If this is nonnegative, it is not time to measure
				;		mov.w	#WDTPW+WDTHOLD,&WDTCTL		; Stop Watchdog Timer before sleeping CPU
				;		bis		#CPUOFF+GIE,SR				; Turn off CPU and ensure interrupts still enabled
					_ELSE								; Else time to measure
						mov		&measureCount,&oldMeasureCount ; Remember this count for next measure
						call	#DoMeasurement			; May transmit status
					_ENDIF
				_ENDIF

			ClearWatchdog				; Clear and restart Watchdog Timer each time around main loop

			_AGAIN
; End of main loop


DoMeasurement:
;
; Regular measurement. Called StatusFreq times per second (2-16 times per second, see InterruptComms.s43)
;
#define Rstrs R12				// Worst stress (present, not trip)
#define Rmeas R14				// Measurement causing worst stress
#define Rtype R15				// Type of measurement causing worst stress

			inc.b	&ticks					; Used to time various infrequent tasks. Allowed to wrap.

			clr		Rstrs					; Init present stress to zero
			clr		Rmeas					; Init measurement causing zero stress to zero
			clr		Rtype					; Init type of measurement causing zero stress to zero

			inc.b	&ticksSinceLastRx		; Cleared whenever valid stress byte received
			_IF		_C						; If unsigned overflow
				mov.b	#$FF,&ticksSinceLastRx	; Saturate at $FF
			_ENDIF

			; Do cell voltage measurement
			call	#cellV					; Get cell voltage in mV in R10
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		_NE
				; Estimate OCV by subtracting current times internal resistance from measured voltage.
				; Shunt must be wired so charge current is positive and discharge current is negative.
				push	R10						; Save the cell voltage measurement

				; We have a 16x16=32-bit multiply, and we want to scale the current and resistance
				; so the high 16 bits of the result is the voltage in millivolts, while ensuring
				; that the scaled current and resistance do not overflow unsigned 16 bits.
				; Also, we want to limit the scaling of the current to binary-shifts since it
				; must be done at runtime, while the scaling of resistance can be more complicated
				; since it can be done at assembly time.
				; We will scale current by >>3 to 1/80ths of an amp, so overflow is at 819.2 A.

				; Get the scaled cell internal resistance into R8.
				; Given that we want the result to be in 1/65536ths of a millivolt, we need to scale
				; resistance to 1/(65536/80) = 1/819.2ths of a milliohm
				; We rely on the fact that the assembler performs 32 bit calculations.
				; HiTempCellRes is in micro-ohms.
				; The +5000 is for correct rounding of the truncating division by 10000.
				mov		&infoCellRes,R10
				clr		R9
				REPT	3
					rra		R10
					rrc		R9
				ENDR
				add		#5000,R9
				adc		R10
				mov		#10000,R8
				call	#UMSlashMod
				mov 	R9,R8
				; Now in 1/819.2ths of a milliohm, so overflow at 80 mR

				; Adjust the internal resistance for temperature using an approx Arrhenius' equation.
				; So the temperature-dependent component doubles for every 10 degC drop in temperature.
				; Assume that the "HiTempCellRes" constant is the fixed or high-temperature component,
				; and that, at 10 degC, the temp-dependent component is equal to the fixed component.
				; So the cell resistance at a given temperature is estimated as
				; CellResistance = HiTempCellRes * [1 + 2^(1-T/10)] where T is the cell temperature.

				; Shift right 3 bits to get the temperature dependent component at 40 degC, in R9.
				add		#4,R9
				rra3	R9

				; For every 6 degrees we are below 40 degC, multiply resistance by 1.5 (approx 2^(6/10))
				; Could mult by 1.25 for every 3 deg, but it would take longer. Accuracy not needed.
				mov		#40-3,R11				; R11 is loop counter, init 40 degC, -3 for rounding
				_BEGIN
					cmp		&temperature,R11
				_WHILE	_GE						; While loop counter >= temperature
					mov		R9,R10					; Multiply resistance by 1.5
					rra		R10
					add		R10,R9
					sub		#6,R11					; Decrement loop counter by 6 degC
				_REPEAT
				add		R9,R8					; Add the temperature-dependent part to the fixed part

				; Get the scaled absolute value of the current into R9
				mov		&current,R9				; Current is in tenths of an amp
				abs		R9
				rla3	R9						; Now in 1/80ths of an amp, so overflow is at 819.2 A

				; Multiply cell resistance and current, and subtract from measured cell voltage
				ClearWatchdog
				call	#UMStar					; R10:R9 = R8 * R9, resistance * current, clears R11
				mov		R10,R9					; Use only the high word of the result, put into R9
				pop		R10						; Restore the cell voltage measurement to R10
				tst		&current
				_IF		_NN						; If current is not negative (i.e. if charging)
					sub		R9,R10					; OCV is lower than measured, when charging
				_ELSE							; Else discharging
					add		R9,R10					; OCV is higher than measured, when discharging
				_ENDIF							; Endif
			_ENDIF	; not BMU

			; Set bypass as required
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		_NE
				mov			&ovStep,R9			; Calculate the bypass threshold in R9
				rla3		R9					; = ovZero + 6*ovStep
				add			&ovZero,R9			; = 8*ovStep + ovZero - ovStep - ovStep
				sub			&ovStep,R9
				sub			&ovStep,R9
				cmp			R9,R10				; Compare present cell voltage (R10) to bypass threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#Bypass,&P2OUT	; Move only the #Bypass bit from R8 to &P2OUT. Trashs R8
				add			&ovStep,R9			; Calculate the full (coulomb-counter reset) threshold
												;	One level above bypass (cf. one below for monitor)
				cmp			R9,R10				; Compare cell voltage (R10) to the full threshold
				CtoAllBits	R8					; If voltage >= threshold then $FF else $00
				movBits_B	R8,#ALL_FULL,&localStatus ; Move only All-Full bits from R8 to localStatus
			_ELSE
				bis.b		#ALL_FULL,&localStatus	; BMU must pretend it's in bypass so charge terminates
			_ENDIF

			cmp.b	#255,&ID
			_IF		_NE						; If we're not a BMU
				push	R10						; For undervoltage stress calc below
				; Calculate stress due to overvoltage
				push	R10						; OCV for overvoltage stress calc
				push	&ovStep					; For every ovStep (millivolts)
				push	&ovZero					;	over ovZero, we add one level of stress
				push	#1						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if non-zero stress due to OV

				; Calculate stress due to undervoltage
												; OCV for undervoltage stress calc already pushed
				push	#UV_STEP				; For every UV_STEP (millivolts)
				push	#UV_ZERO				;	below UV_ZERO, we add one level of stress
				push	#2						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if non-zero stress due to UV
			_ENDIF	; not a BMU

			; Do temperature measurement using internal sensor
			call	#temp					; Get temperature in degrees Celsius in R10
			mov		R10,&temperature		; Used by next calculation of cell internal resistance

			cmp.b	#255,&ID
			_IF		_NE						; If we're not a BMU
				push	R10						; Save measurement for undertemperature stress calc
				; Calculate stress due to overtemperature
				push	R10						; Measurement for overtemperature stress calc
				push	#OT_STEP				; For every OT_STEP (degrees Celsius)
				push	#OT_ZERO				;	over OT_ZERO, we add one level of stress
				push	#3						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to OT

				; Calculate stress due to undertemperature
												; Measurement saved on stack earlier
				push	#UT_STEP				; For every UT_STEP (degrees Celsius)
				push	#UT_ZERO				;	below UT_ZERO, we add one level of stress
				push	#4						; Type of measurement
				call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to UT
			_ENDIF

			; Calculate stress due to link voltage (current shunt measurement for a BMU)
			call	#linkV					; Get link voltage in mV in R10
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		_NE
#if 0			// Don't treat link voltage as stress for now, as the circuitry is too noise prone.
				cmp		#9999,R10				; Special "invalid" value?
				_IF		_NE						; Only calculate link stress if not this value
					; Calculate stress due to excessive absolute link voltage
					tst		R10						; Get absolute value of link voltage
					_IF		_L
						inv		R10
						inc		R10
					_ENDIF
					push	R10						; Measurement for absolute link stress calc
					push	#AL_STEP				; For every AL_STEP (millivolts)
					push	#AL_ZERO				;	over AL_ZERO, we add one level of stress
					push	#5						; Type of measurement
					call	#DoStress				; Update Rstrs Rmeas Rtype if worse stress due to AL
				_ENDIF
#endif
			_ELSE	; BMU
				; We have a 500 A 50 mV shunt for the Genevo DCM at Kingscliff,
				; and the diffamp has a gain of 10, so the linkV result should be
				; in units of 0.5 A. So -1500 to 1500 corresp to -750 A to 750 A.
				mov		R10,R9					; Multiply by 5 to
				rla2	R10						;  convert to tenths of an amp
				add		R9,R10
				mov		R10,&current			; Save in RAM variable
				bis.b	#bSendi,&masterFlags	; Indicate that an 'i' command using &current is due
				ClearWatchdog					; When testing, seem to need this

				tst		&current
				_IF		_NN						; If current is not negative
					bis.b	#bCharging,&monFlags	; We're charging
				_ELSE							; Else
					bic.b	#bCharging,&monFlags	; We're not charging
				_ENDIF							; Endif

				; Sign extend current to 32 bits in R10:R9.
				mov		&current,R9					; Get current in R9
				mov		R9,R10						; Make a copy in R10
				rla		R10							; Shift sign bit to carry
				subc	R10,R10						; 0 if R9 is negative, -1 otherwise
				inv		R10							; -1 if R9 is negative, 0 otherwise

				; Do coulomb counting
				sub		R9,&discharge				; Integrate current in 32-bit discharge accumulator
				subc	R10,&discharge+2			; for fuel gauge
				_IF		_NN							; Clamp negative values to zero
				_ELSE								; There is no true _IF _N with the MSP430
					clr		&discharge
					clr		&discharge+2
				_ENDIF
				call	#UpdateSoC					; Update the pre-computed SoC timer advance value

				; Send the high word of the discharge counter to safe storage
				tst.b	&ticks						; Every 128 seconds
				_IF	_Z
					bis.b	#bSendZ,&masterFlags		; Indicate to the master that a Z command is due
				_ENDIF ; Every 136 seconds
			_ENDIF ; BMU current measurement

			cmp.b	#255,&ID
			_IF		_NE						; If we're not a BMU
				; Clamp local present stress to a maximum value
				mov		#15,R9					; Default clamp value is 15
				cmp		#4,Rtype
				_IF		_EQ						; If type is undertemperature
					mov		#MinContStress,R9		; Clamp to a max of 12 to avoid masking UV >= 12
				_ENDIF
				mov		Rstrs,R8				; Copy stress. movBits_B macro below trashes its source.
				cmp		R9,R8					; If the stress is not less than the maximum allowed
				_IF		_HS
					mov		R9,R8					; Use the maximum allowed
				_ENDIF

				; Update local present stress
				movBits_B R8,#STRESS,&localStatus ; Record for later use, preserving other status bits.

				; Update local present stress type if not already set to "all considered full" above.
				mov.b	&localStatus,R10
				and		#S_TYPE,R10
				cmp		#ALL_FULL,R10
				_IF		_NE						; If stress type is not already All considered Full
					cmp		#2,Rtype
					_IF		_EQ						; If stress type is UnderVoltage
						mov		#UV_AF,R8				; Set the UV_AF bit, clear the OV_UT bit
					_ELSE							; Else
						_COND							; Begin short circuit conditional
							cmp		#1,Rtype
						_OR_ELSE _EQ					; If type is OverVoltage, else
							cmp		#4,Rtype
						_OR_IFS	_EQ						; or if type is UnderTemperature
							mov		#OV_UT,R8				; Set the OV_UT bit, clear the UV_AF bit
						_ELSE							; Else
							clr		R8						; Clear both type bits
						_ENDIF
					_ENDIF
					movBits_B R8,#S_TYPE,&localStatus ; Record type for later, presrve other status bits
				_ENDIF

				; Update worst stress for trip so far
				cmp.b	&worstStress,Rstrs		; If stress equal or higher than worstStress for trip so far
				_IF		_HS
					tst.b	Rstrs					; and it's an actual, nonzero stress
					_IF	_NZ
						mov.b	Rstrs,&worstStress		; Update worstStress
						mov.b	Rtype,&worstStressType	; Update type of measurement causing worst stress
					_ENDIF
				_ENDIF

				; Update Alarm -- local red LED and piezo
				cmp.b		#MinAlarmStress,Rstrs	; Turn on the error LED if stress is MinAlarmStress or more
				CtoAllBits	Rtos
				bit.b		#bBadInsulation,&monFlags
				CtoAllBits	R8
				bis			R8,Rtos				; or if the last insulation test failed (BMU only)
				call		#_errorLed			; Use this function so it optionally turns on piezo as well
			_ENDIF	; Not a BMU

			; Check for comms error and send local status if required
			bic.b	#COM_ERR,&localStatus	; Clear comms error flag by default. May be set below.
			bit.b	#bNotSendStatus,&monFlags ; If sending status, and so expecting to receive it
			_IF		_Z
				cmp.b	#ComErrTicks,&ticksSinceLastRx ; and too many ticks since last valid status Rx
				_IF		_HS
					; If our ID is not 1 (first CMU), set the comms error bit in local status
					; and send a comment with our ID followed by 'c' for comms error
					; every 256 status bytes (approx every 136 seconds).
					cmp.b	#1,&ID
					_IF		_NE
						bis.b	#COM_ERR,&localStatus
#if 0
// This is meaningless to a Modbus SCU. If not running in the BMU, it could be made to send a command
// to the BMU, which would set a register that the SCU could interrogate to find out
// where the comms break is. Otherwise we'll just eyeball the CMUs for out-of-sync blue LEDs.
// The SCU will learn there is a comms break, from the status byte, via the 'p' command.
						tst.b	&ticks
						_IF	_Z
							call	#_commsError			; Call pretty-printing command
						_ENDIF
#endif
					_ENDIF

					; Act as a master -- send our status
					mov.b	&localStatus,R8
					bis.b	#$80,R8					; Set the high bit to say it's a status byte

					; Send status or control a charger
					cmp.b	#255,&ID				; If we're a CMU
					_IF		_NE
						call	#TxByte					; Send the status byte. Wait buffer not full
					_ELSE							; Else we're in charger control mode
						mov.b	R8,&globalStatus		; '255sp' (or modbus equiv) reads global status
						call	#ControlContactors		; Control contactors
					_ENDIF
				_ENDIF							; End if too many ticks since last Rx
			_ENDIF							; End if sending status
			ret
; End of DoMeasurement


DoStress:
;
; Called 5 times by DoMeasurement to calculate the various kinds of stress
; and keep track of which is worse.
; It takes 4 parameters on the stack and updates 3 registers as required (Rstrs, Rmeas, Rtype).
; Trashes R8 thru R11.
;
; Stack offsets for parameters (return address is at offset zero)
type	EQU		2				; A number representing the type of measurement OV=1 UV=2 OT=3 UT=4 AL=5
zero	EQU		4				; The measurement corresponding to zero stress
step	EQU		6				; The change in measurement corresp to a change of one stress level
meas	EQU		8				; The measurement

			ClearWatchdog
			mov		meas(SP),R9				; Get meas in R9
			mov		type(SP),R10			; Get type * 2 in R10 for use as word index
			rla		R10
			mov		step(SP),R8				; Get step in R8
			tst		R8
			_IF		_GE
				cmp		worstStress(R10),R9
				_IF		_GE						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				sub		zero(SP),R9				; Get meas - zero in R9
			_ELSE
				cmp		worstStress(R10),R9
				_IF		_L						; If this is a worse measurement of this type
					mov		R9,worstStress(R10)		; Update the worst
				_ENDIF
				inv		R8						; Get absolute value of step in R8
				inc		R8
				mov		zero(SP),R9				; Get zero - meas + step -1 in R9
				sub		meas(SP),R9
				add		step(SP),R9
				sub		#1,R9
			_ENDIF
			_IF		_L
				clr		R9						; Min of 0
			_ENDIF
			clr		R10						; Clear high word of dividend
			call	#UMSlashMod				; R9 = R10:R9 / R8 = (meas - zero) / step, clears R11
			cmp		R9,Rstrs
			_IF		_LO						; If this stress worse than present stress calculated so far
				mov		R9,Rstrs				; Make it the new present stress
				mov		meas(SP),Rmeas			; Measurement causing present stress
				mov		type(SP),Rtype			; Type of measurement causing present stress
			_ENDIF
			pop		R8						; Pop the return address
			add		#8,SP					; Drop the parameters off the stack
			br		R8						; Return
; End of DoStress


DoStatus:
;
;	Process received status byte in R8. Trashes R9, R10
;	Status byte:
;	Bit 7: Always 1 for status byte
;	Bit 6: Comms error: Means that status information does not represent the whole pack
;	Bit 5: Ignore on charge (if bit 4 is clear), All considered full (if bit 4 is set)
;	Bit 4: Ignore on discharge
;	Bits 3-0: Stress level 0-15
;
		; Extract the stress bits from the incoming status byte
		mov.b	R8,R9					; Copy incoming status to R9
		and.b	#STRESS,R9				; Only stress bits in R9

		clr.b	&ticksSinceLastRx		; Now zero time since last received valid status
		; This will eliminate any comms error next time through DoMeasurement

		; Check if DoMeasurement may have just sent a status byte, due to a comms error
		bit.b	#COM_ERR,&localStatus
		_IF		_Z						; If no comms error

			; Do MAX of local and incoming stress, and handle stress type and all considered full
			mov.b	&localStatus,R10		; Get local status to R10
			and.b	#STRESS,R10				; Extract stress bits
			cmp.b	R10,R9					; Compare incoming stress (R9) to ours (R10)
			_IF		_LO						; If incoming stress (R9) is less than ours (R10)
				mov		R8,R9					; Make a copy of incoming status for tests below
				mov.b	&localStatus,R10		; Get local status to R10
				movBits_B	R10,#STRESS|S_TYPE,R8 ; Replace incoming stress and type with ours (trashes R10)
				_COND
					and		#S_TYPE,R9
					cmp		#ALL_FULL,R9
				_AND_IF	_NE						; If incoming was not all considered full
					mov.b	&localStatus,R10
					and		#S_TYPE,R10
					cmp		#ALL_FULL,R10
				_AND_IF	_EQ						; and if local is in bypass
					bic		#UV_AF,R8 				; Clear the UV_AF (undervoltage or all considered full) bit
				_ENDIFS
			_ELSE							; Else incoming stress is not less than ours
				_IF		_EQ						; If incoming stress is equal to ours
					mov.b	&localStatus,R10		; Ensure UV trumps other types, particularly UT,
					and		#S_TYPE,R10				; which won't go away when sources dropped, and
					cmp		#UV_AF,R10				; may mask UV and prevent loads being dropped.
					_IF		_EQ						; If local is undervoltage
						movBits_B	R10,#S_TYPE,R8		; Replace incoming type with ours (trashes R10)
					_ENDIF
				_ENDIF
				; Incoming stress not less than ours
				mov		R8,R9					; Make a copy of incoming status for tests below
				_COND
					and		#S_TYPE,R9
					cmp		#ALL_FULL,R9
				_AND_IF	_EQ						; If incoming is all considered full
					mov.b	&localStatus,R10
					and		#S_TYPE,R10
					cmp		#ALL_FULL,R10
				_AND_IF	_NE						; and if local is not in bypass
					bic		#UV_AF,R8 				; Clear UV_AF (UV or all considered full) bit
				_ENDIFS
			_ENDIF							; End else incoming stress is not less than ours

			; Process incoming comms error bit.
			; Since we received a valid status byte, there is no local
			;	comms error, so just pass the incoming comms error bit through.

			; Send status or control a charger
			cmp.b	#255,&ID
			_IF		_NE						; If we're a CMU
				call	#TxByte						; Send the status byte. Wait buffer not full
			_ELSE								; Else we're in charger control mode
				mov.b	R8,&globalStatus			; '255sp' (or modbus equiv) reads global status
				call	#ControlContactors			; Control contactors (was call #ControlCharger)
			_ENDIF
		_ENDIF							; End if no comms error
		ret
; End of DoStatus


ControlContactors:
;
; Status byte is in R8. Use it to control contactors
;
		push 	R9
		push	R10

		; Check if the stress type can be ignored, based on the direction of the current.
		; But if the source contactors are off, treat it as if we are charging, and so ignore only
		; undervoltage stress.
		mov		R8,R9					; Take a copy of the status byte in R9
		_COND							; Begin a short-circuit conditional
			cmp		#10,&current			; Check the current, which is in tenths of an amp
		_IF_OR	_GE						; If there's 1 amp or more of charge current (positive)
			bit.b	#AcLfPvCtor,&CtorPortOUT ; Check the state of the source contactors
		_OR_IFS	_Z						; Or if the AC and left PV source contactors are off
			and		#S_TYPE,R9				; Isolate the two stress-type bits
			cmp		#UV_AF,R9				; Check if type of stress is ignore-on-charge
		_ELSE							; Else not charging
			cmp		#-9,&current			; Check the current, which is in tenths of an amp
			_IF		_L						; If 1 amp or more of discharge current (negative)
				and		#OV_UT,R9				; Isolate the single overvolt/undertemp stress-type bit
				cmp		#OV_UT,R9				; Check if type of stress is ignore-on-discharge
			_ELSE							; Else current between -1 amp and 1 amp
				clrz							; Ensure stress will not be ignored, by clearing EQ flag
			_ENDIF							; Endif 1 amp discharge
		_ENDIF							; Endif >= 1 amp charge or source contactors off

		; Treat ignorable stress as 7 and comms error as 15, for contactor control (will be smoothed)
		_IF		_EQ						; If we can ignore this stress
			mov		#7,R9					; Treat it as stress 7 (neutral) for contactor control
		_ELSE							; Else can't ignore
			mov		R8,R9
			and		#STRESS,R9				; Get stress into R9
		_ENDIF							; Endif ignore stress
		bit		#COM_ERR,R8
		_IF		_NZ						; If the comms error bit is set
			mov		#15,R9					; Treat it as stress 15 for contactor control
		_ENDIF								;   (it will be smoothed)

		; Calculate smoothed stress for controlling contactors
		rla2	R9						; Quadruple the incoming stress
		mov.b	&smoothStressX4,R10		; Get the previous smoothed stress times 4 into R10
		add		R10,R9
		add		R10,R9
		add		R10,R9					; R9 = 4*incoming + 3*4*previous
		incd	R9						; Add 2 for rounding
		rra2	R9						; Divide by 4 to get new smoothed stress times 4
		mov.b	R9,&smoothStressX4		; Save it for next time
		inc		R9						; Add 1 for rounding (don't add 2 or it won't descend fully)
		rra2	R9						; Divide by 4 to get smoothed stress

		cmp.b	#15,R9					; If smoothed stress is extreme
		_IF		_GE
			inc.b	&shutdownTimer
			cmp.b	#ShutdownTime,&shutdownTimer
			_IF		_HS						; And enough time has passed
				bic.b	#(BatPosCtor|BatNegCtor|AcLfPvCtor|RtPvCtor),CtorPortOUT	; Drop out all battery
																		; contactors, and we die
				; We need an endless loop here in case the BMU doesn't lose power.
				; It may still be powered up by the inverter capacitors, or some charge source.
				; This will require the red button to be pushed to remove power from the BMU
				; to reset it. After which, releasing the red may be sufficient to restart,
				; or you may also have to push the green.
				br		#Halt
			_ENDIF
		_ELSE							; Else
			clr.b	&shutdownTimer			; Clear the shutdown timer
		_ENDIF							; Endif


		; If all considered full (and no comms error), reset the coulomb counter
		_COND
			bit		#COM_ERR,R8
		_AND_IF	_Z
			mov		R8,R10					; Make a copy of the status byte in R10
			and		#S_TYPE,R10				; Extract the stress type bits
			cmp		#ALL_FULL,R10
		_AND_IF	_EQ						; If all cells are considered full
			; Set the discharge counter to a DoD of 0
			mov		#0,&discharge		; Lo word
			mov		#0,&discharge+2		; Hi word
			call	#UpdateSoC			; Update the pre-computed PWM counter advance value
		_ENDIFS ; All Considered Full and no comms error

		pop		R10
		pop		R9
		ret
; End of ControlContactors


DoPrecharge:
		; This code is designed to work with a number of different battery contactor
		; arrangements.
		; t0 thru t4 indicate the time order of switching during precharge.
		; P21 thru P25 are the numbers of the BMU connectors that drive the contactor coils.
		; The connector numbers increase as you go away from the BMU's 12 V input connector.
		; These BMU connectors are named respectively PRE BAT CHG DIS NRM in the software and schematic.
		;
        ; This is the contactor arrangement for the first DCM system installed at Kingscliff TAFE:
		;           + ___ -      - ___ +
		;        +----o o----------o o-----+
		;        | t4 DIS P24   t1 NRM P25 |
		;        |  + ___ -      - ___ +   |
		; Bat+ --+----o o----------o o-----+-- Load +
		;        | t3 BAT P22   t0 CHG P23 |
		;        |    ___          ___     |
		;        +----o o---------|___|----+
		;          t2 PRE P21    3R3 100W
		;
		;                          ___
		; Bat- -------------------|___|------- Load -
		;                      500A 50mV shunt
		;
		; This is the contactor arrangement for the first Pods system installed at Kingscliff TAFE:
		;           + ___ -
		; Bat+ --+----o o------------------+-- Load +
		;        | t3 BAT P22              |
		;        |    ___          ___     |
		;        +----o o---------|___|----+
		;          t2 PRE P21    3R3 100W
		;
		;           + ___ -        ___
		; Bat- -------o o---------|___|------- Load -
		;          t0 CHG P23  500A 50mV shunt
		;
		; Future DCM systems should have their contactors arranged like this:
		;           + ___ -
		;        +----o o-----+
		;        | t4 DIS P24 |
		;        |  + ___ -   |
		; Bat+ --+----o o-----+------------+-- Load +
		;        | t3 BAT P22              |
		;        |    ___          ___     |
		;        +----o o---------|___|----+
		;          t2 PRE P21    3R3 100W
		;
		;           + ___ -
		;        +----o o-----+
		;        | t1 NRM P25 |
		;        |  + ___ -   |    ___
		; Bat- --+----o o-----+---|___|------- Load -
		;          t0 CHG P23  500A 50mV shunt
		;
		; We stagger the turn-on of the contactors so that the DC-DC converter can cope.
		bis.b	#BatNegCtor,&CtorPortOUT 		; Turn on the lower charge-direction contactor
		mov		#160,R8						; 160 milliseconds (to allow for GX14 or EV200)
		call	#DelayMs					; Wait for economiser to reduce coil current
		bis.b	#RtPvCtor,&CtorPortOUT ; Turn on the upper charge-direction contactor
		mov		#160,R8						; 160 milliseconds
		call	#DelayMs					; Wait for economiser to reduce coil current

		; We may have come here after a bootstrap-load, with all contactors (except precharge) still on.
		; We should only turn on the precharge contactor if the positive contactor isn't already on,
		; because otherwise it may put too much load on the power supply and shut down the Monolith.
		bit.b	#BatPosCtor,&CtorPortOUT	; Check the positive contactor
		_IF		_Z							; If the positive contactor is off
			bis.b	#PreCtor,&CtorPortOUT		; Turn on the Precharge contactor
		_ENDIF
		mov		#3*1000/100,R12				; 3 seconds = 30 x 100 ms timeout
		_BEGIN
			mov		#100,R8						; 100 milliseconds; placed at start
			call	#DelayMs					;	of loop to allow ADC system to settle after reset
			call	#CapV						; Trashes R8, R9, R11 result in R10
			push	R10							; Save capacitor voltage measurement
			call	#BatV						; Trashes R8, R9, R11 result in R10
			pop		R8							; Restore cap voltage to R8
			sub		R8,R10						; R10 = BatV - CapV
			abs		R10							; R10 = Abs(BatV - CapV), allow for CapV > BatV
			cmp		#6*10,R10
			_WHILE	_HS							; Wait for less than 6 V across contactor
				dec		R12
		_UNTIL	_Z
				mov		#1,Rtos						; Fall thru to here on timeout
				call	#_errorLed					; We who are about to die beep at you
				bic.b	#PreCtor,&CtorPortOUT		; Turn off the Precharge contactor to save resistor
				bic.b	#BatNegCtor,&CtorPortOUT 		; Turn off the lower charge-direction contactor
				bic.b	#RtPvCtor,&CtorPortOUT 		; Turn off the upper charge-direction contactor
				br		#Halt						; Endless loop, but check for BSL password
			_ELSE									; Come here from WHILE, when less than 6 V
				; We stagger the turn-on of the contactors so that the DC-DC converter can cope.
				bis.b	#BatPosCtor,&CtorPortOUT ; Turn on the lower discharge-direction contactor
				mov		#160,R8						; 160 milliseconds
				call	#DelayMs					; Wait for economiser to reduce coil current
				bic.b	#PreCtor,&CtorPortOUT		; Turn off the Precharge contactor to save power
				mov		#160,R8						; 160 milliseconds
				call	#DelayMs					; Wait for pre-charge to come off
				bis.b	#AcLfPvCtor,&CtorPortOUT ; Turn on the upper discharge-direction contactor
				mov		#160,R8						; 160 milliseconds
				call	#DelayMs					; Wait for relay bounce and voltage settling
			_ENDIF
		ret


PiController:
;
; A PI controller whose input and output are in R8
; Input range is 0 to 15 (stress levels). Setpoint is 7.
; Output range is chargerVoltMin to chargerVoltMax (tenths of a volt).
;
#define Rerror R10			// Error register
#define Rderiv R9			// Derivative register
#define Routput R8			// Output register
			mov		#7,Rerror				; error = setpoint - measurement
			sub		R8,Rerror
			mov		Rerror,Rderiv			; deriv = error - prev_error
			sub		&piPrevError,Rderiv

			mov		&piPrevOutput,Routput	; output = prev_output + Kp * deriv + Ki * error
			; Insert rla Rderiv here to change Kp
			rla3	Rderiv					; Kp = 4
			add		Rderiv,Routput
			mov		Rerror,R9				; Overwrites unused Rderiv
			; Insert rla R9 here to change Ki
			add		R9,Routput				; Ki = 1

			mov		&chargerVoltMin,R9
			rla2	R9						; The combination of this rla2, the rla2 below,
											; and the rra2 at the end, have the effect of dividing
											; bit Kp and Ki by 4. So they are effectively 1 and 1/4.
			cmp		R9,Routput				; Clamp output between chargerVoltMin and chargerVoltMax
			_IF		_L
				mov		R9,Routput
			_ELSE
				mov		&chargerVoltMax,R9
				rla2	R9						; For effective reduction of Kp and Ki
				cmp		R9,Routput
				_IF		_GE
					mov		R9,Routput
				_ENDIF
			_ENDIF

			mov		Rerror,&piPrevError		; prev_error = error
			mov		Routput,&piPrevOutput	; prev_output = output
			rra2	Routput					; For effective reduction of Kp and Ki
			ret
; End of PiController


;
; Update the SoC meter's advance value (so the SoC meter will reflect a change made to the discharge
; counter)
; Preserves R8 and R9, trashes R10, clears R11
;
UpdateSoC:
MinAdvance	EQU			20					; To avoid timer compare wraparound
			push		R8
			push		R9
			; Though we use DoD here, the PWM interrupt routine inverts the output so it represents SoC
			call		#DepthOfDischarge	; Get DoD as value 0-1000 (0 to 100.0%)
			cmp			#MinAdvance,R9		; Compare with minimum value
			_IF			_LO					; If lower,
				mov			#MinAdvance,R9		; Enforce minimum value to avoid timer compare wrap
			_ENDIF
			cmp			#1000-MinAdvance,R9	; Compare with maximum value
			_IF			_HS					; If higher or same,
				mov			#1000-MinAdvance,R9	; Enforce maximum value to avoid timer compare wrap
			_ENDIF
			mov			R9,&socPwmAdv		; Save in the pre-computed advance variable
			pop			R9
			pop			R8
			ret


; Some calculations so we can see how much space we have left, by reading the listing.
freespace	EQU		_CMDCHRTBL-$
#define BCD(x) ( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent EQU BCD( (100*freespace)/(_CMDCHRTBL-PROG_START))

;---------------------------------------------------------------------------------
; Interrupt and entry-point jump table at the end of the third-last main-flash segment
;---------------------------------------------------------------------------------
				ORG		BSL2_START-$22	; FBDE for now
CMDCHRTBLEND	EQU		$				; Command character table ends immediately below lowest
										;  main-program entry point
jInterpretByte	br		#InterpretByte	; A branch to InterpretByte, independent of PROG_START

jUCA0TxIsr		br		#TxIsr			; UART transmit
jUCA0RxIsr		br		#RxIsr			; UART receive

jTA1TxRxIsr		br		#ChgTxRxIsr		; Combined TA1 CCR1 & CCR2 (transmit & receive capture/compare)
jTA1PwmIsr		br		#SocPwmIsr		; Timer A1 CCR0 (SoC PWM compare)

jInterpretInit	br		#InterpretInit	; A branch to InterpretInit, independent of PROG_START

jTA0TxRxIsr		br		#ScuTxRxIsr		; Combined TA0 CCR1 & CCR2 (transmit & receive capture/compare)
jTA0FllIsr		reti					; Timer A0 CCR0 (frequency locked loop capture).
				nop						;   This is handled directly by the BSL.
				ORG		BSL2_START-2	; FBFE for now
ProgPresence	DB		$AA				; For BSL2 to check before calling main program (InterpretByte)
ProgChecksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg

;---------------------------------------------------------------------------------
; Bootstrap loader, in the last main-flash segment
;---------------------------------------------------------------------------------
				ORG		BSL2_START		; Start of last main-flash segment
; Include the Bootstrap loader
#include "../common/BSL2.s43"			// Include bootstrap-loader and interrupt vectors
				ORG		$FFFE			; The reset vector
				DW		jBSL			; Reset to BSL main entry in case there is a crash

				END
