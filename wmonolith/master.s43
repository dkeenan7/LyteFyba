;
; This is a version of ACCEPT that doesn't interpret, but instead injects Z, G, i (etc) commands as
; needed and in synch with the incoming stream (i.e. it waits for either a CR or a timeout before
; sending)
;

AccMaster
		bit.b	#bBlocked,&masterFlags
		_IF		_Z						; Presently not blocked. A non carriage return non linefeed
										;	will block us
			_COND
				tst.b	R8				; Not null? (Indicates no char received)
			_AND_IF		_NZ
				cmp.b	#$0D,R8			; And not carriage return?
			_AND_IF	_NE
				cmp.b	#$0A,R8			; And not linefeed?
			_AND_IF	_NE
				bis.b	#bBlocked,&masterFlags	; We're now blocked
				mov		&ticks,R9				; Get the medium speed counter
				add		#1*StatusFreq,R9		; ~ one second later
				mov		R9,&masterUnblockTicks	; Save that time
			_ENDIFS
		_ELSE						; Presently blocked. A carriage return will unblock
			cmp.b	#$0D,R8				; Carriage return?
			_IF		_EQ
				bic.b	#bBlocked,&masterFlags
			_ELSE
				; Still blocked. Check for timeout, with care for wrapping
				cmp		&masterUnblockTicks,&ticks
				_IF _NN						; If ticks minus masterUnblockTicks is not negative
					bic.b	#bBlocked,&masterFlags ; then unblock anyway
				_ENDIF
			_ENDIF
		_ENDIF

		bit.b	#bSendZ,&masterFlags		; Is a Z command due?
		_IF		_NZ
			mov		#SelectCMU1,R10				; Transmit "1s" to select CMU 1 only
			call	#TxStringCk
			ClearWatchdog

			mov		&discharge+2,Rsec
			mov		#5,Rtos						; 5 digit field width
			push.b	&interpFlags				; Save number base
			bis.b	#bHexOutput,&interpFlags	; Set to hexadecimal output
			call	#_emitNum					; Transmit the number
			pop.b	&interpFlags				; Restore number base
			ClearWatchdog

			mov		#'Z',R8						; Transmit a "Z" for ZtoreDischarge
			call	#TxByteCk
			call	#TxEndOfPacket
			bic.b	#bSendZ,&masterFlags		; Don't repeat until needed
		_ENDIF

		bit.b	#bSendi,&masterFlags			; Is an 'i' command due?
		_IF		_NZ
			; For a BMU, the so-called link-voltage is really shunt current in 1/5ths of an amp.
			; This was shifted left and copied to ram &current (so tenths of an amp)
			; Tell the CMUs what the current is, by sending an 'i' command
			mov		&current,R10			; Get the saved current, tenths of an amp
			abs		R10						; Take the absolute value of the current in R10
			mov		R10,Rsec
			mov		#4,Rtos					; 4 digit field width
			ClearWatchdog
			call	#_emitNum				; Transmit the number
			ClearWatchdog
			cmp		#0,&current
			_IF		_L						; If current is negative
				mov		#'-',R8					; Transmit a postfix minus sign
				call	#TxByteCk
			_ENDIF
			mov		#'i',R8					; Transmit an "i" for current
			call	#TxByteCk
			call	#TxEndOfPacket
			bic.b	#bSendi,&masterFlags	; Don't repeat until needed
		_ENDIF							; End if 'i' command was due

		bit.b	#bSendInit,&masterFlags
		_IF		_NZ
			; If we're a BMU, ensure CMUs are using and expecting checksums, and sending status bytes,
			; then retrieve the high word of the discharge accumulator from CMU 1
			; The below can't be replaced by a single 9-byte string.
			; They must go as separate packets because the 'k' must be sent without checksum
			; and the 1sG is for a single CMU.
			mov		#'\r',R8				; Clear any junk
			call	#TxByte
			mov		#'k',R8					; Transmit "k" with no checksum
			call	#TxByte					;	to tell CMUs to send and expect checksums
			mov		#'\r',R8
			call	#TxByte

			mov		#EnableStatus,R10		; Transmit "0K" to tell CMUs to send status bytes
			call	#TxStringCk
			call	#TxEndOfPacket

			mov		#SelectCMU1Get,R10		; Transmit "1sG" to select CMU 1 only, and get discharge
			call	#TxStringCk
			call	#TxEndOfPacket

			bic.b	#bSendInit,&masterFlags	; Don't repeat
		_ENDIF

		ret

SelectCMU1		DB		2, '1s'			; Length-prefixed command string to select CMU 1
EnableStatus	DB		2, '0K'			; Length-prefixed command string to enable status sending
SelectCMU1Get	DB		3, '1sG'		; Length-prefixed command string to get saved discharge counter
		ALIGN	1

;-------------------------------------------------------------------------------
; The outer (packet) interpreter, specialised for BMUs in wmonolith
; Sends all output to SCU port; checks bEchoResponses flag, and if set echoes all responses
; (Wunth and Modbus) to SCU port
; WmACCEPT	( char -- )	; Accept the character in R8 into the line buffer.
; Trashes R8 and R9, and more if carriage return is processed.
; Implements backspace editing, Xon/Xoff and Escape, and calls the inner interpreter
; to interpret the line when a valid checksum and a carriage return are received.
WmBmuACCEPT
		mov		&ToIN,R9
		_CASE

		_OFb	#$0A,R8			; Throw away any line feeds (after carriage returns from modbus)
		_ENDOF

		_OFb	#$0D,R8			; Carriage return = end of packet
			cmp		#TIBEnd,R9
			_IF		_LO				; If packet buffer not full
				bit.b	#bEchoResponses,&interpFlags
				; This is e.g. to allow SCU to see Wunth or Modbus responses from CMUs
				_IF		_NZ				; If echoing responses
					mov.b	&TIB,R8				; Get first char of text input buffer
					xor.b	#'\\',R8			; R8 is 0 iff it was a slosh, starting a Wunth resp.
					_IF		_NZ					; Otherwise,
						cmp.b	#':',&TIB			; Does it start with a colon? (modBus resp or cmd)
						_IF		_EQ
							cmp		#TIB+13,R9			; Would the CR be at position 13?
							_IF		_EQ					; If so, it's a Modbus response
								clr		R8					; Clear boolean R8 if so
							_ENDIF
						_ENDIF
					_ENDIF
					tst		R8						; Test our condition flag
					_IF		_Z						; Zero indicates a response to be echoed
						; Echo the response
						push	R10
						push	R11
						mov		#TIB,R10			; Start of TIB to R10
						mov		R9,R11				; R11 has position where CR would be
						mov.b	#$0D,0(R11)			; Store CR there
						sub		#TIB-1,R11			; R11 has length including CR
						push	&TxBytePtr
						mov		#ScuTxByte,&TxBytePtr ; Switch to SCU output
						call	#TxBytes			; Send this string
						pop		&TxBytePtr			; Restore TxByte destination
						pop		R11
						pop		R10
					_ENDIF					; Endif copying this response
				_ENDIF					; Endif bEchoResponses
				bit.b	#bChecksumming,&interpFlags
				_IF		_NZ				; If checksumming
					cmp.b	#':',&TIB
					_IF		_NE				; And if not a modbus packet (starts with colon)
						tst.b	&rxCksum
						_IF		_Z				; And if good checksum
							dec		R9				; Prepare to overwrite checksum with EXIT command char
							cmp		#TIB,R9			; Handle case of empty packet with no checksum
							_IF		_LO
								mov		#TIB,R9
							_ENDIF
					_END_PRIOR_IF			; End if not modbus
				_END_PRIOR_IF			; End if checksumming
							; We get here when not-checksumming or a modbus packet or a good checksum
							mov.b	#EXIT,0(R9) 	; Overwrite checksum or CR with EXIT command character
							bit.b	#bDontInterpret,&interpFlags
							_IF		_Z				; If the dont-interpret flag is clear
								mov		#TIB,Rip		; Interpret the packet as command characters
								push	&TxBytePtr
								mov		#ScuTxByte,&TxBytePtr ; Switch to SCU output
								call	#_ENTER
								pop		&TxBytePtr		; Restore TxByte destination
							_ENDIF					; End if dont-interpret flag is clear
						_ENDIF					; End if good checksum
			_ENDIF					; End if packet buffer not full
			mov		#TIB,&ToIN		; Initialise packet buffer pointer
			clr.b	&rxCksum		; Clear the packet checksum
		_ENDOF					; End of carriage return

		_OFb	#$08,R8			; Backspace editing
			cmp		#TIBEnd,R9
			_IF		_LO				; If packet buffer not full
				dec		R9				; Decrement the pointer, but
				cmp		#TIB,R9			; don't go back past start of packet
				_IF		_LO
					mov		#TIB,R9
				_ENDIF
				mov		R9,&ToIN
			_ENDIF					; Endif packet buffer not full
		_ENDOF					; EndOf backspace

		_OFb	#$11,R8			; XON (ctrl-Q) to exit no-echo mode
			bic.b	#bDontEcho,&interpFlags ; Clear the don't-echo flag
		_ENDOF					; EndOf XON

		_OFb	#$13,R8			; XOFF (ctrl-S) to enter no-echo mode
			bit.b	#bDontInterpret,&interpFlags
			_IF		_Z				; If the dont-interpret flag is clear
				bis.b	#bDontEcho,&interpFlags ; Set the don't-echo flag
			_ENDIF
		_ENDOF					; EndOf XOFF

		_OFb	#$1B,R8			; Escape to exit eXclusive mode (single CMU interaction)
			bic.b	#bDontInterpret,&interpFlags ; Clear the don't-interpret flag
		_ENDOF					; EndOf escape

		; Default case, if not CR, BS, XON, XOFF or ESC
			cmp		#TIBEnd,R9
			_IF		_LO				; If packet buffer not full
				mov.b	R8,0(R9)		; Write the byte to the buffer
				inc		&ToIN			; Increment the pointer
				xor.b	R8,&rxCksum	; Accumulate the Wunth checksum
			_ENDIF					; Endif packet buffer not full

		_ENDCASE				; End Case char

		ret

