;
; Command character definitions common to both the monitor and BSLwriter,
; which need no customisation in either
;

; EXIT ( -- ); Return from interpreting a sequence of command characters.
; Causes any characters following to be treated as comments only (Forth "\").

		xCODE	'\\',EXIT,_EXIT	; Slosh (backslash)
		incd	SP			; Drop the return address within the interpreter
		ret					; Return to whoever called the interpreter (_ENTER)
		
; HEX ( flag -- ) ; Set the number base to hexadecimal

		xCODE	'h',HEX,_HEX
		bis.b	#bHexOutput,&intFlags
_Space	ret					; When _Space is called, be a no-op (for separating literal numbers)

; DECIMAL ( flag -- ) ; Set the number base to decimal

		xCODE	'd',DECIMAL,_DECIMAL
		bic.b	#bHexOutput,&intFlags
		ret

; CLIT ( -- c ) ; Character literal. Pronounced "see lit".
; Treat the next character in a command sequence as a literal character.

		xCODE	'\'',CLIT,_CLIT	; Tick (single-quote)
;		PUSH	Rtos
;		MOV.B	@Rip+,Rtos
		DPUSHb	@Rip+
		ret

; changeSign ( n -- -n )
;
		xCODE	'-',changeSign,_changeSign	; Postfix unary minus
		inv		Rtos
		inc		Rtos
		ret

; dollarHex ( -- )
;
		xCODE	'$',dollarHex,_dollarHex	; $ for starting hex number input
		bis		#1<<14,SR					; Set the hex flag
		ret

;
; eXclusive ( id -- )	; Sticky version of select. Type <ESC> to exit.
;
		xCODE	'x',eXclusive,_eXclusive
		bis.b	#bDontInterpret,&intFlags
		; Fall through to _Select
;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		xCODE	's',Select,_Select
		cmp.b	&ID,Rtos			; Correct ID?
;		pop		Rtos				; Pop the argument
;		DROP						; Pop the argument
		_IF		_NE					; If not correct ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ELSE						; Else
			bic.b	#bDontInterpret,&intFlags ; Needed to handle _eXclusive fall-through
		_ENDIF						; Endif
		ret
		
;
; emitNum  ( n count -- ) ; Emit an integer n as count digits in the current number base
; Trashes R8-R12
		
		xCODE	'n',emitNum,_emitNum
#if 1	// This version takes up 7 more words of flash but doesn't use any stack (apart from its return address)
		mov		#4,R12				; Loop 5 times for decimal conversion
		bit.b	#bHexOutput,&intFlags ; Hexadecimal or decimal?
		_IF		_Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TX_ByteCk
				inv		Rsec				; Negate to get absolute value
				inc		Rsec
			_ENDIF						; Endif negative
			mov		Rsec,R10			; Get n as 16.16 bit fixpoint Dividend in R10:R9
			mov		#40000,R8			; Divisor in R8 is 4 * 10^4
			mov		R8,R9				; Instead of clearing R9 and adding one to the quotient later
			call	#UMSlashMod			; R10:R9 / R8 -> R9, remainder to R10 (ignored), clears R11
			clr		R10					; Ignore remainder. Treat R10:R9 as 16.16 bit fixpoint again
			rla		R9					; Shift R10:R9 2 bits left
			rlc		R10					; to get most sig decimal digit in R10 (max value 3)
			rla		R9
			rlc		R10
			mov		#10,Rsec			; Rsec := 10 (radix)
		_ELSE						; Else hexadecimal
			dec		R12					; Loop only 4 times for hexadecimal conversion
			dec		Rtos				; For hex, send one less digit than requested
			cmp		#2,Rtos				; but enforce a minimum of 2 digits
			_IF		_LO
				mov		#2,Rtos
			_ENDIF
			mov.b	#'$',R8				; Emit dollar sign for hex
			call	#TX_ByteCk
			mov		Rsec,R9				; R9 := n
			mov		#16,Rsec			; Rsec := 16 (radix)
			_BEGIN
				mov		Rsec,R8				; Radix (10 or 16) into R8
				call	#UMStar				; R9 * R8 -> R10:R9, clears R11
		_CS_SWAP					; [Make next _ENDIF apply to prev _ELSE so decimal skips first multiply]
		_ENDIF						; End hexadecimal
				cmp		Rtos,R12			; Only convert and send the digit if it was asked for
				_IF		_LO					; Equivalent to _IF _NC. So clrc isn't necessary below
					mov.b	R10,R8				; ASCII conversion follows
			;		clrc						; Because dadd is always done with carry on MSP430
					dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
					dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			;		and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
					mov		R9,Rthd				; Save R9
					call	#TX_ByteCk			; Transmit byte (accumulating checksum). Trashes R9
					mov		Rthd,R9				; Restore R9
				_ENDIF
				dec		R12					; Decrement loop counter
			_UNTIL	_L					; Jump back to matching _BEGIN if loop counter not negative

#else	// This version of emitNum takes less flash but uses up to 8 bytes of stack to reverse digits
		bit.b	#bHexOutput,&intFlags ; Hexadecimal or decimal?
		_IF		_Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TX_ByteCk
				inv		Rsec				; Negate
				inc		Rsec
			_ENDIF						; Endif negative
			mov.b	#10,R8			; Divisor in R8 is number base
		_ELSE						; Else hexadecimal
			dec		Rtos				; Use one less digit
			mov.b	#'$',R8				; Emit dollar sign
			call	#TX_ByteCk
			mov.b	#16,R8			; Divisor in R8 is number base
		_ENDIF						; End hexadecimal
		dec		Rtos				; Count := Count-1
		_IF		_L					; Enforce a minimum of 2 digits
			mov		#1,Rtos
		_ENDIF
		mov		Rtos,R12			; Count to R12
		mov		Rsec,R9				; Dividend in R10:R9 will have n initially
		dec		R12					; Count := Count-1
		_BEGIN
			clr		R10
			call	#UMSlashMod			; dividend/base -> R9, remainder to R10
			push	R10					; Push remainder
			dec		R12
		_UNTIL	_L					; R9 keeps quotient as next dividend
		mov		R9,R8
		; Now we have n-1 results on the stack and the last one in R8; print these as hex/decimal
		_BEGIN
			clrc						; Because dadd is always done with carry on MSP430
			dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
			dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
			call	#TX_ByteCk
			dec		Rtos
		_WHILE	_NN
			pop		R8
		_REPEAT
#endif
		ret


_prettyPrint3:
		mov		#3,Rtos
		; Fall thru to _prettyPrint
;
; Pretty print  ( ch n m -- ) Print n as a comment packet with m digits
; and precede with ID and ch.
; (no command letter)
_prettyPrint:
		push.b	&intFlags			; Save current number base
		
		DELAY_IF_NEEDED				; Allow time for CR to be echoed upstream if needed
		mov		#EXIT,R8			; Initial slosh (EXIT command or comment character)
		call	#TX_ByteCk			; Stops rest of packet being interpreted
		
		push	Rsec				; Save n
		push	Rtos				; Save m
		push	Rthd				; Save ch
		
		bic.b	#bHexOutput,&intFlags ; Set to decimal output
		mov.b	&ID,Rsec
		mov		#3,Rtos
		call	#_emitNum			; Emit the ID in decimal
		
		mov		#':',R8				; Colon separator
		call	#TX_ByteCk
		
		pop		R8					; Restore ch (type of measurement)
		call	#TX_ByteCk			; Transmit ch
		
		mov		#' ',R8				; Transmit a space
		call	#TX_ByteCk
		
		pop		Rtos				; Restore m
		pop		Rsec				; Restore n
		pop.b	&intFlags			; Restore number base to print n with
		call	#_emitNum
		
		call	#TX_Cksum			; Transmit checksum if required, then clear checksum.
		
		mov		#'\r',R8			; Carriage return to R8
		call	#TX_Byte			; Emit
		
		bic.b	#ACTLED,&P1OUT		; Set the (inverted) activity LED here to mimic old behaviour
		ret
		
;
; cellVolt ( -- )
; Transmit the cell voltage measurement in millivolts (0 to 4095 mV)
;
		xCODE		'v',cellVolt,_cellVolt
		call		#cellV				; Return cell voltage in millivolts in R10
		mov			#'v',Rthd			; Type is cell Voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Cell temperature measurement ( -- )
; Transmit cell temperature in degrees C
;
		xCODE		't',cellTemp,_cellTemp
		call		#temp				; Return temperature in degrees Celsius in R10
		mov			#'t',Rthd			; Type is temperature
										; Don't use degree symbol ($F8 Terminal font). Looks like status
		mov			R10,Rsec			; Result in degrees Celsius
		mov			#2,Rtos				; Print 2 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Link voltage measurement ( -- )
; Transmit link voltage in millivolts, -1500 to 1500 or 9999 for "invalid".
		xCODE		'l',linkVolt,_linkVolt
		call		#linkV				; Return link voltage in millivolts in R10
		mov			#'l',Rthd			; Type is Link voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits... would 3 be enough?
		jmp			_prettyPrint		; Tail-call pretty-print and return


;
; Turn on or off the error LED (bool -- )
;
		xCODE	'e',errorLed,_errorLed
		tst		Rtos
		_IF		_Z
			bic.b	#ERRLED,&P2OUT			; Turn off the error LED
			bic.b	#PIEZO,&P1SEL			; Short out the piezo
		_ELSE
			bis.b	#ERRLED,&P2OUT			; Turn on the error LED
			bis.b	#PIEZO,&P1SEL			; Make the piezo squeal
		_ENDIF

;		pop		Rtos				; Remove operand
		ret

;
; Quiet (bool -- )
; Stop the piezo coming on with the error LED
		xCODE	'Q',quiet,_quiet
		allBitsIfZ	Rtos,Rtos		; IF Rtos is zero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#LFXT1S_2,&BCSCTL3 ; Move only #LFXT1S_2 bit from Rtos to &BCSCTL3. Trashes Rtos
		; Select either VLOCLK (~12 kHz) or LFXT1 (unused crystal oscillator) as source for ACLK divider
;		pop		Rtos				; Remove operand
		ret
		