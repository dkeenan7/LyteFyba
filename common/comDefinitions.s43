;
; Command character definitions common to TestICal, monitor, monolith and wmonolith,
; which need no customisation in any of them.
;

BmuModbusID			EQU	100				; Normally the highest valid ID of 247, but Geli use 100
BroadcastModbusID	EQU	BmuModbusID - 1

; EXIT ( -- ); Return from interpreting a sequence of command characters.
; Causes any characters following to be treated as comments only (Forth "\").
;
		xCODE	'\\',EXIT,_EXIT	; Slosh (backslash)
		incd	SP			; Drop the return address (which is within the interpreter)
		ret					; Return to whoever called the interpreter (_ENTER)

; HEX ( flag -- ) ; Set the output number base to hexadecimal
;
		xCODE	'h',HEX,_HEX
		bis.b	#bHexOutput,&interpFlags
_Space	ret					; When _Space is called, be a no-op (for separating literal numbers)

; DECIMAL ( flag -- ) ; Set the output number base to decimal
;
		xCODE	'd',DECIMAL,_DECIMAL
		bic.b	#bHexOutput,&interpFlags
		ret

; C_LIT ( -- c ) ; Character literal. Also acts like Forth's "tick".
; Treat the next character in a command sequence as a literal character.
; or equivalently, return the execution token of the next command.
		xCODE	'\'',C_LIT,_C_LIT	; Tick (single-quote)
		DPUSHb	@Rip+
		ret

; EXECUTE ( c -- ) ; Interpret the character on the top of the interpreter data stack as a command.
; The inverse of C_LIT or tick.
		xCODE	'`',EXECUTE,_EXECUTE	; Tock (back-quote)
		DPOPb	Rw			; Pop the top of the interpreter data stack into Rw
		incd	SP			; Drop the return address (which is within the interpreter)
		br		#_RUN		; Interpret the character in Rw

; QUOTE ( "ccc<quote>" -- c-addr u )
; Parse, from the command sequence, characters ccc delimited by " (double quote).
; Return c-addr and u that describe a string consisting of the characters ccc.
; c-addr points to the first character and u is the length of the string.
; The caller must not alter the returned string.
		xCODE	'"',QUOTE,_QUOTE	; Double-quote
		DPUSH	Rip			; Push the address of the first character
		DPUSH	#0			; Push a tentative zero length, Rtos := 0
		_DO
			mov.b	@Rip+,Rw	; Read a character and increment the interpreter pointer
			cmp.b	#'"',Rw		; Check if the character is a double quote
			_WHILE	NE			; While the character is not a double-quote
				cmp.b	#EXIT,Rw	; Check if at end of command packet, in case quote was omitted
				_WHILE	NE			; While the character is not an EXIT command
					inc	Rtos			; Increment the length
		_AGAIN				; Loop back to _DO
				_ENDIF				; End While not EXIT command (end of command packet)
				dec		Rip			; Back up so the EXIT command gets interpreted
			_ENDIF				; End While not a double-quote
		ret

; TYPE (c-addr u -- )
; If u is greater than zero, emit the character string specified by pointer c-addr and length u.
		xCODE	'T'|'y' <<8,TYPE,_TYPE	; 'Ty' collides with 'Ti, 'Tq', 'Li', 'Lq', 'Ly'
		_DO
			tst		Rtos
		_WHILE	NZ
			mov.b	@Rsec+,R8
			call	#TxByteCk
			dec		Rtos
		_ENDW
		DROP
		DROP
		ret

; CR ( -- )
; Emit an end-of-packet, i.e. a carriage return, preceded by a checksum if required.
		xCODE	'C'|'r' <<8,CR,_CR	; 'Cr' collides with 'Cb, 'Cj', 'Cz'
		br	#TxEndOfPacket			; Tail-call TxEndOfPacket and return

; changeSign ( n -- -n )
;
		xCODE	'-',changeSign,_changeSign	; Postfix unary minus
		inv		Rtos
		inc		Rtos
		ret

; dollarHex ( -- )
;
		xCODE	'$',dollarHex,_dollarHex	; $ for starting hex number input
		bis		#1<<14,SR					; Set the hex flag
		ret

;
; eXclusive ( id -- )	; Sticky version of select. Type <ESC> to exit.
;
		xCODE	'x',eXclusive,_eXclusive
		bis.b	#bDontInterpret,&interpFlags
		; Fall through to _Select
;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		xCODE	's',Select,_Select
		cmp.b	&ID,Rtos			; Correct ID?
;		pop		Rtos				; Pop the argument
;		DROP						; Pop the argument
		_IF		NE					; If not correct ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ELSE						; Else
			bic.b	#bDontInterpret,&interpFlags ; Needed to handle _eXclusive fall-through
		_ENDIF						; Endif
		ret

;
; eXclude ( id -- )	; Sticky version of deSelect. Type <ESC> to exit.
;
		xCODE	'X',eXclude,_eXclude
		cmp.b	&ID,Rtos			; specified ID?
		_IF		EQ					; If specified ID
			bis.b	#bDontInterpret,&interpFlags	; Stop interpreting
		_ENDIF
		ret

;
; deSelect ( id -- ) ; Ignore to end of line if ID on TOS is our ID
;
		xCODE	'S',deSelect,_deSelect
		cmp.b	&ID,Rtos			; Specified ID?
		_IF		EQ					; If specified ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ENDIF						; Endif
		ret

;
; ? GetWord - get a word (NOT to stack) and display it (Forth ?) ( addr -- )
;
			xCODE	'?',GetWord,_GetWord
			mov		#'?',Rthd
			mov.w	@Rtos,Rsec
			mov		#5,Rtos
			br		#_prettyPrint			; Tail-call pretty-print and return

;
; C? GetByte - get a byte (C for char) (NOT to stack) and display it ( addr -- )
;
			xCODE	'C'|'?' <<8,GetByte,_GetByte	; 'C?' collides with 'Co' 'Cg' 'Cw' 'C'' 'C/'
			mov		#'C'|'?'<<8,Rthd
			mov.b	@Rtos,Rsec
;			mov		#3,Rtos
			br		#_prettyPrint3			; Tail-call pretty-print of 3 digits and return

_emitNum4:
		mov		#4,Rtos				; Common to want 4
		jmp		_emitNum
_emitNum3:
		mov		#3,Rtos				; or 3 digits
		; Fall through to _emitNum
		;
;
; emitNum  ( n count -- ) ; Emit an integer n as count digits in the current number base
; Trashes R8-R12

		xCODE	'N'|'o' <<8,emitNum,_emitNum	; 'No' collides with 'Ng', 'Nw', 'Vg', 'Vo', 'Vw'
#if 1	// This version takes up 7 more words of flash but doesn't use any stack (except return address)
		mov		#4,R12				; Loop 5 times for decimal conversion
		bit.b	#bHexOutput,&interpFlags ; Hexadecimal or decimal?
		_IF		Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TxByteCk
				inv		Rsec				; Negate to get absolute value
				inc		Rsec
			_ENDIF						; Endif negative
			mov		Rsec,R10			; Get n as 16.16 bit fixpoint Dividend in R10:R9
			mov		#40000,R8			; Divisor in R8 is 4 * 10^4
			mov		R8,R9				; Instead of clearing R9 and adding one to the quotient later
			call	#UMSlashMod			; R10:R9 / R8 -> R9, remainder to R10 (ignored), clears R11
			clr		R10					; Ignore remainder. Treat R10:R9 as 16.16 bit fixpoint again
			rla		R9					; Shift R10:R9 2 bits left
			rlc		R10					; to get most sig decimal digit in R10 (max value 3)
			rla		R9
			rlc		R10
			mov		#10,Rsec			; Rsec := 10 (radix)
		_ELSE						; Else hexadecimal
			dec		R12					; Loop only 4 times for hexadecimal conversion
			dec		Rtos				; For hex, send one less digit than requested
			cmp		#2,Rtos				; but enforce a minimum of 2 digits
			_IF		LO
				mov		#2,Rtos
			_ENDIF
			bit.b	#bModbusOutput,&interpFlags
			_IF		Z					; If not in modbus output mode
				mov.b	#'$',R8				; Emit dollar sign for hex
				call	#TxByteCk
			_ENDIF
			mov		Rsec,R9				; R9 := n
			mov		#16,Rsec			; Rsec := 16 (radix)
			_DO
				mov		Rsec,R8				; Radix (10 or 16) into R8
				call	#UMStar				; R9 * R8 -> R10:R9, clears R11
		_END_PRIOR_IF				; End hexadecimal
				cmp		Rtos,R12			; Only convert and send the digit if it was asked for
				_IF		LO					; Equivalent to _IF NC. So clrc isn't necessary below
					mov.b	R10,R8				; ASCII conversion follows
			;		clrc						; Because dadd is always done with carry on MSP430
					dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
					dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			;		and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
					mov		R9,Rthd				; Save R9
					call	#TxByteCk			; Transmit byte (accumulating checksum). Trashes R9
					mov		Rthd,R9				; Restore R9
				_ENDIF
				dec		R12					; Decrement loop counter
			_UNTIL	L					; Jump back to matching _DO if loop counter not negative

#else	// This version of emitNum takes less flash but uses up to 8 bytes of stack to reverse digits
		bit.b	#bHexOutput,&interpFlags ; Hexadecimal or decimal?
		_IF		Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TxByteCk
				inv		Rsec				; Negate
				inc		Rsec
			_ENDIF						; Endif negative
			mov.b	#10,R8			; Divisor in R8 is number base
		_ELSE						; Else hexadecimal
			dec		Rtos				; Use one less digit
			mov.b	#'$',R8				; Emit dollar sign
			call	#TxByteCk
			mov.b	#16,R8			; Divisor in R8 is number base
		_ENDIF						; End hexadecimal
		dec		Rtos				; Count := Count-1
		_IF		L					; Enforce a minimum of 2 digits
			mov		#1,Rtos
		_ENDIF
		mov		Rtos,R12			; Count to R12
		mov		Rsec,R9				; Dividend in R10:R9 will have n initially
		dec		R12					; Count := Count-1
		_DO
			clr		R10
			call	#UMSlashMod			; dividend/base -> R9, remainder to R10
			push	R10					; Push remainder
			dec		R12
		_UNTIL	L					; R9 keeps quotient as next dividend
		mov		R9,R8
		; Now we have n-1 results on the stack and the last one in R8; print these as hex/decimal
		_DO
			clrc						; Because dadd is always done with carry on MSP430
			dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
			dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
			call	#TxByteCk
			dec		Rtos
		_WHILE	NN
			pop		R8
		_ENDW
#endif
		ret


;
; GetCellVolt ( -- )
; Transmit the cell (strap+) voltage measurement in millivolts (0 to 4348 mV)
;
		xCODE		'v',GetCellVolt,_GetCellVolt
		call		#GetCellV			; Return cell voltage in millivolts in R10
		mov			#'v',Rthd			; Type is cell Voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; GetBoltPlVolt ( -- )
; Transmit the cell (bolt+) voltage measurement in millivolts (0 to 4348 mV)
;
		xCODE		'V',GetBoltPlVolt,_GetBoltPlVolt
		call		#GetBoltPlV			; Return bolt+ voltage in millivolts in R10
		mov			#'V',Rthd			; Type is cell Voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Cell temperature measurement ( -- )
; Transmit cell temperature in degrees C
;
		xCODE		't',GetCellTemp,_GetCellTemp
		call		#GetTemp			; Return temperature in degrees Celsius in R10
		mov			#'t',Rthd			; Type is temperature
										; Don't use degree symbol ($F8 Terminal font). Looks like status
		mov			R10,Rsec			; Result in degrees Celsius
		mov			#2,Rtos				; Print 2 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

#ifdef	KINGSCLIFF_DCM
;
; External thermistor temperature measurement ( -- )
; Transmit cell temperature in degrees C
;
		xCODE		'H',GetExtTemp,_GetExtTemp
		call		#extT				; Return temperature in degrees Celsius in R10
		mov			#'H',Rthd			; Type is temperature
										; Don't use degree symbol ($F8 Terminal font). Looks like status
		mov			R10,Rsec			; Result in degrees Celsius
		mov			#2,Rtos				; Print 2 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return
#endif

;
; Current shunt voltage x20 for BMU, Negative terminal volt drop for CMU ( -- )
; Display in signed millivolts -1500 to 1500 or 9999 for "invalid".
; Corresponds to fifths of an amp with a 200 A 50 mV shunt
		xCODE		'I'|'s' <<8,CurrSh,_CurrSh	; 'Is' collides with 'Ia' 'Ic' 'Ik' 'Qa' 'Qc' 'Qk' 'Qs'
		xCODE		'n',NegBolt,_NegBolt		; 'n' alias to allow keyboard auto-repeat when testing
		call		#GetBoltMiV			; Return bolt- voltage in millivolts in R10
		mov			#'I'|'s'<<8,Rthd	; Characters of command being responded to
		mov			R10,Rsec			; Result in fifths of an amp (with a 200 A 50 mV shunt)
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return


GetLinkV:
		call		#GetBoltMiV			; Return bolt- or shuntx20 in mV in R10
		cmp.b	#255,&ID
		_IF		EQ						; If we're a BMU
			mov			R10,Rsec			; Result to Rsec
		_ELSE
			abs			R10					; Absolute value: easier to compare, and sign is meaningless
											;	unless you know whether pos or neg strap!
			push		R10					; Remember this neg term value
			mov			#CellVChan<<12,R8	; Shifted ADC channel for CellV voltage divider
			call		#MeasAndCorrCell
			push		R10					; Save strap voltage
			mov			#BoltVPlChan<<12,R8 ; Shifted ADC channel for BoltVPl voltage divider
			call		#MeasAndCorrBoltPl	; Measure and correct using the BoltPL corrections
			sub			R10,0(SP)			; TOS has bolt/array - cell/battery
			pop			R10					; R10 has pos term strap drop
			abs			R10					; Absolute value
			cmp			R10,0(SP)			; Compare pos and neg drops
			_IF			LO					; If 0(SP) < R10
				mov			R10,0(SP)			; Replace it with R10
			_ENDIF
			pop			R10					; Worst result to R10
		_ENDIF
		ret

;
; Link voltage (max abs volt drop across any terminal) for CMU, Current shunt voltage x20 for BMU ( -- )
; Display in signed millivolts, -1500 to 1500 or 9999 for "invalid".
; Corresponds to fifths of an amp with a 200 A 50 mV shunt
		xCODE		'l',LinkVolt,_LinkVolt
		call		#GetLinkV			; Get the worst link voltage
		mov			R10,Rsec			; To Rsec for display
		mov			#'l',Rthd			; Type is Link voltage
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Measure Vcc ( -- )	; Emit the Vcc voltage in millivolts
;
		xCODE	'M'|'v' <<8,MeasVcc,_MeasVcc	; 'Mv' collides with 'Mf' 'Mn' 'Uv' 'Uf' 'Un'
		xCODE	'o',MeasVcc2,_MeasVcc2			; 'o' alias to allow keyboard auto-repeat when testing
		mov		#0xB<<12,R8				; Choose the internal half-supply analog input
		call	#MeasAndCorrCell		; Gives us 0-4092 in R10, for 0-1.5 V
		mov		R10,R8
		mov		#48047,R9				; 3000/4092*65536
		call	#UMStar					; R10:R9 = R8 * R9
		rla		R9						; Do rounding
		adc		R10
		mov		#'M'|'v' <<8,Rthd		; Type is Vcc Measurement
		mov		R10,Rsec				; Result in millivolts
		mov		#4,Rtos					; Print 4 digits
		br		#_prettyPrint			; Tail-call pretty-print and return


#if INSULATION_MONITORING
;
; TouchValue ( -- )
; Transmit the raw touch value (0 to 4092 mV).
; This is an uncalibrated measurement as it is the touch current times the opto's CTR (0.63 to 1.25)
; times R17 (120R), scaled to 4092 counts for 1500 mV (ADC reference).
;
		xCODE		'T'|'o' <<8,touchValue,_touchValue	; 'To' collides with 'Tg' 'Tw' 'Lg' 'Lo' 'Lw'
		cmp.b	#255,&ID					; If we're a BMU
		_IF		EQ
			call		#GetTouchV			; Return touch value (0 to 4092) in R10
			mov			#'T'|'o' <<8,Rthd	; Command characters
			mov			R10,Rsec			; Result
			mov			#4,Rtos				; Print 4 digits
			call		#_prettyPrint		; Call pretty-print
		_ENDIF
		ret

;
; Insulation test ( -- )
; Transmit the prospective touch current in tenths of a milliamp (0 to 999.9 mA)
; This is a calibrated result based on 3 touch measurements and a battery voltage measurement
; and the fact that the test resistors are 100k and the battery voltage is divided by 109.
; Expect approximately the following readings with the following leakage test resistors and 360 V battery
; 470k 8, 100k 36, 6.8k 501, 2.2k 1390, 0k 9216.
		xCODE		'J',insulationTest,_insulationTest
		; Register definitions
#define RCellV R12				// Battery voltage divided by 109 (in mV). Average cell voltage.
#define Rmeas R14				// Max of touch measurements when any one relay is on.
#define Rtest R15				// Touch self-test value when both relays are on.
		cmp.b	#0,&ID				; If we're an IMU
		_IF		EQ
			call	#GetCellV			; Return battery_voltage/109 in millivolts in R10
			mov		R10,RCellV

			; Positive relay only
			bis.b	#RelayP,&P2OUT		; Turn on positive relay
			mov		#130,R8				; 130 milliseconds
			call	#DelayMs			; Wait for relay bounce and voltage settling
			call	#GetTouchV			; Return touch value in R10
			mov		R10,Rmeas

			; Both relays
			bis.b	#RelayM,&P2OUT		; Turn on negative relay
			mov		#130,R8				; 130 milliseconds
			call	#DelayMs			; Wait for relay bounce and voltage settling
			call	#GetTouchV			; Return touch value in R10
			; This allows calibration, as it will represent the battery voltage divided by 100k
			; irrespective of any leakage resistances, assuming only that the two optos
			; have similar CTRs.
			mov		R10,Rtest

			; Negative relay only
			bic.b	#RelayP,&P2OUT		; Turn off positive relay
			mov		#130,R8				; 130 milliseconds
			call	#DelayMs			; Wait for relay bounce and voltage settling
			call	#GetTouchV			; Return touch value in R10

			cmp		R10,Rmeas			; Keep the maximum of the two single-relay measurements
			_IF		LO
				mov		R10,Rmeas
			_ENDIF

			; Both relays off
			bic.b	#RelayM,&P2OUT		; Turn off negative relay

			mov.b	#$FF,R8				; If battery voltage is less than 109 * 255 mV ~= 28 V
			cmp.w	R8,RCellV			;  e.g. if battery contactors are off
			_IF		LO
				mov		#8888,R9			; Indicate an invalid test by a large distinctive value
			_ELSE
				mov		RCellV,R8			; If test value is less than battery_voltage/109 / 4
				rra2	R8					;  e.g. because of reed relay failure
				cmp		R8,Rtest
				_IF		LO
					mov		#7777,R9			; Indicate an invalid test by a large distinctive value
				_ELSE
					; Calculate the prospective touch current in tenths of a milliamp (accuracy +-25%)
					; assuming a human body model of 390 ohms (after skin breakdown due to high voltage)
					; (= 100k/256), test resistors of 100k and Vcell = Vbat / 109.
					; We use the approximation 10000/109 ~= 92 (0.3% error).
					; Itouch ~= (Vcell * Vmeas) / ((Vtest - 0.9961*Vmeas) * 92)
					mov		Rmeas,R8		; R8    = Vmeas
					mov		RCellV,R9		; R9    = VcellV
					call	#UMStar			; R10:R9 = R8 * R9 = Vcell * Vmeas
					sub		Rmeas,Rtest		; Rtest = Vtest - Vmeas
					_IF		NC				; If not carry = If borrow = If Vtest < Vmeas
						mov		#0,Rtest		; Rtest = 0
					_ENDIF					; Must not feed negative numbers to the following sqrt

					; Roughly compensate for opto nonlinearity by a crude square-root * 25 (+-20% error)
					; applied to the difference between test (2 relay) and measured (max 1 relay) values.
					mov		Rtest,R8		; R8    = Vtest - Vmeas
					rla2	Rtest			; Rtest = (Vtest - Vmeas) * 4
					mov		Rtest,R9		; R9    = (Vtest - Vmeas) * 4
					rla2	R9				; R9    = (Vtest - Vmeas) * 16
					add		R9,Rtest		; Rtest = (Vtest - Vmeas) * 20
					_DO
						cmp		#4,R8
						_WHILE	HS				; While R8 >= 4 (HS is the same as carry set)
							clrc					; Clear carry so the rrc below is an unsigned div by 2
							rrc		Rtest			; Do half as many shifts of Rtest
							rra2	R8				; as we can do to R8 before it goes below 4
					_AGAIN
						_ELSE
							cmp		#2,R8
							_IF		HS				; If one more shift of R8 is possible, to take it to 1
								mov		Rtest,R8		; Perform a "half-shift" of Rtest, by
								rra2	R8				; subtracting a quarter of it, which effectively
								sub		R8,Rtest		; multiplies it by 0.75, which is approx sqrt(0.5)
							_ENDIF
						_ENDIF
					rla4	Rtest			; Rtest = Corrected(Vtest - Vmeas) * 16

					; Finish the calculation of the prospective touch current
					rra4	Rmeas			; Rmeas = Vmeas / 16 = Vmeas/256 * 16
					add		Rmeas,Rtest		; Rtest = (Corr(Vtest - Vmeas) + Vmeas/256)) * 16
					mov		Rtest,R8		; R8    = (Corr(Vtest - Vmeas) + Vmeas/256)) * 16
					rra		Rtest			; Rtest = (Corr(Vtest - Vmeas) + Vmeas/256)) * 8
					add		Rtest,R8		; R8    = (Corr(Vtest - Vmeas) + Vmeas/256)) * 24
					rra3	Rtest			; Rtest = (Corr(Vtest - Vmeas) + Vmeas/256)) * 1
					sub		Rtest,R8 		; R8    = (Corr(Vtest - Vmeas) + Vmeas/256)) * 23
					call	#UMSlashMod		; R9    = R10:R9 / R8
											;    = (Vcell * Vmeas)/(Corr(Vtest - Vmeas) + Vmeas/256) * 23)
					add		#2,R9			; For rounding
					rra2	R9				; R9 = (Vcell * Vmeas)/(Corr(Vtest - Vmeas) + Vmeas/256) * 92)
					mov		#9999,R8		; Clamp to 999.9 mA
					cmp		R8,R9
					_IF		HS
						mov		R8,R9
					_ENDIF
				_ENDIF
			_ENDIF

#ifdef MONITOR		// If we're assembling Monitor, not TestICal or Monolith
			cmp		#170,R9				; Check if touch current > 20 mA (NCOP14), with a safety margin
			CtoAllBits	R8				; 	because our measurent is +-25%.
			movBits_B	R8,#bBadInsulation,&monFlags	; Piezo beeper will be turned on as required
#endif
			mov		#'J',Rthd 			; Character of command being responded to
			mov		R9,Rsec				; Result in tenths of a milliamp
			mov		#4,Rtos				; Print 4 digits
			call	#_prettyPrint		; Call pretty-print
		_ENDIF
		ret

#endif // INSULATION_MONITORING

		xCODE		'M'|'s' <<8,msDelay,_msDelay ; 'Ms' collides with 'Ma' 'Mc' 'Mk' 'Us' 'Ua' 'Uc' 'Uk'
		mov			Rtos,R8				; Argument to R8
		; Fall through

; Do not put code here
DelayMs:
; Delay by the number of milliseconds given in R8.
; R8 is treated as unsigned. There will be no travelling-backwards-in-time allowed here!
; Clears R8.
		push	R9
		_DO
			tst		R8						; (1)
		_WHILE	NZ						; (2) jz
			; 1 ms of MCLKs, 3 c inner loop, 11 c outer, 1 c rounding
			_FOR		#((DCOfreq/DCOckPerMck+500)/1000-11+1)/3,R9
			_NEXT_DEC	R9						; (3) dec R9, jnz
			ClearWatchdog					; (5) mov #x,&y
			dec			R8					; (1)
		_ENDW							; (2) jmp
		pop R9
		ret


;
; RelayPlus ( bool -- ) Turn on or off relay+ on IMU
;
		xCODE	'Y',relayP,_relayP
		cmp.b	#255,&ID
		_IF		EQ					; If we're a BMU (57.6 kHz on a CMU)
			allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#RelayP,&P2OUT ; Move only the #RelayP bit from Rtos to &P2OUT. Trashs Rtos
		_ENDIF
;		pop		Rtos				; Remove operand
		ret


;
; Bypass or RelayMinus ( bool -- ) Turn on or off bypass resistors (or relay- if this is an IMU)
;
		xCODE	'y',bypass,_bypass
_relayM	EQU		_bypass				; An alias for use in IMU code
		allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#Bypass,&BypPortOUT ; Move only Bypass bit from Rtos to &P2OUT. Trashes Rtos.
;		pop		Rtos				; Remove operand
		ret


_prettyPrint3:
		mov		#3,Rtos
		; Fall thru to _prettyPrint
;
; Pretty print  ( ch n m -- ) Print n as a comment packet with m digits
; and precede with ID and ch.
; (no command letter)
_prettyPrint:
		DELAY_IF_NEEDED				; Allow time for a typed CR to be echoed upstream if needed
		ClearWatchdog
		push.b	&interpFlags		; Save present number base
		push	Rsec				; Save n -- the result

		bit.b	#bModbusOutput,&interpFlags
		_IF		Z					; If not in modbus output mode, give a human-readable response
			mov		#EXIT,R8			; Initial slosh (EXIT command or comment character)
			call	#TxByteCk			; Stops rest of packet being interpreted
			push	Rtos				; Save m -- the digit count
			push	Rthd				; Save ch -- the command character(s)
			bic.b	#bHexOutput,&interpFlags ; Set to decimal output
			mov.b	&ID,Rsec
			call	#_emitNum3			; Emit the ID in decimal
			mov		#':',R8				; Colon separator
			call	#TxByteCk
			pop		R8					; Restore ch (command character(s)) to R8
			call	#TxByteCk			; Transmit ch, preserves R8
			swpb	R8					; Check if there's a second command character
			tst.b	R8
			_IF		NZ					; If the second command character is not null
				call	#TxByteCk			; Transmit the second command character
			_ENDIF
			mov		#' ',R8				; Transmit a space
			call	#TxByteCk
			pop		Rtos				; Restore m
			pop		Rsec				; Restore n
			popBits_B #bHexOutput,&interpFlags ; Restore number base to print n with
			call	#_emitNum
			call	#TxEndOfPacket
		_ELSE						; Else generate a modbus/ASCII response
			bis.b	#bHexOutput,&interpFlags ; Set to hexadecimal output
			; We can't send a slosh, so we rely on the fact that our Modbus responses are shorter
			; than the accepted Modbus commands, to allow following devices to ignore them.
			mov		#':',R8				; Colon is start of modbus packet
			call	#TxByteCk			; Send the colon
			cmp.b	#255,&ID
			_IF		EQ					; If our ID is 255 (i.e. BMU)
				mov		#BmuModbusID,Rsec	; Translate it to corresponding modbus ID
			_ELSE						; Else
				mov.b	&ID,Rsec			; Use our ID unchanged
			_ENDIF
;			mov		#3,Rtos				; Request 2 hex digits ($ is suppressed)
			call	#_emitNum3			; Emit the device id as two hex digits
;			mov.b	#3,Rsec				; Function code always 3
			call	#_emitNum3			; Emit the function code as two hex digits
			mov.b	#2,Rsec				; Indicate that 2 bytes of data follow
			call	#_emitNum			; Emit the data count as two hex digits
			ClearWatchdog				; None of this clears the watchdog
			mov		#5,Rtos				; Request 4 hex digits ($ is suppressed)
			mov		0(SP),Rsec			; Copy the result, i.e. the register value
			call	#_emitNum			; Emit register value as 4 hex digits
			pop		R8					; Pop result to R8, needed for LRC
			call	#TxEndOfModbusPacket ; Send LRC, CR and LF
			popBits_B #bHexOutput,&interpFlags ; Restore number base
		_ENDIF							; End Else in modbus mode

		ret

; Transmit the end of a Modbus packet: LRC, CR, LF
TxEndOfModbusPacket:
			; Transmit modbus/ASCII checksum in hex. R8 must have the 16-bit result just transmitted
			mov.w	R8, Rsec				; Copy the result
			swpb	Rsec					; Get upper byte to lower Byte
			add.b	R8, Rsec				; Add the lower byte of result
			add.b	#03+02,Rsec				; Add the constant terms of the checksum
			cmp.b	#255, &ID
			_IF		EQ						; If our ID is 255 (a BMU)
				add.b	#BmuModbusID, Rsec		; add the corresponding modbus ID
			_ELSE							; Else a cmu
				add.b	&ID, Rsec				; add our ID directly
			_ENDIF
			inv.b	Rsec					; The checksum is the negation of all this
			inc.b	Rsec
			call	#_emitNum3				; Transmit the checksum as two hex digits
			clr.b	&txCksum				; Restart regular checksums
			mov		#$0D,R8					; Transmit a carriage return.
			call	#TxByte
			mov		#$0A,R8					; Transmit a line feed.
			br		#TxByte					; Tail-call TxByte and return
;			ret

ErrorLed:
		tst		Rtos
		_IF		Z
			ErrLedOff						; Turn off the error LED
			bic.b	#Piezo,&P1SEL			; Short out the piezo
		_ELSE
			ErrLedOn						; Turn on the error LED
			bit.b	#bQuiet,&interpFlags
			_IF		Z						; If not in quiet mode
				bis.b	#Piezo,&P1SEL			; Make the piezo squeal
			_ENDIF
		_ENDIF
		ret

;
; Turn on or off the error LED and piezo beeper (bool -- )
;
		xCODE	'e',errorLedCmd,_errorLedCmd
		call	#ErrorLed
		mov		#50,R8					; Delay for 50 ms so this is visible/audible even when
		call	#DelayMs				; under automatic control, as in monolith.
;		pop		Rtos					; Remove operand
		ret

;
; Quiet (bool -- )
; Stop the piezo coming on with the error LED
		xCODE	'Q',quiet,_quiet
		tst		Rtos
		_IF		NZ
			bis.b	#bQuiet,&interpFlags
			bic.b	#Piezo,P1SEL			; Make it an ordinary output (short piezo to GND)
		_ELSE
			bic.b	#bQuiet,&interpFlags
			bit.b	#ErrLed,&P2OUT
			_IF		NZ						; If error LED is on
				bis.b	#Piezo,P1SEL			; Give piezo output ACLK function (make it squeal)
			_ENDIF
		_ENDIF
		ret

; Query the reset-log ( maxResetsToShow -- )
			xCODE	'R'|'l' <<8,queryResetLog,_queryResetLog ; 'Rl' collides with 'Rd' 'Rt' 'Jl' 'Jd' 'Jt'
			push	Rtos					; Save maxResetsToShow
			mov		#'R'|'l' <<8,Rthd		; Type is reset-log query
			mov		&resetCounter,Rsec		; Result
			call	#_prettyPrint3			; Pretty-print of 3 digits

			ClearWatchdog

			; Now prettyPrint the reasons for the resets, in hex
			pop		R8						; Restore maxResetsToShow
			push.b	&interpFlags				; Save present number base
			bis.b	#bHexOutput,&interpFlags	; Set to hexadecimal output

			cmp		&resetCounter,R8		; Take min of maxResetsToShow and resetCounter
			_IF		HS
				mov		&resetCounter,R8
			_ENDIF
			cmp		#16,R8					; Take min of that and 16
			_IF		HS
				mov		#16,R8
			_ENDIF

			mov		&resetCounter,R9
			and		#$0F,R9
			add		#resetBuffer,R9

			_DO
				tst		R8
			_WHILE	NZ
				push	R8
				mov		#'R'|'l' <<8,Rthd		; Type is reset-log query
				dec		R9
				cmp		#resetBuffer,R9
				_IF		LO
					mov		#resetBuffer+15,R9
				_ENDIF
				mov.b	@R9,Rsec				; Result
				push	R9
				call	#_prettyPrint3			; Call pretty-print for 3 digits
				pop		R9

				ClearWatchdog

				pop		R8
				dec		R8
			_ENDW

			popBits_B #bHexOutput,&interpFlags ; Restore number base
			ret

; Reset the reset-log ( -- )
			xCODE	'^',resetResetLog,_resetResetLog ; "^" so unlikely to type accidentally
			clr		&resetCounter
			mov		#resetBuffer,R8
			_DO
				clr.b	0(R8)
				inc		R8
				cmp		#resetBuffer+16,R8
			_UNTIL	EQ
			ret


; NO_ECHO_CMD ; A wrapper macro for defining commands that need to operate without echo
NO_ECHO_CMD	MACRO	cmd0,cmd
			cmp.b	#1,&ID
			_IF		EQ					; If my ID is 1
				mov		#$13,R8				; Transmit an XOFF (ctrl-S)
				call	#TxByteCk
				call	#cmd0				; Do the command with default parameters
				mov		#$11,R8				; Transmit an XON (ctrl-Q)
				call	#TxByteCk
			_ELSE						; Else (ID not 1)
				bit.b	#bDontEcho,&interpFlags
				_IF		NZ					; If the dont-echo flag is set
					call	#cmd				; Do the command
				_ENDIF
			_ENDIF
			ret
			ENDM


; NumCells  ( n -- ) Gives the number of cells
		xCODE	'N'|'c' <<8,NumCells,_NumCells	; 'Nc' collides with 'Na' 'Nk' 'Ns' 'Va' 'Vc' 'Vk' 'Vs'
			NO_ECHO_CMD	doNumCells0,doNumCells	; Use the no-echo wrapper macro
doNumCells0:
			mov		#0,Rtos
doNumCells:	; Emit another NumCells command with its parameter incremented by one.
			; When preceded by XOFF (ctrl-S) 0 and followed by <cr> XON (ctrl-Q) it gives the cell count.
			inc		Rtos				; Increment the parameter
			DPUSH	#3					; Use a 3 digit field width
			call	#_emitNum			; Transmit the number as text in the present number base

			mov		#'N',R8				; Transmit an "N"
			call	#TxByteCk
			mov		#'c',R8				; Transmit a "c"
			call	#TxByteCk

			br		#TxEndOfPacket		; Tail-call TxEndOfPacket and return
;			ret


; Fuel Gauge commands

; Monitor and TestICal:
; g		Reads the depth of discharge (DoD) in tenths of a percent, i.e. accumulated discharge as a
;		proportion of the battery capacity constant (may be > 100.0% if capacity underestimated).
; %		Clears the discharge accumulator to zero (use only at the end of a full charge).

; TestICal only:
; 'gr	Reads the battery capacity constant in tenths of an amp-hour.
; 'gc	Calibrates the fuel gauge by setting the battery capacity constant to the present accumulated
;		discharge converted to tenths of an amp-hour (use only when run flat).
; <n>'gw	Write the battery capacity to be the number <n>, in tenths of an amp-hour.


; Get depth of discharge ( -- )
		xCODE	'g',fuelDOD,_fuelDOD
#ifdef MONOLITH
		cmp.b	#255,&ID
#else
		cmp.b	#0,&ID
#endif
		_IF		EQ					; BMUs and IMUs only
			call	#DepthOfDischarge	; Get the depth of discharge as a number 0-1000 in R9
			mov		#'g',Rthd			; Type is fuel gauge (depth of discharge)
			mov		R9,Rsec				; Result in tenths of a percent
			mov		#4,Rtos				; Use 4 digits
			call	#_prettyPrint		; Call pretty-print
		_ENDIF
		ret

;
; Convert the discharge counter to a depth of discharge 0-1000 (representing 0-100.0% DoD)
; Result in R9; trashes R8, R10, clears R11
;
DepthOfDischarge:
		mov		&discharge,R8		; Low word of discharge accumulator
		mov		&discharge+2,R9		; High word of discharge accumulator
									; Starts with units of 1/72 mAh
		tst		R9
		_IF		L					; Clamp negative values to zero. Unsigned divide below.
			clr		R8
			clr		R9
		_ENDIF
		#if StatusFreq <= 8
			rla		R8
			rlc		R9
		#endif
		#if StatusFreq <= 4
			rla		R8
			rlc		R9
		#endif
		#if StatusFreq = 2
			rla		R8
			rlc		R9
		#endif
		rla		R8					; Shift the 32-bit quantity R9:R8 2 more bits left
		rlc		R9
		rla		R8
		rlc		R9
		; Units are now 1/72 x 1/32 mAh
		rla		R8					; Do rounding
		adc		R9
		; Upper half has units of 65536 x 1/72 x 1/32 mAh = 28.44 mAh
		; Will overflow at .02844 * 65536 = 1864 Ah
		; Want result in 1/10 % = 1/1000, after dividing by capacity in 1/20 Ah
		; So need to multiply by 28.44 / 1000 * 20 * 1000 = 568.9, use 569.
		mov		#569,R8
		call	#UMStar				; R10:R9 = R8 * R9

		ClearWatchdog

		mov		&infoCapacity,R8	; Battery capacity in tenths of an amp-hour
		rla		R8					; This works in conjuction with the 569 above, to scale correctly
		add		&infoCapacity,R9	; For rounding
		adc		R10
		br		#UMSlashMod			; R9 = R10:R9 / R8 and return
		;ret

; Opposite to the above
; Convert SoC (tenths of a %) to discharge value
; discharge = (1000 - SoC) * 7.2 * capacity (SoC in tenths of %, capacity in tenths of Ah, result in
;	1/72 mAh when StatusFreq = 2.
; Pass SoC in R9, result is returned in R10:R9
; Trashes R8-R10
SocToDischarge:
		mov		#1000, R8
		sub		R9, R8				; Convert SoC to DoD (tenths of a percent). R8 = 1000-R9
		mov		#1843,R9			; Use 1843/256 = 7.199
		mov		#128,R10			; Half the divisor, for rounding
		call	#UMStarPlus			; Multiply DoD by 1843 and add 128. R10:R9 = (R8 * R9) + R10
		rra8_l	R10,R9				; Divide by 256. Result will fit in R9.
		mov		&infoCapacity,R8	; Multiply by the battery capoacity in tenths of an amp-hour.
		call	#UMStar				; R10:R9 = R8 * R9
		#if StatusFreq >= 4
			rra		R9
			rrc		R10
		#endif
		#if StatusFreq >= 8
			rra		R9
			rrc		R10
		#endif
		#if StatusFreq = 16
			rra		R9
			rrc		R10
		#endif
		ret


		xCODE	'%',resetFuelGauge,_resetFuelGauge
		; Only IMUs care about this, but no harm if CMUs do it too
		clr		&discharge				; Clear low word of discharge accumulator
		clr		&discharge+2			; Clear high word of discharge accumulator
		ret


		xCODE	'F'|'f' <<8,forceFuelGauge,_forceFuelGauge	; 'Ff' collides with 'Fn' and 'Fv'
		mov		Rtos,R9
		call	#SocToDischarge
		mov		R9,&discharge
		mov		R10,&discharge+2
		ret


#if 0
; Reset via watchdog 				; Cause a reset with watchdog interrupt flag set, for testing only
			xCODE	'!',Watchdog,_Watchdog
			mov.w	#0,&WDTCTL		; Write an incorrect password to the watchdog control reg
			ret
#endif

; Convert a contactor number or letter to a bitmask for the output port.
; This is a helper for the Contactor on and off (Liven and Unliven) commands.
; GetContactorBitmask ( n -- m )
GetContactorBitmask:
			_CASE
			_OF_B	#1,Rtos				; Precharge
				mov.b	#PreCtor,Rtos
			_ENDOF
			_OF_B	#2,Rtos				; Battery pos
				mov.b	#BatPosCtor,Rtos
			_ENDOF
			_OF_B	#3,Rtos				; Battery neg
				mov.b	#BatNegCtor,Rtos
			_ENDOF
			_OF_B	#4,Rtos				; Left charge sources
				mov.b	#AcLfPvCtor,Rtos
			_ENDOF
			_OF_B	#5,Rtos				; Right charge source(s)
				mov.b	#RtPvCtor,Rtos
			_ENDOF
			_ENDCASE
			ret

;
; Liven contactor ( n --- )
; Turn on the output for contactor n
;
			xCODE	'L',liven,_liven
			call	#GetContactorBitmask
			bis.b	Rtos,&P3DIR		; Restore automatic control
			bis.b	Rtos,&P3OUT		; Turn it on (possibly only momentarily)
			ret

;
; Unliven contactor ( n --- )
; Turn off the output for contactor n
;
			xCODE	'U',unliven,_unliven
			call	#GetContactorBitmask
			bic.b	Rtos,&P3OUT		; Turn it off
			bic.b	Rtos,&P3DIR		; Prevent automatic control from turning it back on
			ret

;
; Display Input port value (n --- )
; n=0 for PreI input; n=1 for BatI input
; Pre and bat digital inputs
;
		xCODE		'I'|'n' <<8,inPut,_inPut ; 'In' collides with 'If', 'Iv', 'Qf', 'Qv', 'Qn'
		tst			Rtos				; 0 for pre input?
		_IF			Z
			bit.b	#PreI,&PreIPortIN		; Is PreI input high?
		_ELSE
			bit.b	#BatI,&BatIPortIN		; Is BatI input high?
		_ENDIF
		_IF		NZ
			mov		#1,Rsec					; If so, set Rsec to 1
		_ELSE
			mov		#0,Rsec					; Else set Rsec to 0
		_ENDIF
		mov		#'I'|'n'<<8,Rthd			; Type In put Port
		mov		#1,Rtos					; One digit: 0 or 1
		br		#_prettyPrint


;
; Echo the SVN revision numbers ( --- )
;
#include "../common/SVNrev.h"			// Definition for SVN_REV generated by pre-build GetSVNrevs.bat
#include "../common/ComRev.h"			// Definition for COM_REV also generated by the above
#include "../common/BSLrev.h"			// Definition for BSL_REV also generated by the above
		xCODE	'#',SVNrev,_SVNrev
		DELAY_IF_NEEDED				; Allow time for a typed CR to be echoed upstream if needed
		ClearWatchdog
		push.b	&interpFlags		; Save present number base
		bit.b	#bModbusOutput,&interpFlags
		_IF		Z					; If not in modbus output mode, give a human-readable response
			mov		#EXIT,R8			; Initial slosh (EXIT command or comment character)
			call	#TxByteCk			; Stops rest of packet being interpreted
			bic.b	#bHexOutput,&interpFlags ; Set to decimal output
			mov.b	&ID,Rsec
			call	#_emitNum3			; Emit the ID in decimal
			mov		#':',R8				; Colon separator
			call	#TxByteCk
			mov		#'#',R8				; Command being responded to
			call	#TxByteCk
			mov		#' ',R8				; Space
			call	#TxByteCk
			mov		#ProductCode,R8		; T for TestICal, R for monitoR, L for monoLith, W for Wmonolith
			call	#TxByteCk
			mov		#' ',R8				; Space
			call	#TxByteCk
			IF		COM_REV > SVN_REV
				mov		#COM_REV,Rsec		; The SVN revision number for the "common" folder
			ELSE
				mov		#SVN_REV,Rsec		; The SVN revision number for this project folder
			ENDIF
			call	#_emitNum4
			ClearWatchdog				; None of this clears the watchdog
			mov		#' ',R8				; Space
			call	#TxByteCk
			mov		#'B',R8				; BSL number
			call	#TxByteCk
			mov		#' ',R8				; Space
			call	#TxByteCk
			mov		&jBslRevision,R8	; Read the code at the BslRevision entry point in BSL
			cmp		#$4030,R8			; Compare with branch opcode
			_IF		EQ					; If the BslRevision entry point exists
				call	#jBslRevision		; Ask the BSL what its revision number is
				mov		R8,Rsec				; Copy to Rsec
			_ELSE						; Else not safe to call that entry point,
				mov		#$0000,Rsec			; hence BSL rev number is unknown
			_ENDIF
			push	Rsec				; Trashed by _emitNum
			call	#_emitNum4
			pop		Rsec
			cmp		#BSL_REV,Rsec
			_IF		NE					; If the BSL is not up to date
				mov		#'!',R8				; display a bang
				call	#TxByteCk			; after the BSL rev number
			_ENDIF
			mov		#' ',R8				; Space
			call	#TxByteCk
			mov		#'H',R8				; Expected hardware rev number
			call	#TxByteCk
			mov		#' ',R8				; Space
			call	#TxByteCk
			mov		#HW_REV,Rsec		; The expected hardware rev number for this code
			call	#_emitNum3
			call	#TxEndOfPacket
;		_ELSE
;			mov		#SVN_REV,Rsec		; The SVN revision number for this branch or trunk
;			call	#_prettyPrint		; Just return this one number
		_ENDIF							; End Else in modbus mode
		popBits_B #bHexOutput,&interpFlags ; Restore number base

		ret

; Modbus ( -- ) ; A colon begins a Modbus/ASCII packet. Packet ends with <cr><lf>.
; The Modbus/ASCII packet format is
; :<dev_id><func_code><reg_adr_hi><reg_adr_lo><reg_cnt_hi><reg_cnt_lo><LRC><cr><lf>
; where everything except the colon and <cr><lf> consists of a pair of ASCII hex digits.
; This is translated before being interpreted, to
; $<dev_id>s$<reg_addr_hi>$<reg_addr_lo>`\
; and a modbus-mode flag is set so PrettyPrint will format the response as a Modbus response.
;
		xCODE	':',Modbus,_Modbus	; Colon, begins a Modbus/ASCII packet
		; Modbus LRC check
		mov		#0,R9				; Clear LRC
		push	Rip					; Save position in buffer

		_DO
			cmp.b	#EXIT,0(Rip)		; Current ch an EXIT? (was CR)
		_WHILE	NE
			mov.b	@Rip+,R8			; Get a high hex digit
			cmp.b	#EXIT,0(Rip)		; Is next an EXIT? (was CR)
			jeq		abortColon			; Should not be! Abort if so
			sub.b	#'0',R8				; Convert to binary
			cmp.b	#9+1,R8				; Was it A-F?
			_IF		GE
				sub.b	#7,R8				; Adjust for A-F
			_ENDIF
			rla4	R8					; Shift left 4 bits
			add.b	R8,R9				; Add to sum
			mov.b	@Rip+,R8			; Get a low hex digit
			sub.b	#'0',R8				; Convert to binary
			cmp.b	#9+1,R8				; Was it A-F?
			_IF		GE
				sub.b	#7,R8				; Adjust for A-F
			_ENDIF
			add.b	R8,R9				; Add to sum
		_ENDW						; Ready to check is next ch a CR?

		tst.b	R9						; Sum should be zero
		jne		abortColon
		pop		Rip					; Restore input pointer

		bis.b	#bModbusOutput,&interpFlags	; Set the flag for PrettyPrint
		dec		Rip					; Back up to the start of the packet
		mov.b	#'$',0(Rip)			; Overwrite the colon with $ for the following <dev_id> hex digits
		mov.b	#'\\',3(Rip)		; Overwrite <func_code> hi digit with slosh (EXIT command)
		call	#_ENTER				; Interpret the hex device ID
		sub		#4,Rip				; Back up to the start of the packet again
		cmp.b	#BroadcastModbusID,Rtos
		_IF		EQ					; If it uses the broadcast ID
			mov.b	#' ',3(Rip)			; Overwrite <func_code> hi digit with space (no-op)
		_ELSE						; Else
			mov.b	#'s',3(Rip)			; Overwrite <func_code> hi digit with 's' for select
			cmp.b	#BmuModbusID,Rtos
			_IF		EQ					; If it's for the BMU
				mov.b	#'F',1(Rip)			; Replace with FF (255)
				mov.b	#'F',2(Rip)			;	(255 is not a valid Modbus device address)
			_ENDIF
		_ENDIF
		mov.b	#'$',4(Rip)			; Overwrite <func_code> lo digit with '$' for <reg_adr_hi> digits
		mov.b	8(Rip),9(Rip)		; Move the <reg_adr_lo> hex digits along by one byte
		mov.b	7(Rip),8(Rip)
		mov.b	#'$',7(Rip)			; Insert a $ before the <reg_adr_lo> hex digits
		mov.b	#EXECUTE,10(Rip)	; Put an EXECUTE command (tock) after them
		mov.b	#EXIT,11(Rip)		; And an EXIT command (slosh) after that
		ret

abortColon
		add		#4,SP				; Remove saved Rip, and return address in the interpreter
		ret							; So now we return to the caller of the interpreter, thus
									; ignoring the packet

; Capacity ( code -- ) ; Emit some constants, hex digit determines which constant
;
; Capacities of the battery system
; For the first Genevo Demand Charge Management system at Kingscliff TAFE
CAP_TOTV	EQU		16 * 32					; Nominal total volltage in decivolts. 16 cells at 3.2 V

		xCODE	'@',Capacity,_Capacity	; At sign, think "capATcity"
		_CASE
		_OF_B	#$B,Rtos			; $B: Battery total nominal voltage (0.1 V)
			mov		#CAP_TOTV,Rsec
		_ENDOF
		_OF_B	#$C,Rtos			; $C: Charge power capability (W)
			call	#EnergyCap
			; Need a multiply or divide here if the charge C rate isn't 1.0
			mov		R9,Rsec
		_ENDOF
		_OF_B	#$D,Rtos			; $D: Discharge power capability (W)
			call	#EnergyCap
			; Need a multiply or divide here if the discharge C rate isn't 1.0
			mov		R9,Rsec
		_ENDOF
		_OF_B	#$E,Rtos			; $E: Energy capacity (Wh)
			call	#EnergyCap
			mov		R9,Rsec
		_ENDOF
		_ENDCASE
		mov		#5,Rtos				; Use 5 digits
		mov		#'@',Rthd			; Response type is @, CapATcity Constant
		br		#_prettyPrint		; Tail call prettyPrint and return

EnergyCap:		; Return energy capacity in R9. Trashes R8, R10, R11
		mov		&infoCapacity,R8 ; Battery capacity in tenths of an amp-hour
		mov		#CAP_TOTV,R9	; Nominal total voltage in tenths of a volt
		mov		#50,R10			; For rounding
		call	#UMStarPlus		; Battery energy in hundredths of a watt-hour
		mov		#100,R8			; Convert to watt-hours
		call	#UMSlashMod
		ret

; Break
; Send a break out of the UART port, which is the CMU port on a BMU, and the only port on a CMU.
; This will reset a following CMU, but not a following BMU.
; When a CMU is reset it sends a break, so all following CMUs will be reset, but not the BMU.
; BMUs are reset by a break to their SCU port only.
; When a BMU is reset, it does not send a break to its CMUs (or anywhere else).
; So the most likely use of this command is to make a BMU reset all its CMUs.
		xCODE		'B'|'r' <<8,break,_break ; 'Br' collides with 'Bb' 'Bj' 'Bz' 'Zr' 'Zb' 'Zj' 'Zz'
		br	#jWriteBreak			; Tail call and return

