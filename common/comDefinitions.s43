;
; Definitions common to both the monitor and BSLwriter, which need no customisation in either
;

; EXIT ( -- ); Return from a bytecode sequence

		xCODE	'|',EXIT,_EXIT ; Vertical bar
		incd	SP			; Drop the return address within the interpreter
		ret					; Return to whoever called the interpreter (_ENTER)
		
; HEX ( flag -- ) ; Set the number base to hexadecimal

		xCODE	'h',HEX,_HEX
		mov.b	#16,&base
_Space	ret					; When _Space is called, be a no-op (for separating literals)

; DECIMAL ( flag -- ) ; Set the number base to decimal

		xCODE	'd',DECIMAL,_DECIMAL
		mov.b	#10,&base
		ret					; When _Space is called, be a no-op (for separating literals)

; CLIT ( -- c ) ; Character literal. Pronounced "see lit".
; Treat the next bytecode as a literal character.

		xCODE	'`',CLIT,_CLIT ; back-quote or tock
;		PUSH	Rtos
;		MOV.B	@Rip+,Rtos
		DPUSHb	@Rip+
		ret

; changeSign ( n -- -n )
		xCODE	'~',changeSign,_changeSign
		inv		Rtos
		inc		Rtos
		ret
		
; EMIT ( c -- )	; Emit the character on top of stack

		xCODE	'm',EMIT,_EMIT
		mov.b	Rtos,R8
		call	#TX_Byte
;		pop		Rtos
;		DROP
		ret

;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		; This is actually longer in bytecode
		xCODE	's',Select,_Select
		cmp.b	&ID,Rtos			; Correct ID?
;		pop		Rtos				; Pop the argument
;		DROP						; Pop the argument
		_IF		_NE					; If not correct ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ENDIF						; Endif
		ret

; eXclusive ( id -- )	; Sticky version of select. Type <ESC> to exit.
		xCODE	'x',exclusive,_exclusive
		cmp.b	&ID,Rtos			; Correct ID?
		_IF		_NE					; If not correct ID
			mov.b	#-1,&dontInterpret
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ENDIF						; Endif
		ret
		
;
; Turn on or off the error LED (bool -- )
;
		xCODE	'e',errorLed,_errorLed
		call	#waitTxCmpl			; If this is called interactively, wait for CR to completely echo
		allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#LED,&P1OUT ; Move only the #LED bit from Rtos to &P1OUT. Trashes Rtos.

;		pop		Rtos				; Remove operand
		ret

;
; Turn on or off bypass resistors (bool -- )
;
		xCODE	'y',bypass,_bypass
		allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#BYPASS,&P1OUT ; Move only the #BYPASS bit from Rtos to &P1OUT. Trashes Rtos.
;		pop		Rtos				; Remove operand
		ret

;
; emitNum  ( n count -- ) ; Emit an integer n as count digits in the current number base
; Trashes R8-R12
		
		xCODE	'n',emitNum,_emitNum
		mov		Rtos,R12			; Count to R12
		bit.b	#2,&base			; Distinguish decimal from hex (the only bases allowed)
		_IF		_NZ					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TX_ByteCk
				inv		Rsec				; Negate
				inc		Rsec
			_ENDIF						; Endif negative
		_ELSE						; Else hexadecimal
			mov.b	#'$',R8				; Emit dollar sign
			call	#TX_ByteCk
		_ENDIF						; End hexadecimal
		mov		Rsec,R9				; Dividend in R10:R9 will have n initially
		mov.b	&base,R8			; Divisor in R8 is number base
		dec		R12					; Count := Count-1
		_BEGIN
			clr		R10
			call	#UMSlashMod			; dividend/base -> R9, remainder to R10
			push	R10					; Push remainder
			dec		R12
		_UNTIL	_Z					; R9 keeps quotient as next dividend
		push	R9
		; Now we have n results on the stack; print these as hex/decimal
		_BEGIN
			pop		R8
			clrc						; Because dadd is always done with carry on MSP430
			dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
			dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			call	#TX_ByteCk
			dec		Rtos
		_UNTIL	_Z
		ret

;
; Pretty print n as a comment packet with m digits and follow with ch (ch n m--)
;
		xCODE	'p',prettyPrint,_prettyPrint
		push	Rthd				; Save ch
		push.b	&base				; Save current base
		
		DELAY_IF_NEEDED				; Allow time for CR to be echoed upstream if needed
		mov		#'|',R8				; Initial vertical bar
		call	#TX_ByteCk			; (interpreted as comment character)
		
		push	Rsec				; Save n
		push	Rtos				; Save m
		
		mov.b	#10,&base			; Set to decimal
		mov.b	&ID,Rsec
		mov		#3,Rtos
		call	#_emitNum			; Emit the ID in decimal
		
		mov		#':',R8				; Colon separator
		call	#TX_ByteCk
		
		pop		Rtos				; Restore m
		pop		Rsec				; Restore n
		pop.b	&base				; Restore radix to print n with
		call	#_emitNum
		
		pop		R8					; Restore ch
		call	#TX_ByteCk
		
		call	#TX_Cksum			; Transmit checksum if required, then clear checksum.
		
		mov		#'\r',R8			; Carriage return to R8
		call	#TX_Byte			; Emit
		
		call	#waitTxCmpl			; Wait for transmit complete
		bis.b	#LED,&P1OUT			; Set the LED here to mimic old behaviour
									; Identifies the BMU that sent a response
		ret
		

;
; Low level voltage measurement (channel -- measurement)
; Channel has channel number shifted left 12 bits (e.g. $7000 for cell voltage)
; Channel 7 is currently cell voltage; 10 is temperature sensor
; Measurement is in millivolts (0 to 4095 mV)
;
		xCODE		'a',llVolt,_llVolt
		mov			Rtos,R8
		call		#measAndCal			; Measure and use calibration
		mov			R10,Rtos
		ret
		
;
; cellVolt ( -- )
; Transmit the cell voltage measurement in millivolts (0 to 4095 mV)
;
		xCODE		'v',cellVolt,_cellVolt
		mov			#CellVChan<<12,Rtos	; ADC channel for cell voltage divider
		call		#_llVolt

		mov			#'V',Rthd			; Units are volts
		mov			Rtos,Rsec			; Result
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Cell temperature measurement ( -- )
; Measurement is in degrees C
;
		xCODE		't',cellTemp,_cellTemp
		mov			#TempChan<<12,Rtos	; ADC channel for temperature sensor
		call		#_llVolt
;
; Scale it back to degrees Celsius. Typically, T = (V-Voff)/.00355 where Voff = 0.986
; But the measurement M is 4096* V/1.5 = 2731*V.
; So T = (M/2731 - Koff1)*281.7 = M/9.694 - Koff2
; To divide by 9.694, multiply by 65536/9.694 = 6760, and keep the top half

		mov			Rtos,R9			; Don't pop; replace with number of digits to print
		mov			#6760,R8
		call		#UMStar
		; Most significant half is in R10
		; Temperature offset is now offset by 273
		sub			#273,R10
		mov.b		&TempCal,R8		; Temp offset calibration
		sxt			R8				; Sign extend
		sub			R8,R10
		mov			#'C',Rthd			; Don't use degree symbol (0xF8, Terminal font only);
										;	it's treated as a badness
		mov			R10,Rsec
		mov			#3,Rtos			; 3 digits
		jmp			_prettyPrint	; Tail-call pretty-print and return


;
; Link voltage measurement ( -- )
; Measurement is in mV
; Circuit has 2:1 voltage divider with Vref at the bottom.
; So meaure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
; Reading = 2048 + (Vin/2)(4096/1.5)
; R = 2048 + Vin * 1365.3 (Vin in volts)
; R = 2048 + Vin * 1.3653 (Vin in mV)
; Vin = (R - 2048)/1.3653 mV
; To divide by 1.3653, multiply by 65536/1.3653 = 48001 and keep the top half

		xCODE		'l',linkVolt,_linkVolt
		mov.b		&LinkCal,R8		; Link offset calibration
		cmp.b		#$80,R8			; $80 is a special value representing "calibration failure"
		_IF			_EQ				; If link calibration value is $80
			mov		#9999,R10			; then use special value
		_ELSE
			mov			#LinkVChan<<12,Rtos	; Shifted ADC channel for link voltage divider
			call		#_llVolt
			sub			#2048,Rtos
			mov.b		&LinkCal,R8		; Link offset calibration
			sxt			R8				; Sign extend
			sub			R8,Rtos
			_IF			_NN
				mov			Rtos,R8
				mov			#48001,R9
				call		#UMStar
				; Most significant half is in R10
			_ELSE
				inv			Rtos
				inc			Rtos			; Negate
				mov			Rtos,R8
				mov			#48001,R9
				call		#UMStar
				inv			R10				; Only interested in top half
				inc			R10				; Negate back
			_ENDIF
		_ENDIF
		mov			#'m',Rthd			; Units are millivolts
		mov			R10,Rsec			; Result
		mov			#4,Rtos				; Print 4 digits... would 3 be enough?
		jmp			_prettyPrint		; Tail-call pretty-print and return
