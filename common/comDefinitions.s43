;
; Command character definitions common to both the monitor and TestICal,
; which need no customisation in either
;

; EXIT ( -- ); Return from interpreting a sequence of command characters.
; Causes any characters following to be treated as comments only (Forth "\").
;
		xCODE	'\\',EXIT,_EXIT	; Slosh (backslash)
		incd	SP			; Drop the return address (which is within the interpreter)
		ret					; Return to whoever called the interpreter (_ENTER)

; HEX ( flag -- ) ; Set the number base to hexadecimal
;
		xCODE	'h',HEX,_HEX
		bis.b	#bHexOutput,&interpFlags
_Space	ret					; When _Space is called, be a no-op (for separating literal numbers)

; DECIMAL ( flag -- ) ; Set the number base to decimal
;
		xCODE	'd',DECIMAL,_DECIMAL
		bic.b	#bHexOutput,&interpFlags
		ret

; C_LIT ( -- c ) ; Character literal. Also acts like Forth's "tick".
; Treat the next character in a command sequence as a literal character.
; or equivalently, return the execution token of the next command.
		xCODE	'\'',C_LIT,_C_LIT	; Tick (single-quote)
		DPUSHb	@Rip+
		ret

; EXECUTE ( c -- ) ; Interpret the character on the top of the interpreter data stack as a command.
; The inverse of C_LIT or tick.
		xCODE	'`',EXECUTE,_EXECUTE	; Tock (back-quote)
		DPOPb	Rw			; Pop the top of the interpreter data stack into Rw
		incd	SP			; Drop the return address (which is within the interpreter)
		br		#_RUN		; Interpret the character in Rw

; changeSign ( n -- -n )
;
		xCODE	'-',changeSign,_changeSign	; Postfix unary minus
		inv		Rtos
		inc		Rtos
		ret

; dollarHex ( -- )
;
		xCODE	'$',dollarHex,_dollarHex	; $ for starting hex number input
		bis		#1<<14,SR					; Set the hex flag
		ret

;
; eXclusive ( id -- )	; Sticky version of select. Type <ESC> to exit.
;
		xCODE	'x',eXclusive,_eXclusive
		xCODE	'W',excleWsive,_excleWsive	; Synonym for when 'x' is rejected as 2400 baud in monolith
		bis.b	#bDontInterpret,&interpFlags
		; Fall through to _Select
;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		xCODE	's',Select,_Select
		cmp.b	&ID,Rtos			; Correct ID?
;		pop		Rtos				; Pop the argument
;		DROP						; Pop the argument
		_IF		_NE					; If not correct ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ELSE						; Else
			bic.b	#bDontInterpret,&interpFlags ; Needed to handle _eXclusive fall-through
		_ENDIF						; Endif
		ret

;
; eXclude ( id -- )	; Sticky version of deSelect. Type <ESC> to exit.
;
		xCODE	'X',eXclude,_eXclude
		cmp.b	&ID,Rtos			; specified ID?
		_IF		_EQ					; If specified ID
			bis.b	#bDontInterpret,&interpFlags	; Stop interpreting
		_ENDIF
		ret
;
; deSelect ( id -- ) ; Ignore to end of line if ID on TOS is our ID
;
		xCODE	'S',deSelect,_deSelect
		cmp.b	&ID,Rtos			; Specified ID?
		_IF		_EQ					; If specified ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ENDIF						; Endif
		ret

;
; emitNum  ( n count -- ) ; Emit an integer n as count digits in the current number base
; Trashes R8-R12

		xCODE	'n',emitNum,_emitNum
#if 1	// This version takes up 7 more words of flash but doesn't use any stack (apart from its return address)
		mov		#4,R12				; Loop 5 times for decimal conversion
		bit.b	#bHexOutput,&interpFlags ; Hexadecimal or decimal?
		_IF		_Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TxByteCk
				inv		Rsec				; Negate to get absolute value
				inc		Rsec
			_ENDIF						; Endif negative
			mov		Rsec,R10			; Get n as 16.16 bit fixpoint Dividend in R10:R9
			mov		#40000,R8			; Divisor in R8 is 4 * 10^4
			mov		R8,R9				; Instead of clearing R9 and adding one to the quotient later
			call	#UMSlashMod			; R10:R9 / R8 -> R9, remainder to R10 (ignored), clears R11
			clr		R10					; Ignore remainder. Treat R10:R9 as 16.16 bit fixpoint again
			rla		R9					; Shift R10:R9 2 bits left
			rlc		R10					; to get most sig decimal digit in R10 (max value 3)
			rla		R9
			rlc		R10
			mov		#10,Rsec			; Rsec := 10 (radix)
		_ELSE						; Else hexadecimal
			dec		R12					; Loop only 4 times for hexadecimal conversion
			dec		Rtos				; For hex, send one less digit than requested
			cmp		#2,Rtos				; but enforce a minimum of 2 digits
			_IF		_LO
				mov		#2,Rtos
			_ENDIF
			bit.b	#bModbusOutput,&interpFlags
			_IF		_Z					; If not in modbus output mode
				mov.b	#'$',R8				; Emit dollar sign for hex
				call	#TxByteCk
			_ENDIF
			mov		Rsec,R9				; R9 := n
			mov		#16,Rsec			; Rsec := 16 (radix)
			_BEGIN
				mov		Rsec,R8				; Radix (10 or 16) into R8
				call	#UMStar				; R9 * R8 -> R10:R9, clears R11
		_END_PRIOR_IF				; End hexadecimal
				cmp		Rtos,R12			; Only convert and send the digit if it was asked for
				_IF		_LO					; Equivalent to _IF _NC. So clrc isn't necessary below
					mov.b	R10,R8				; ASCII conversion follows
			;		clrc						; Because dadd is always done with carry on MSP430
					dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
					dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			;		and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
					mov		R9,Rthd				; Save R9
					call	#TxByteCk			; Transmit byte (accumulating checksum). Trashes R9
					mov		Rthd,R9				; Restore R9
				_ENDIF
				dec		R12					; Decrement loop counter
			_UNTIL	_L					; Jump back to matching _BEGIN if loop counter not negative

#else	// This version of emitNum takes less flash but uses up to 8 bytes of stack to reverse digits
		bit.b	#bHexOutput,&interpFlags ; Hexadecimal or decimal?
		_IF		_Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TxByteCk
				inv		Rsec				; Negate
				inc		Rsec
			_ENDIF						; Endif negative
			mov.b	#10,R8			; Divisor in R8 is number base
		_ELSE						; Else hexadecimal
			dec		Rtos				; Use one less digit
			mov.b	#'$',R8				; Emit dollar sign
			call	#TxByteCk
			mov.b	#16,R8			; Divisor in R8 is number base
		_ENDIF						; End hexadecimal
		dec		Rtos				; Count := Count-1
		_IF		_L					; Enforce a minimum of 2 digits
			mov		#1,Rtos
		_ENDIF
		mov		Rtos,R12			; Count to R12
		mov		Rsec,R9				; Dividend in R10:R9 will have n initially
		dec		R12					; Count := Count-1
		_BEGIN
			clr		R10
			call	#UMSlashMod			; dividend/base -> R9, remainder to R10
			push	R10					; Push remainder
			dec		R12
		_UNTIL	_L					; R9 keeps quotient as next dividend
		mov		R9,R8
		; Now we have n-1 results on the stack and the last one in R8; print these as hex/decimal
		_BEGIN
			clrc						; Because dadd is always done with carry on MSP430
			dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
			dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
			call	#TxByteCk
			dec		Rtos
		_WHILE	_NN
			pop		R8
		_REPEAT
#endif
		ret


;
; cellVolt ( -- )
; Transmit the cell (strap+) voltage measurement in millivolts (0 to 4095 mV)
;
		xCODE		'v',cellVolt,_cellVolt
		call		#cellV				; Return cell voltage in millivolts in R10
		mov			#'v',Rthd			; Type is cell Voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; boltVolt ( -- )
; Transmit the cell (bolt+) voltage measurement in millivolts (0 to 4095 mV)
;
		xCODE		'V',boltVolt,_boltVolt
		call		#boltV				; Return cell voltage in millivolts in R10
		mov			#'V',Rthd			; Type is cell Voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Cell temperature measurement ( -- )
; Transmit cell temperature in degrees C
;
		xCODE		't',cellTemp,_cellTemp
		call		#temp				; Return temperature in degrees Celsius in R10
		mov			#'t',Rthd			; Type is temperature
										; Don't use degree symbol ($F8 Terminal font). Looks like status
		mov			R10,Rsec			; Result in degrees Celsius
		mov			#2,Rtos				; Print 2 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; External thermistor temperature measurement ( -- )
; Transmit cell temperature in degrees C
;
		xCODE		'H',extTemp,_extTemp
		call		#extT				; Return temperature in degrees Celsius in R10
		mov			#'H',Rthd			; Type is temperature
										; Don't use degree symbol ($F8 Terminal font). Looks like status
		mov			R10,Rsec			; Result in degrees Celsius
		mov			#2,Rtos				; Print 2 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Link voltage measurement ( -- )
; Transmit link voltage in millivolts, -1500 to 1500 or 9999 for "invalid".
		xCODE		'l',linkVolt,_linkVolt
		call		#linkV				; Return link voltage in millivolts in R10
		mov			#'l',Rthd			; Type is Link voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits... would 3 be enough?
		jmp			_prettyPrint		; Tail-call pretty-print and return


#if INSULATION_MONITORING
;
; TouchValue ( -- )
; Transmit the raw touch value (0 to 4095 mV).
; This is an uncalibrated measurement as it is the touch current times the opto's CTR (0.63 to 1.25)
; times R17 (120R), scaled to 4096 counts for 1500 mV (ADC reference).
;
		xCODE		'T',touchValue,_touchValue
		cmp.b	#0,&ID					; If we're an IMU
		_IF		_EQ
			call		#touchV				; Return touch value (0 to 4095) in R10
			mov			#'T',Rthd			; Type is touch value
			mov			R10,Rsec			; Result
			mov			#4,Rtos				; Print 4 digits
			call		#_prettyPrint		; Call pretty-print
		_ENDIF
		ret

;
; Insulation test ( -- )
; Transmit the prospective touch current in tenths of a milliamp (0 to 999.9 mA)
; This is a calibrated result based on 3 touch measurements and a battery voltage measurement
; and the fact that the test resistors are 100k and the battery voltage is divided by 109.
; Expect approximately the following readings with the following leakage test resistors and 360 V battery
; 470k 8, 100k 36, 6.8k 501, 2.2k 1390, 0k 9216.
		xCODE		'I',insulationTest,_insulationTest
		; Register definitions
#define Rcellv R12				// Battery voltage divided by 109 (in mV). Average cell voltage.
#define Rmeas R14				// Max of touch measurements when any one relay is on.
#define Rtest R15				// Touch self-test value when both relays are on.
		cmp.b	#0,&ID				; If we're an IMU
		_IF		_EQ
			call	#cellV				; Return battery_voltage/109 in millivolts in R10
			mov		R10,Rcellv

			; Positive relay only
			bis.b	#RelayP,&P2OUT		; Turn on positive relay
			mov		#130,R8				; 130 milliseconds
			call	#DelayMs			; Wait for relay bounce and voltage settling
			call	#touchV				; Return touch value in R10
			mov		R10,Rmeas

			; Both relays
			bis.b	#RelayM,&P2OUT		; Turn on negative relay
			mov		#130,R8				; 130 milliseconds
			call	#DelayMs			; Wait for relay bounce and voltage settling
			call	#touchV				; Return touch value in R10
			; This allows calibration, as it will represent the battery voltage divided by 100k
			; irrespective of any leakage resistances, assuming only that the two optos
			; have similar CTRs.
			mov		R10,Rtest

			; Negative relay only
			bic.b	#RelayP,&P2OUT		; Turn off positive relay
			mov		#130,R8				; 130 milliseconds
			call	#DelayMs			; Wait for relay bounce and voltage settling
			call	#touchV				; Return touch value in R10

			cmp		R10,Rmeas			; Keep the maximum of the two single-relay measurements
			_IF		_LO
				mov		R10,Rmeas
			_ENDIF

			; Both relays off
			bic.b	#RelayM,&P2OUT		; Turn off negative relay

			mov.b	#$FF,R8				; If battery voltage is less than 109 * 255 mV ~= 28 V
			cmp.w	R8,Rcellv			;  e.g. if battery contactors are off
			_IF		_LO
				mov		#8888,R9			; Indicate an invalid test by a large distinctive value
			_ELSE
				mov		Rcellv,R8			; If test value is less than battery_voltage/109 / 4
				rra2	R8					;  e.g. because of reed relay failure
				cmp		R8,Rtest
				_IF		_LO
					mov		#7777,R9			; Indicate an invalid test by a large distinctive value
				_ELSE
					; Calculate the prospective touch current in tenths of a milliamp (accuracy +-25%)
					; assuming a human body model of 390 ohms (after skin breakdown due to high voltage)
					; (= 100k/256), test resistors of 100k and Vcell = Vbat / 109.
					; We use the approximation 10000/109 ~= 92 (0.3% error).
					; Itouch ~= (Vcell * Vmeas) / ((Vtest - 0.9961*Vmeas) * 92)
					mov		Rmeas,R8		; R8    = Vmeas
					mov		Rcellv,R9		; R9    = Vcellv
					call	#UMStar			; R10:R9 = R8 * R9 = Vcell * Vmeas
					sub		Rmeas,Rtest		; Rtest = Vtest - Vmeas
					_IF		_NC				; If not carry = If borrow = If Vtest < Vmeas
						mov		#0,Rtest		; Rtest = 0
					_ENDIF					; Must not feed negative numbers to the following sqrt

					; Roughly compensate for opto nonlinearity by a crude square-root * 25 (+-20% error)
					; applied to the difference between test (2 relay) and measured (max 1 relay) values.
					mov		Rtest,R8		; R8    = Vtest - Vmeas
					rla2	Rtest			; Rtest = (Vtest - Vmeas) * 4
					mov		Rtest,R9		; R9    = (Vtest - Vmeas) * 4
					rla2	R9				; R9    = (Vtest - Vmeas) * 16
					add		R9,Rtest		; Rtest = (Vtest - Vmeas) * 20
					_BEGIN
						cmp		#4,R8
						_WHILE	_HS				; While R8 >= 4 (_HS is the same as carry set)
							clrc					; Clear carry so the rrc below is an unsigned div by 2
							rrc		Rtest			; Do half as many shifts of Rtest
							rra2	R8				; as we can do to R8 before it goes below 4
					_AGAIN
						_ELSE
							cmp		#2,R8
							_IF		_HS				; If one more shift of R8 is possible, to take it to 1
								mov		Rtest,R8		; Perform a "half-shift" of Rtest, by
								rra2	R8				; subtracting a quarter of it, which effectively
								sub		R8,Rtest		; multiplies it by 0.75, which is approx sqrt(0.5)
							_ENDIF
						_ENDIF
					rla4	Rtest			; Rtest = Corrected(Vtest - Vmeas) * 16

					; Finish the calculation of the prospective touch current
					rra4	Rmeas			; Rmeas = Vmeas / 16 = Vmeas/256 * 16
					add		Rmeas,Rtest		; Rtest = (Corr(Vtest - Vmeas) + Vmeas/256)) * 16
					mov		Rtest,R8		; R8    = (Corr(Vtest - Vmeas) + Vmeas/256)) * 16
					rra		Rtest			; Rtest = (Corr(Vtest - Vmeas) + Vmeas/256)) * 8
					add		Rtest,R8		; R8    = (Corr(Vtest - Vmeas) + Vmeas/256)) * 24
					rra3	Rtest			; Rtest = (Corr(Vtest - Vmeas) + Vmeas/256)) * 1
					sub		Rtest,R8 		; R8    = (Corr(Vtest - Vmeas) + Vmeas/256)) * 23
					call	#UMSlashMod		; R9    = R10:R9 / R8
											;    = (Vcell * Vmeas)/(Corr(Vtest - Vmeas) + Vmeas/256) * 23)
					add		#2,R9			; For rounding
					rra2	R9				; R9 = (Vcell * Vmeas)/(Corr(Vtest - Vmeas) + Vmeas/256) * 92)
					mov		#9999,R8		; Clamp to 999.9 mA
					cmp		R8,R9
					_IF		_HS
						mov		R8,R9
					_ENDIF
				_ENDIF
			_ENDIF

#ifdef Monitor		// If we're assembling Monitor, not TestICal or Monolith
			cmp		#170,R9				; Check if touch current > 20 mA (NCOP14), with a safety margin
			CtoAllBits	R8				; 	because our measurent is +-25%.
			movBits_B	R8,#bBadInsulation,&monFlags	; Piezo beeper will be turned on as required
#endif
			mov		#'I',Rthd			; Type is touch current
			mov		R9,Rsec				; Result in tenths of a milliamp
			mov		#4,Rtos				; Print 4 digits
			call	#_prettyPrint		; Call pretty-print
		_ENDIF
		ret

#endif // INSULATION_MONITORING


DelayMs:
; Delay by the number of milliseconds given in R8.
; R8 is treated as unsigned. There will be no travelling-backwards-in-time allowed here!
; Clears R8.
		push	R9
		_BEGIN
			tst		R8						; (1)
		_WHILE	_NZ						; (2) jz
			_DO		#(4000-11+1)/3,R9		; 4000 c = 1 ms, 3 c inner loop, 11 c outer, 1 c rounding
			_LOOP	R9						; (3) dec R9, jnz
			ClearWatchdog					; (5) mov #x,&y
			dec			R8					; (1)
		_REPEAT							; (2) jmp
		pop R9
		ret


;
; RelayPlus ( bool -- ) Turn on or off relay+ on IMU
;
		xCODE	'Y',relayP,_relayP
		tst.b	&ID
		_IF		_Z					; If we're an IMU (would operate the error LED on a CMU)
			allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
			movBits_B	Rtos,#RelayP,&P2OUT ; Move only the #RelayP bit from Rtos to &P2OUT. Trashs Rtos
		_ENDIF
;		pop		Rtos				; Remove operand
		ret


#if PROG_START < $F800	// Commented out if need to save space
;
; Bypass or RelayMinus ( bool -- ) Turn on or off bypass resistors (or relay- if this is an IMU)
;
		xCODE	'y',bypass,_bypass
_relayM	EQU		_bypass				; An alias for use in IMU code
		allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#Bypass,&P2OUT ; Move only the #Bypass bit from Rtos to &P2OUT. Trashes Rtos.
;		pop		Rtos				; Remove operand
		ret
#endif	// PROG_START < $F800


_prettyPrint3:
		mov		#3,Rtos
		; Fall thru to _prettyPrint
;
; Pretty print  ( ch n m -- ) Print n as a comment packet with m digits
; and precede with ID and ch.
; (no command letter)
_prettyPrint:
		ClearWatchdog
		push.b	&interpFlags			; Save present number base

		DELAY_IF_NEEDED				; Allow time for CR to be echoed upstream if needed
		mov		#EXIT,R8			; Initial slosh (EXIT command or comment character)
;		call	#TxByteCk			; Stops rest of packet being interpreted

		push	Rsec				; Save n -- the result

		bit.b	#bModbusOutput,&interpFlags
		_IF		_Z					; If not in modbus output mode, give a human-readable response
			push	Rtos				; Save m -- the digit count
			push	Rthd				; Save ch -- the command character
			bic.b	#bHexOutput,&interpFlags ; Set to decimal output
			mov.b	&ID,Rsec
			mov		#3,Rtos
			call	#_emitNum			; Emit the ID in decimal
			mov		#':',R8				; Colon separator
			call	#TxByteCk
			pop		R8					; Restore ch (type of measurement)
			call	#TxByteCk			; Transmit ch
			mov		#' ',R8				; Transmit a space
			call	#TxByteCk
			pop		Rtos				; Restore m
			pop		Rsec				; Restore n
			pop.b	&interpFlags		; Restore number base to print n with
			call	#_emitNum
			call	#TxEndOfPacket
		_ELSE						; Else generate a modbus/ASCII response
			bis.b	#bHexOutput,&interpFlags ; Set to hexadecimal output
			mov		#':',R8				; Colon is start of modbus packet
			call	#TxByteCk			; Send the colon
			cmp.b	#255,&ID			; Is our ID 255?
			_IF		_EQ
				mov		#247,Rsec			; Yes, translate it to 247
			_ELSE
				mov.b	&ID,Rsec			; Use our ID unchanged
			_ENDIF
			mov		#3,Rtos				; Request 2 hex digits ($ is suppressed)
			call	#_emitNum			; Emit the device id as two hex digits
			mov.b	#3,Rsec				; Function code always 3
			call	#_emitNum			; Emit the function code as two hex digits
			mov.b	#2,Rsec				; Indicate that 2 bytes of data follow
			call	#_emitNum			; Emit the data count as two hex digits
			ClearWatchdog				; None of this clears the watchdog
			mov		#5,Rtos				; Request 4 hex digits ($ is suppressed)
			mov		0(SP),Rsec			; Copy the result, i.e. the register value
			call	#_emitNum			; Emit register value as 4 hex digits
			pop		R8					; Pop result to R8, needed for LRC
			call	#TxEndOfModbusPacket ; Send LRC, CR and LF
			pop.b	&interpFlags		; Restore number base
			bic.b	#bModbusOutput,&interpFlags	; Clear the modbus output mode flag
		_ENDIF							; End Else in modbus mode

		ActLedOn					; Set the (inverted) activity LED here to mimic old behaviour
		ret

; Transmit the end of a Modbus packet: LCR, CR, LF
TxEndOfModbusPacket:
			; Transmit modbus/ASCII checksum in hex. R8 must have the 16-bit result just transmitted
			mov.w	R8, Rsec				; Copy the result
			swpb	Rsec					; Get upper byte to lower Byte
			add.b	R8, Rsec				; Add the lower byte of result
			add.b	#03+02,Rsec				; Add the constant terms of the checksum
			cmp.b	#255, &ID				; Is our ID 255?
			_IF		_EQ						; If so,
				add.b	#247, Rsec				; add 247, our Modbus ID
			_ELSE
				add.b	&ID, Rsec				; else a CMU, use our ID directly
			_ENDIF
			inv.b	Rsec						; The checksum is the negation of all this
			inc.b	Rsec
			mov		#3, Rtos
			call	#_emitNum				; Transmit the checksum as two hex digits			
			clr.b	&txCksum				; Restart regular checksums
			mov		#$0D,R8					; Transmit a carriage return.
			call	#TxByte
			mov		#$0A,R8					; Transmit a carriage return.
			br		#TxByte					; Tail-call TxByte and return
;			ret


;
; Turn on or off the error LED and piezo beeper (bool -- )
;
		xCODE	'e',errorLed,_errorLed
		tst		Rtos
		_IF		_Z
			ErrLedOff						; Turn off the error LED
			bic.b	#Piezo,&PiezoPortSEL	; Short out the piezo
		_ELSE
			ErrLedOn						; Turn on the error LED
			bis.b	#Piezo,&PiezoPortSEL	; Make the piezo squeal
		_ENDIF

;		pop		Rtos				; Remove operand
		ret

;
; Quiet (bool -- )
; Stop the piezo coming on with the error LED
		xCODE	'Q',quiet,_quiet
#if G2553
		allBitsIfZ	Rtos,Rtos		; IF Rtos is zero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#OUTMOD_4|CCIE,&PizCCTLp ; Move only these bits from Rtos to &BCSCTL3.
									; If Rtos is zero, the zeroes will select output mode 0 (direct
									; control) and output value zero, so no DC on Piezzo. Trashes Rtos
#else	// G2452
		allBitsIfZ	Rtos,Rtos		; IF Rtos is zero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#LFXT1S_2,&BCSCTL3 ; Move only #LFXT1S_2 bit from Rtos to &BCSCTL3. Trashes Rtos
		; Select either VLOCLK (~12 kHz) or LFXT1 (unused crystal oscillator) as source for ACLK divider
;		pop		Rtos				; Remove operand
#endif
		ret

; Query the reset-log ( maxResetsToShow -- )
			xCODE	'R',queryResetLog,_queryResetLog
			push	Rtos					; Save maxResetsToShow
			mov.b	#'R',Rthd				; Type is reset-log query
			mov		&resetCounter,Rsec		; Result
			call	#_prettyPrint3			; Pretty-print of 3 digits

			ClearWatchdog

			; Now prettyPrint the reasons for the resets, in hex
			pop		R8						; Restore maxResetsToShow
			push.b	&interpFlags				; Save present number base
			bis.b	#bHexOutput,&interpFlags	; Set to hexadecimal output

			cmp		&resetCounter,R8		; Take min of maxResetsToShow and resetCounter
			_IF		_HS
				mov		&resetCounter,R8
			_ENDIF
			cmp		#16,R8					; Take min of that and 16
			_IF		_HS
				mov		#16,R8
			_ENDIF

			mov		&resetCounter,R9
			and		#$0F,R9
			add		#resetBuffer,R9

			_BEGIN
				tst		R8
			_WHILE	_NZ
				push	R8
				mov.b	#'R',Rthd				; Type is reset-log query
				dec		R9
				cmp		#resetBuffer,R9
				_IF		_LO
					mov		#resetBuffer+15,R9
				_ENDIF
				mov.b	@R9,Rsec				; Result
				push	R9
				call	#_prettyPrint3			; Call pretty-print for 3 digits
				pop		R9

				ClearWatchdog

				pop		R8
				dec		R8
			_REPEAT

			pop.b	&interpFlags				; Restore number base
			ret

; Reset the reset-log ( -- )
			xCODE	'^',resetResetLog,_resetResetLog ; "^" so unlikely to type accidentally
			clr		&resetCounter
			mov		#resetBuffer,R8
			_BEGIN
				clr.b	0(R8)
				inc		R8
				cmp		#resetBuffer+16,R8
			_UNTIL	_EQ
			ret


; NO_ECHO_CMD ; A wrapper macro for defining commands that need to operate without echo
NO_ECHO_CMD	MACRO	cmd0,cmd
			cmp.b	#1,&ID
			_IF		_EQ					; If my ID is 1
				mov		#$13,R8				; Transmit an XOFF (ctrl-S)
				call	#TxByteCk
				call	#cmd0				; Do the command with default parameters
				mov		#$11,R8				; Transmit an XON (ctrl-Q)
				call	#TxByteCk
			_ELSE						; Else (ID not 1)
				bit.b	#bDontEcho,&interpFlags
				_IF		_NZ					; If the dont-echo flag is set
					call	#cmd				; Do the command
				_ENDIF
			_ENDIF
			ret
			ENDM


#if (PROG_START < $F000)		; Comment out if required to save space
; NumCells  ( n -- ) Gives the number of cells
		xCODE	'N',NumCells,_NumCells
			NO_ECHO_CMD	doNumCells0,doNumCells		; Use the no-echo wrapper macro
doNumCells0:
			mov		#0,Rtos
doNumCells:	; Emit another NumCells command with its parameter incremented by one.
			; When preceded by XOFF (ctrl-S) 0 and followed by <cr> XON (ctrl-Q) it gives the cell count.
			inc		Rtos				; Increment the parameter
			DPUSH	#3					; Use a 3 digit field width
			call	#_emitNum			; Transmit the number as text in the present number base

			mov		#'N',R8				; Transmit an "N"
			call	#TxByteCk

			br		#TxEndOfPacket		; Tail-call TxEndOfPacket and return
;			ret
#endif


; Fuel Gauge commands

; Monitor and TestICal:
; g		Reads the depth of discharge (DoD) in tenths of a percent, i.e. accumulated discharge as a
;		proportion of the battery capacity constant (may be > 100.0% if capacity underestimated).
; %		Clears the discharge accumulator to zero (use only at the end of a full charge).

; TestICal only:
; 'gr	Reads the battery capacity constant in tenths of an amp-hour.
; 'gc	Calibrates the fuel gauge by setting the battery capacity constant to the present accumulated
;		discharge converted to tenths of an amp-hour (use only when run flat).
; <n>'gw	Write the battery capacity to be the number <n>, in tenths of an amp-hour.

		xCODE	'g',fuelGauge,_fuelGauge
#ifdef MONOLITH
		cmp.b	#255,&ID
#else
		cmp.b	#0,&ID
#endif
		_IF		_EQ					; IMUs only
			call	#DepthOfDischarge	; Get the depth of discharge as a number 0-1000 in R9
			mov		#'g',Rthd			; Type is fuel gauge (depth of discharge)
			mov		R9,Rsec				; Result in tenths of a percent
			mov		#4,Rtos				; Use 4 digits
			call	#_prettyPrint		; Call pretty-print
		_ENDIF
		ret

;
; Convert the discharge counter to a depth of discharge 0-1000 (representing 0-100.0% DoD)
; Result in R9; trashes R8, R10, clears R11
;
DepthOfDischarge:
		mov		&discharge,R8		; Low word of discharge accumulator
		mov		&discharge+2,R9		; High word of discharge accumulator
		tst		R9
		_IF		_L					; Clamp negative values to zero. Unsigned divide below.
			clr		R8
			clr		R9
		_ENDIF
		#if StatusFreq <= 8
			rla		R8
			rlc		R9
		#endif
		#if StatusFreq <= 4
			rla		R8
			rlc		R9
		#endif
		#if StatusFreq = 2
			rla		R8
			rlc		R9
		#endif
		rla		R8					; Shift the 32-bit quantity R9:R8 3 more bits left
		rlc		R9
		rla		R8
		rlc		R9
		rla		R8
		rlc		R9					; Then use only the high 16-bits in the calculation
		rla		R8					; Do rounding
		adc		R9					; Resulting units are 8192/270000 Ah ~= 0.03034 Ah
		mov		#607,R8				; Mult to give tenths of a percent when div by 1/20ths of an Ah
		call	#UMStar				; R10:R9 = R8 * R9 and return

		ClearWatchdog

		mov		#BatCapacity,R8		; Battery capacity in tenths of an amp-hour
									; The above constant may be stored in info-flash in future
		rla		R8					; This works in conjuction with the 607 above, to scale correctly
		add		#BatCapacity,R9		; For rounding
		adc		R10
		br		#UMSlashMod			; R9 = R10:R9 / R8 and return
		;ret


		xCODE	'%',resetFuelGauge,_resetFuelGauge
		; Only IMUs care about this, but no harm if CMUs do it too
		clr		&discharge				; Clear low word of discharge accumulator
		clr		&discharge+2			; Clear high word of discharge accumulator
		ret

#if 0
		; Temporary command for testing fuel gauge
		; setFuelGauge ( hiword loword -- )
		; $A4 $CB80 a -- should correspond to 100.0% (of 40 Ah)
		; $52 $65C0 a -- should correspond to 50.0% (of 40 Ah)
		xCODE	'a',setFuelGauge,_setFuelGauge
		; Only IMUs care about this, but no harm if CMUs do it too
		mov		Rtos,&discharge				; Set low word of discharge accumulator
		mov		Rsec,&discharge+2			; Set high word of discharge accumulator
		call	#UpdateSoC					; For monolith only: update variable for SoC meter
		ret
#endif

#if 0
; Reset via watchdog 				; Cause a reset with watchdog interrupt flag set, for testing only
			xCODE	'!',Watchdog,_Watchdog
			mov.w	#0,&WDTCTL		; Write an incorrect password to the watchdog control reg
			ret
#endif

#if		G2553
; Convert a contactor number or letter to a bitmask for the output port.
; This is a helper for the Contactor on and off (Joy and Misery) commands.
; GetContactorBitmask ( n -- m )
GetContactorBitmask:
			_CASE
			_OFb	#1,Rtos				; Precharge
				mov.b	#PreCont,Rtos
			_ENDOF
			_OFb	#2,Rtos				; Battery
				mov.b	#BatCont,Rtos
			_ENDOF
			_OFb	#3,Rtos				; Charge sources
				mov.b	#ChgCont,Rtos
			_ENDOF
			_OFb	#4,Rtos				; Discharge / Discretionary loads
				mov.b	#DisCont,Rtos
			_ENDOF
			_OFb	#5,Rtos				; Normal loads
				mov.b	#NrmCont,Rtos
			_ENDOF
			_ENDCASE
			ret

;
; Liven contactor ( n --- )
; Turn on the output for contactor n
;
			xCODE	'L',liven,_liven
			call	#GetContactorBitmask
			bis.b	Rtos,&P3OUT
			ret

;
; Unliven contactor ( n --- )
; Turn off the output for contactor n
;
			xCODE	'U',unliven,_unliven
			call	#GetContactorBitmask
			bic.b	Rtos,&P3OUT
			ret
#endif // G2553


; Modbus ( -- ) ; A colon begins a Modbus/ASCII packet. Packet ends with <cr><lf>.
; The Modbus/ASCII packet format is
; :<dev_id><func_code><reg_adr_hi><reg_adr_lo><reg_cnt_hi><reg_cnt_lo><LRC><cr><lf>
; where everything except the colon and <cr><lf> consists of a pair of ASCII hex digits.
; This is translated before being interpreted, to
; $<dev_id>s$<reg_addr_hi>$<reg_addr_lo>`\
; and a modbus-mode flag is set so PrettyPrint will format the response as a Modbus response.
;
		xCODE	':',Modbus,_Modbus	; Colon, begins a Modbus/ASCII packet
		; Modbus LRC check
		mov		#0,R9				; Clear LRC
		push	Rip					; Save position in buffer
		_BEGIN
		cmp.b	#EXIT,0(Rip)			; Current ch an EXIT? (was CR)
		_WHILE	_NE
			mov.b	@Rip+,R8			; Get a high hex digit
			cmp		#EXIT,0(Rip)		; Is next an EXIT? (was CR)
			jeq		abortColon			; Should not be! Abort if so
			sub.b	#'0',R8				; Convert to binary
			cmp.b	#9+1,R8				; Was it A-F?
			_IF		_GE
				sub.b	#7,R8				; Adjust for A-F
			_ENDIF
			rla4	R8					; Shift left 4 bits
			add.b	R8,R9				; Add to sum
			mov.b	@Rip+,R8			; Get a low hex digit
			sub.b	#'0',R8				; Convert to binary
			cmp.b	#9+1,R8				; Was it A-F?
			_IF		_GE
				sub.b	#7,R8				; Adjust for A-F
			_ENDIF
			add.b	R8,R9				; Add to sum
										; Ready to check is next ch a CR?
		_REPEAT
		tst		R9						; Sum should be zero
		jne		abortColon
		pop		Rip					; Restore input pointer
		
		bis.b	#bModbusOutput,&interpFlags	; Set the flag for PrettyPrint
		dec		Rip					; Back up to the start of the packet
		mov.b	#'$',0(Rip)			; Overwrite the colon with $ for the following <dev_id> hex digits
		mov.b	#'\\',3(Rip)		; Overwrite <func_code> hi digit with slosh (EXIT command)
		call	#_ENTER				; Interpret the hex device ID
		sub		#4,Rip				; Back up to the start of the packet again
		cmp		#246,Rtos
		_IF		_EQ					; If the ID is 246, treat as broadcast
			mov.b	#' ',3(Rip)			; Overwrite <func_code> hi digit with space (no-op)
		_ELSE
			mov.b	#'s',3(Rip)			; Overwrite <func_code> hi digit with 's' for select
			cmp.b	#247,Rtos			; For this BMU?
			_IF		_EQ
				mov.b	#'F',1(Rip)			; Yes, replace with FF (255)
				mov.b	#'F',2(Rip)			;	(255 is not a valid device address)
			_ENDIF
		_ENDIF
		mov.b	#'$',4(Rip)			; Overwrite <func_code> lo digit with '$' for <reg_adr_hi> digits
		mov.b	8(Rip),9(Rip)		; Move the <reg_adr_lo> hex digits along by one byte
		mov.b	7(Rip),8(Rip)
		mov.b	#'$',7(Rip)			; Insert a $ before the <reg_adr_lo> hex digits
		mov.b	#'`',10(Rip)		; Put a tock (EXECUTE command) after them
		mov.b	#'\\',11(Rip)		; And an EXIT command after that
		ret

abortColon
		add		#4,SP				; Remove saved Rip, and return address in the interpreter
		ret							; So now we return to the caller of the interpreter, thus
									; ignoring the packet with the bad LCC
		
; Capacity ( code -- ) ; Emit some constants, code determines which constant
;
		xCODE	'@',Capacity,_Capacity	; At sign, think "capATcity"
		_CASE
		_OFb	#$E,Rtos			; E: Energy capacity (Wh)
			mov		#CAP_ENERGY,Rsec
		_ENDOF
		_OFb	#$B,Rtos			; B: Battery total nominal voltage
			mov		#CAP_TOTV,Rsec
		_ENDOF
		_OFb	#$D,Rtos			; Discharge power capability
			mov		#CAP_DISCH,Rsec
		_ENDOF
		_OFb	#$C,Rtos			; Charge power capability
			mov		#CAP_CHARGE,Rsec
		_ENDOF
		_ENDCASE
		mov		#5,Rtos				; Use 5 digits
		mov		#'C',Rthd			; Response type is C, Capacity Constant
		jmp		_prettyPrint		; Pretty print and return
