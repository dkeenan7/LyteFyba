;
; Command character definitions common to both the monitor and TestICal,
; which need no customisation in either
;

; EXIT ( -- ); Return from interpreting a sequence of command characters.
; Causes any characters following to be treated as comments only (Forth "\").

		xCODE	'\\',EXIT,_EXIT	; Slosh (backslash)
		incd	SP			; Drop the return address within the interpreter
		ret					; Return to whoever called the interpreter (_ENTER)

; HEX ( flag -- ) ; Set the number base to hexadecimal

		xCODE	'h',HEX,_HEX
		bis.b	#bHexOutput,&intFlags
_Space	ret					; When _Space is called, be a no-op (for separating literal numbers)

; DECIMAL ( flag -- ) ; Set the number base to decimal

		xCODE	'd',DECIMAL,_DECIMAL
		bic.b	#bHexOutput,&intFlags
		ret

; CLIT ( -- c ) ; Character literal. Pronounced "see lit".
; Treat the next character in a command sequence as a literal character.

		xCODE	'\'',CLIT,_CLIT	; Tick (single-quote)
		xCODE	':',cLIT,_cLIT	; Colon, an alias for tick, used by the max and min commands
;		PUSH	Rtos
;		MOV.B	@Rip+,Rtos
		DPUSHb	@Rip+
		ret

; changeSign ( n -- -n )
;
		xCODE	'-',changeSign,_changeSign	; Postfix unary minus
		inv		Rtos
		inc		Rtos
		ret

; dollarHex ( -- )
;
		xCODE	'$',dollarHex,_dollarHex	; $ for starting hex number input
		bis		#1<<14,SR					; Set the hex flag
		ret

;
; eXclusive ( id -- )	; Sticky version of select. Type <ESC> to exit.
;
		xCODE	'x',eXclusive,_eXclusive
		bis.b	#bDontInterpret,&intFlags
		; Fall through to _Select
;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		xCODE	's',Select,_Select
		cmp.b	&ID,Rtos			; Correct ID?
;		pop		Rtos				; Pop the argument
;		DROP						; Pop the argument
		_IF		_NE					; If not correct ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ELSE						; Else
			bic.b	#bDontInterpret,&intFlags ; Needed to handle _eXclusive fall-through
		_ENDIF						; Endif
		ret

;
; eXclude ( id -- )	; Sticky version of deSelect. Type <ESC> to exit.
;
		xCODE	'X',eXclude,_eXclude
		cmp.b	&ID,Rtos			; specified ID?
		_IF		_EQ					; If specified ID
			bis.b	#bDontInterpret,&intFlags	; Stop interpreting
		_ENDIF
		ret
;
; deSelect ( id -- ) ; Ignore to end of line if ID on TOS is our ID
;
		xCODE	'S',deSelect,_deSelect
		cmp.b	&ID,Rtos			; Specified ID?
		_IF		_EQ					; If specified ID
			incd	SP					; Return to the outer interpreter (i.e. ignore rest of packet)
		_ENDIF						; Endif
		ret

;
; emitNum  ( n count -- ) ; Emit an integer n as count digits in the current number base
; Trashes R8-R12

		xCODE	'n',emitNum,_emitNum
#if 1	// This version takes up 7 more words of flash but doesn't use any stack (apart from its return address)
		mov		#4,R12				; Loop 5 times for decimal conversion
		bit.b	#bHexOutput,&intFlags ; Hexadecimal or decimal?
		_IF		_Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TX_ByteCk
				inv		Rsec				; Negate to get absolute value
				inc		Rsec
			_ENDIF						; Endif negative
			mov		Rsec,R10			; Get n as 16.16 bit fixpoint Dividend in R10:R9
			mov		#40000,R8			; Divisor in R8 is 4 * 10^4
			mov		R8,R9				; Instead of clearing R9 and adding one to the quotient later
			call	#UMSlashMod			; R10:R9 / R8 -> R9, remainder to R10 (ignored), clears R11
			clr		R10					; Ignore remainder. Treat R10:R9 as 16.16 bit fixpoint again
			rla		R9					; Shift R10:R9 2 bits left
			rlc		R10					; to get most sig decimal digit in R10 (max value 3)
			rla		R9
			rlc		R10
			mov		#10,Rsec			; Rsec := 10 (radix)
		_ELSE						; Else hexadecimal
			dec		R12					; Loop only 4 times for hexadecimal conversion
			dec		Rtos				; For hex, send one less digit than requested
			cmp		#2,Rtos				; but enforce a minimum of 2 digits
			_IF		_LO
				mov		#2,Rtos
			_ENDIF
			mov.b	#'$',R8				; Emit dollar sign for hex
			call	#TX_ByteCk
			mov		Rsec,R9				; R9 := n
			mov		#16,Rsec			; Rsec := 16 (radix)
			_BEGIN
				mov		Rsec,R8				; Radix (10 or 16) into R8
				call	#UMStar				; R9 * R8 -> R10:R9, clears R11
		_END_PRIOR_IF				; End hexadecimal
				cmp		Rtos,R12			; Only convert and send the digit if it was asked for
				_IF		_LO					; Equivalent to _IF _NC. So clrc isn't necessary below
					mov.b	R10,R8				; ASCII conversion follows
			;		clrc						; Because dadd is always done with carry on MSP430
					dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
					dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			;		and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
					mov		R9,Rthd				; Save R9
					call	#TX_ByteCk			; Transmit byte (accumulating checksum). Trashes R9
					mov		Rthd,R9				; Restore R9
				_ENDIF
				dec		R12					; Decrement loop counter
			_UNTIL	_L					; Jump back to matching _BEGIN if loop counter not negative

#else	// This version of emitNum takes less flash but uses up to 8 bytes of stack to reverse digits
		bit.b	#bHexOutput,&intFlags ; Hexadecimal or decimal?
		_IF		_Z					; If decimal, treat as a signed number
			tst		Rsec
			_IF		_L					; If n is negative
				mov.b	#'-',R8				; Emit minus sign
				call	#TX_ByteCk
				inv		Rsec				; Negate
				inc		Rsec
			_ENDIF						; Endif negative
			mov.b	#10,R8			; Divisor in R8 is number base
		_ELSE						; Else hexadecimal
			dec		Rtos				; Use one less digit
			mov.b	#'$',R8				; Emit dollar sign
			call	#TX_ByteCk
			mov.b	#16,R8			; Divisor in R8 is number base
		_ENDIF						; End hexadecimal
		dec		Rtos				; Count := Count-1
		_IF		_L					; Enforce a minimum of 2 digits
			mov		#1,Rtos
		_ENDIF
		mov		Rtos,R12			; Count to R12
		mov		Rsec,R9				; Dividend in R10:R9 will have n initially
		dec		R12					; Count := Count-1
		_BEGIN
			clr		R10
			call	#UMSlashMod			; dividend/base -> R9, remainder to R10
			push	R10					; Push remainder
			dec		R12
		_UNTIL	_L					; R9 keeps quotient as next dividend
		mov		R9,R8
		; Now we have n-1 results on the stack and the last one in R8; print these as hex/decimal
		_BEGIN
			clrc						; Because dadd is always done with carry on MSP430
			dadd.b	#$90,R8				; Causes a carry for A to F, none for 0 to 9
			dadd.b	#$40,R8				; Now any carry gets added, giving 30h-39h, 41h-46h
			and.b	#$7F,R8				; Ensure nothing can be misinterpreted as status
			call	#TX_ByteCk
			dec		Rtos
		_WHILE	_NN
			pop		R8
		_REPEAT
#endif
		ret


_prettyPrint3:
		mov		#3,Rtos
		; Fall thru to _prettyPrint
;
; Pretty print  ( ch n m -- ) Print n as a comment packet with m digits
; and precede with ID and ch.
; (no command letter)
_prettyPrint:
		push.b	&intFlags			; Save current number base

		DELAY_IF_NEEDED				; Allow time for CR to be echoed upstream if needed
		mov		#EXIT,R8			; Initial slosh (EXIT command or comment character)
		call	#TX_ByteCk			; Stops rest of packet being interpreted

		push	Rsec				; Save n
		push	Rtos				; Save m
		push	Rthd				; Save ch

		bic.b	#bHexOutput,&intFlags ; Set to decimal output
		mov.b	&ID,Rsec
		mov		#3,Rtos
		call	#_emitNum			; Emit the ID in decimal

		mov		#':',R8				; Colon separator
		call	#TX_ByteCk

		pop		R8					; Restore ch (type of measurement)
		call	#TX_ByteCk			; Transmit ch

		mov		#' ',R8				; Transmit a space
		call	#TX_ByteCk

		pop		Rtos				; Restore m
		pop		Rsec				; Restore n
		pop.b	&intFlags			; Restore number base to print n with
		call	#_emitNum

		call	#TX_Cksum			; Transmit checksum if required, then clear checksum.

		mov		#'\r',R8			; Carriage return to R8
		call	#TX_Byte			; Emit

		bic.b	#ACTLED,&P1OUT		; Set the (inverted) activity LED here to mimic old behaviour
		ret

;
; cellVolt ( -- )
; Transmit the cell voltage measurement in millivolts (0 to 4095 mV)
;
		xCODE		'v',cellVolt,_cellVolt
		call		#cellV				; Return cell voltage in millivolts in R10
		mov			#'v',Rthd			; Type is cell Voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Cell temperature measurement ( -- )
; Transmit cell temperature in degrees C
;
		xCODE		't',cellTemp,_cellTemp
		call		#temp				; Return temperature in degrees Celsius in R10
		mov			#'t',Rthd			; Type is temperature
										; Don't use degree symbol ($F8 Terminal font). Looks like status
		mov			R10,Rsec			; Result in degrees Celsius
		mov			#2,Rtos				; Print 2 digits
		jmp			_prettyPrint		; Tail-call pretty-print and return

;
; Link voltage measurement ( -- )
; Transmit link voltage in millivolts, -1500 to 1500 or 9999 for "invalid".
		xCODE		'l',linkVolt,_linkVolt
		call		#linkV				; Return link voltage in millivolts in R10
		mov			#'l',Rthd			; Type is Link voltage
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits... would 3 be enough?
		jmp			_prettyPrint		; Tail-call pretty-print and return


;
; Turn on or off the error LED (bool -- )
;
		xCODE	'e',errorLed,_errorLed
		tst		Rtos
		_IF		_Z
			bic.b	#ERRLED,&P2OUT			; Turn off the error LED
			bic.b	#PIEZO,&P1SEL			; Short out the piezo
		_ELSE
			bis.b	#ERRLED,&P2OUT			; Turn on the error LED
			bis.b	#PIEZO,&P1SEL			; Make the piezo squeal
		_ENDIF

;		pop		Rtos				; Remove operand
		ret

;
; Quiet (bool -- )
; Stop the piezo coming on with the error LED
		xCODE	'Q',quiet,_quiet
		allBitsIfZ	Rtos,Rtos		; IF Rtos is zero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#LFXT1S_2,&BCSCTL3 ; Move only #LFXT1S_2 bit from Rtos to &BCSCTL3. Trashes Rtos
		; Select either VLOCLK (~12 kHz) or LFXT1 (unused crystal oscillator) as source for ACLK divider
;		pop		Rtos				; Remove operand
		ret

; Query the reset-log ( maxResetsToShow -- )
			xCODE	'R',queryResetLog,_queryResetLog
			push	Rtos					; Save maxResetsToShow
			mov.b	#'R',Rthd				; Type is reset-log query
			mov		&resetCounter,Rsec		; Result
			call	#_prettyPrint3			; Pretty-print of 3 digits
	#if WATCHDOG
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart watchdog timer
	#endif

			; Now prettyPrint the reasons for the resets, in hex
			pop		R8						; Restore maxResetsToShow
			push.b	&intFlags				; Save current number base
			bis.b	#bHexOutput,&intFlags	; Set to hexadecimal output

			cmp		&resetCounter,R8		; Take min of maxResetsToShow and resetCounter
			_IF		_HS
				mov		&resetCounter,R8
			_ENDIF
			cmp		#16,R8					; Take min of that and 16
			_IF		_HS
				mov		#16,R8
			_ENDIF

			mov		&resetCounter,R9
			and		#$0F,R9
			add		#resetBuffer,R9

			_BEGIN
			tst		R8
			_WHILE	_NZ
			push	R8
			mov.b	#'R',Rthd				; Type is reset-log query
			dec		R9
			cmp		#resetBuffer,R9
			_IF		_LO
				mov		#resetBuffer+15,R9
			_ENDIF
			mov.b	@R9,Rsec				; Result
			push	R9
			call	#_prettyPrint3			; Call pretty-print for 3 digits
			pop		R9
	#if WATCHDOG
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart watchdog timer
	#endif
			pop		R8
			dec		R8
			_REPEAT

			pop.b	&intFlags				; Restore number base
			ret

; Reset the reset-log ( -- )
			xCODE	'^',resetResetLog,_resetResetLog ; "^" so unlikely to type accidentally
			clr		&resetCounter
			mov		#resetBuffer,R8
			_BEGIN
			clr.b	0(R8)
			inc		R8
			cmp		#resetBuffer+16,R8
			_UNTIL	_EQ
			ret


; NO_ECHO_CMD ; A wrapper macro for defining commands that need to operate without echo
NO_ECHO_CMD	MACRO	cmd0,cmd
			cmp.b	#1,&ID
			_IF		_EQ					; If my ID is 1
				mov		#$13,R8				; Transmit an XOFF (ctrl-S)
				call	#TX_ByteCk
				call	#cmd0				; Do the command with default parameters
				mov		#$11,R8				; Transmit an XON (ctrl-Q)
				call	#TX_ByteCk
			_ELSE						; Else (ID not 1)
				bit.b	#bDontEcho,&intFlags
				_IF		_NZ					; If the dont-echo flag is set
					call	#cmd				; Do the command
				_ENDIF
			_ENDIF
			ret
			ENDM


; NumCells  ( n -- ) Gives the number of cells
		xCODE	'N',NumCells,_NumCells
			NO_ECHO_CMD	doNumCells0,doNumCells		; Use the no-echo wrapper macro
doNumCells0:
			mov		#0,Rtos
doNumCells:	; Emit another NumCells command with its parameter incremented by one.
			; When preceded by XOFF (ctrl-S) 0 and followed by <cr> XON (ctrl-Q) it gives the cell count.
			inc		Rtos				; Increment the parameter
			DPUSH	#3					; Use a 3 digit field width
			call	#_emitNum			; Transmit the number as text in the current number base

			mov		#'N',R8				; Transmit an "N"
			call	#TX_ByteCk

			call	#TX_Cksum			; Transmit checksum if required, then clear checksum.

			mov		#'\r',R8			; Transmit a carriage return.
			call	#TX_Byte
			ret


; Min  ( id type value -- ) ; Gives the minimum voltage or temperature and the ID of the cell
		xCODE	'<',min,_min
			NO_ECHO_CMD	doMin0,doMin			; Use the no-echo wrapper macro
doMin0:
		mov		#0,Rthd				; Default ID
		mov		Rtos,Rsec			; Type
		mov		#$7FFF,Rtos			; Default value infinity
doMin:	; Emit another Min command with its last parameter min-ed with the
		; relevant local value. The second parameter tells which type of local value, voltage or temp.
		; The first parameter gives the ID of the cell having the max value.
 		_CASE
			_OF #'v',Rsec
				call	#cellV			; Get cell voltage in millivolts in R10
				push	#4				; Save the field width, 4 digits
			_ENDOF
			_OF #'t',Rsec
				call	#temp			; Get temperature in degrees Celsius in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'p',Rsec
				mov.b	&localStatus,R10 ; Get stress level in R10
				and.b	#$0F,R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'q',Rsec
				mov.b	&worstStress,R10 ; Get stress level in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
		mov		#$7FFF,R10			; Default case, unknown type, set R10 to infinity
		push	#1					; Save the field width, 1 digit
		_ENDCASE

		cmp		Rtos,R10			; Find min of parameter and local value
		_IF		_L
			mov		R10,Rtos
			mov.b	&ID,Rthd			; If new min, update ID
		_ENDIF

		push	Rtos				; Save value
		push	Rsec				; Save type

		mov		Rthd,Rsec			; Put ID into Rsec
		mov		#3,Rtos				; Use a 3 digit field width
		call	#_emitNum			; Transmit the ID as text in the current number base

		mov		#':',R8				; Transmit a colon, an alias for tick
		call	#TX_ByteCk

		pop		R8					; Pop and transmit the type, 'v' or 't'
		call	#TX_ByteCk

		mov		#' ',R8				; Transmit a space
		call	#TX_ByteCk

		pop		Rsec				; Pop the min value
		pop		Rtos				; Pop the field width
		call	#_emitNum			; Transmit the value as text in the current number base

		mov		#'<',R8				; Transmit a "<"
		call	#TX_ByteCk

		call	#TX_Cksum			; Transmit checksum if required, then clear checksum.

		mov		#'\r',R8			; Transmit a carriage return.
		call	#TX_Byte
		ret


; Max  ( id type value -- ) ; Gives the maximum voltage or temperature and the ID of the cell
		xCODE	'>',max,_max
			NO_ECHO_CMD	doMax0,doMax	; Use the no-echo wrapper macro
doMax0:
		mov		#0,Rthd				; Default ID
		mov		Rtos,Rsec			; Type
		mov		#$8000,Rtos			; Default value neg infinity
doMax:	; Emit another Max command with its last parameter max-ed with the
		; relevant local value. The second parameter tells which type of local value, voltage or temp.
		; The first parameter gives the ID of the cell having the max value.
 		_CASE
			_OF #'v',Rsec
				call	#cellV			; Get cell voltage in millivolts in R10
				push	#4				; Save the field width, 4 digits
			_ENDOF
			_OF #'t',Rsec
				call	#temp			; Get temperature in degrees Celsius in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'p',Rsec
				mov.b	&localStatus,R10 ; Get stress level in R10
				and.b	#$0F,R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
			_OF #'q',Rsec
				mov.b	&worstStress,R10 ; Get stress level in R10
				push	#2				; Save the field width, 2 digits
			_ENDOF
		mov		#$8000,R10			; Default case, unknown type, set R10 to neg infinity
		push	#1					; Save the field width, 1 digit
		_ENDCASE

		cmp		R10,Rtos			; Find max of parameter and local value
		_IF		_L
			mov		R10,Rtos
			mov.b	&ID,Rthd			; If new max, update ID
		_ENDIF

		push	Rtos				; Save value
		push	Rsec				; Save type

		mov		Rthd,Rsec			; Put ID into Rsec
		mov		#3,Rtos				; Use a 3 digit field width
		call	#_emitNum			; Transmit the ID as text in the current number base

		mov		#':',R8				; Transmit a colon, an alias for tick
		call	#TX_ByteCk

		pop		R8					; Pop and transmit the type, 'v' or 't'
		call	#TX_ByteCk

		mov		#' ',R8				; Transmit a space
		call	#TX_ByteCk

		pop		Rsec				; Pop the max value
		pop		Rtos				; Pop the field width
		call	#_emitNum			; Transmit the value as text in the current number base

		mov		#'>',R8				; Transmit a ">"
		call	#TX_ByteCk

		call	#TX_Cksum			; Transmit checksum if required, then clear checksum.

		mov		#'\r',R8			; Transmit a carriage return.
		call	#TX_Byte
		ret
