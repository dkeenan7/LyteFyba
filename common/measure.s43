; Suitable usage at appropriate part of assembly file: #include ../common/measure.s43
; Sensitive to these defines:
;	NumSamples
;	ADCBUF

; measure
; Input:  R8 = analog channel number shifted left 12 bits.
; 			   e.g. $7000 for cell voltage, $A000 for temperature, $6000 for link voltage.
; Output: R8 = uncalibrated 12.2-bit fixed-point result.
; Trashes R9-R10.
; Formerly assumed 4 MHz MCLK.
; Caller is responsible for initialising the pins in the ADC10AE0 register.
;
; Perform an analogue measurement without calibration.

measure:
#if !ADCBUF
			; This is the standard version, which doesn't use any RAM.

			; Turn on ADC10
			; no MSC	= single sample and conversion
			; ADC10ON	= turn on the ADC core
			bis			#ADC10ON,&ADC10CTL0
			; INCH		= R8 has the input channel number already in the right position
			; SHS_0		= enable software starting via the ADC10SC bit

			; ADC10DIV_1 = divide input clock by 2 for ADC10CLK
			; ADC10DIV_2 = divide input clock by 3 for ADC10CLK
            ; ADC10DIV_7 = divide input clock by 8 for ADC10CLK
			; ADC10SSEL_0 = choose internal ADC clock (3-6 MHz) as input to ADC10CLK divider
			; ADC10SSEL_2 = choose MCLK (4 MHz) as input to ADC10CLK divider
			; CONSEQ_0	= single channel single conversion
;			bis			#SHS_0+ADC10DIV_1+ADC10SSEL_2+CONSEQ_0,R8	;ADC10CLK = MCLK/2
			; We find that the below distributes noise particularly from SMCLK better, for more consistent
			; ADC readings
			bis			#SHS_0+ADC10DIV_2+ADC10SSEL_0+CONSEQ_0,R8	;ADC10CLK = ADC10OSC/3
// The below seems to cause the monitor to lose transmit characters, and doesn't seem to improve jitter
//			bis			#SHS_0+ADC10DIV_7+ADC10SSEL_0+CONSEQ_0,R8	;ADC10CLK = ADC10OSC/8
			mov			R8,&ADC10CTL1

			; Wait at least 30 us (= 120 cycles at 4 MHz) after REFON, for the reference to settle
;			_DO			#40,R8					; 40 times around a 3 cycle dec jnz loop
;			_LOOP		R8

			mov			#0,R8					; Initialise the sum. R8 no longer cleared by above loop
			_DO			#NumSamples,R9			; Sample counter
				bis			#ENC+ADC10SC,&ADC10CTL0	; Start conversion. ADC10SC is reset automatically

				ClearWatchdog

				_BEGIN								; Busy wait for conversion to complete
	;				bit			#ADC10IFG,&ADC10CTL0	; Done conversion?
	;			_UNTIL		_NZ
					bit			#ADC10BUSY,&ADC10CTL1	; Done conversion?
				_UNTIL		_Z
				add			&ADC10MEM,R8			; Add a result
	;			bic			#ADC10IFG,&ADC10CTL0	; Clear the interrupt flag
			_LOOP		R9
			bic			#ENC,&ADC10CTL0 		; Must turn off ENC bit before other bits can be changed
			bic			#ADC10ON,&ADC10CTL0 	; Turn off ADC core

#else
			; Version which reads <NumSamples> samples to a RAM buffer and adds them at the end.
			; Useful for debugging. Can see all values and compare them.

			; Turn on ADC10
			; MSC	= multiple sample and conversion
			; ADC10ON	= turn on the ADC core
			bis			#MSC+ADC10ON,&ADC10CTL0
			; INCHx		= R8 has the channel number already in the right position
			; SHS_0		= enable software starting via the ADC10SC bit
			; ADC10DIV_1 = divide input clock by 2 for ADC10CLK
			; ADC10DIV_2 = divide input clock by 3 for ADC10CLK
			; ADC10SSEL_0 = choose internal ADC clock (3-6 MHz) as input to ADC10CLK divider
			; ADC10SSEL_2 = choose MCLK (4 MHz) as input to ADC10CLK divider
			; CONSEQ_2	= repeat single channel
;			bis			#SHS_0+ADC10DIV_1+ADC10SSEL_2+CONSEQ_2,R8	;ADC10CLK = MCLK/2
			; We find that the below distributes noise particularly from SMCLK better, for more consistent
			; ADC readings
			bis			#SHS_0+ADC10DIV_2+ADC10SSEL_0+CONSEQ_2,R8	;ADC10CLK = ADC10OSC/3
			mov			R8,&ADC10CTL1

			; Wait at least 30 us (= 120 cycles at 4 MHz) after REFON, for the reference to settle
;			_DO			#40,R8					; 40 times around a 3 cycle dec jnz loop
;			_LOOP		R8

			mov.b		#NumSamples,&ADC10DTC1	; Typically 16 conversions
			mov			#sampleBuf,&ADC10SA		; Set start address
			bis			#ENC+ADC10SC,&ADC10CTL0	; Start conversion
			_BEGIN								; Busy wait for conversion to complete
;				bit			#ADC10IFG,&ADC10CTL0	; Done conversion?
;			_UNTIL		_NZ
				bit			#ADC10BUSY,&ADC10CTL1	; Done conversion?
			_UNTIL		_Z
;			bic			#ADC10IFG,&ADC10CTL0	; Clear the interrupt flag
			bic			#ENC,&ADC10CTL0 		; Must turn off ENC bit before other bits can be changed
			bic			#ADC10ON,&ADC10CTL0		; Turn off ADC core
			; Sum the samples
			mov			#0,R8					; Initialise the sum. R8 no longer cleared by above loop
			mov			#NumSamples*2,R9
			_BEGIN
				add			sampleBuf-2(R9),R8		; Add a sample
				decd		R9
			_UNTIL		_Z
	#if 0					; Debug code for measuring deviations -- Trashes R11
			mov		R8,R10						; Sum of samples into R10. Treat as mean in 12.4 fixed point
			clr		R8
			mov		#NumSamples*2,R9
			_BEGIN
				mov		sampleBuf-2(R9),R11		; Retrieve a sample
				rla		R11						; Convert to 12.4 fixed point
				rla		R11
				rla		R11
				rla		R11
				sub		R10,R11					; Subtract the mean to get deviation (as 12.4)
				_IF		_L						; Get absolute value of deviation (as 12.4)
					inv		R11
					inc		R11
				_ENDIF
				cmp		R11,R8					; Record the max abs deviation (as 12.4)
				_IF		_LO
					mov		R11,R8
				_ENDIF
				decd	R9
			_UNTIL	_Z
	#endif
#endif
			ret


; measAndCorr
; Input:  R8  = analog channel number shifted left 12 bits.
; Output: R10 = 12-bit measurement result with scale calibration applied.
; Trashes: R8, R9, R11
;
; Correct the value for scale by multiplying the sum-of-samples by the voltage calibration scale factor
; in info flash, and correct it for offset by adding another value from info flash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration scale factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
;
measAndCorr:
			call		#measure				; 12.2 fixed-point result in R8
			mov.w		&VoltCal,R9				; Get voltage calibration word as multiplicand in R9
												; Multiplier is sum-of-samples, already in R8
			call		#UMStar					; Gives unsigned product in R10 (hi word) and R9 (lo)
			inc			R10						; For correct rounding
			rra			R10						; Shift product hi word right one bit
			mov.b		&VoltOff,R9				; Get the voltage offset as signed byte
			sxt			R9						; Convert to signed word
			add			R9,R10					; Add the offset calibration value
			ret									; Finished

; As above, using the separate bolt calibration factor and offset
measAndCorrBolt:
			call		#measure				; 12.2 fixed-point result in R8
			mov.w		&BoltPlCal,R9			; Get bolt+ voltage scale factor as multiplicand in R9
			cmp.w		#$FFFF,R9				; Check if it doesn't exist, i.e. just erased flash
			_IF			_EQ						; If it doesn't exist
				mov.w		&VoltCal,R9				; Use the cell voltage scale factor instead
			_ENDIF								; Endif
												; Multiplier is sum-of-samples, already in R8
			call		#UMStar					; Gives unsigned product in R10 (hi word) and R9 (lo)
			inc			R10						; For correct rounding
			rra			R10						; Shift product hi word right one bit
			mov.b		&BoltPlOff,R9			; Get the voltage offset as signed byte
			sxt			R9						; Convert to signed word
			add			R9,R10					; Add the offset calibration value
			ret									; Finished
BatV:
cellV:
; Trashes: R8, R9, R11
; Output: R10 = calibrated in millivolts, approx range 0 to 4348
			mov		#CellVChan<<12,R8
			call	#measAndCorr
			cmp.b	#255,&ID
			_IF		_NE			; If not a BMU then
				; Multiply by 17/16 to change full-scale from 4092 mV to 4348 mV
				mov		R10,R8		; Copy the value
				add		#8,R8		; Add half the divisor for rounding
				rra4	R8			; Divide by 16
				add		R8,R10		; Add back to the original
			_ENDIF
			ret


CapV:		; When used by (w)monolith to check precharge
ArrayV:
BoltV:
; Trashes: R8, R9, R11
; Output: R10 = calibrated in millivolts, approx range 0 to 4348
			mov		#BoltVPlChan<<12,R8
			call	#measAndCorrBolt
			cmp.b	#255,&ID
			_IF		_NE			; If not a BMU then
				; Multiply by 17/16 to change full-scale from 4092 mV to 4348 mV
				mov		R10,R8		; Copy the value
				add		#8,R8		; Add half the divisor for rounding
				rra4	R8			; Divide by 16
				add		R8,R10		; Add back to the original
			_ENDIF
			ret


temp:
; Output: R10 = temperature calibrated in degrees Celsius, approx range ???
; Trashes: R8, R9, R11
			mov		#TempChan<<12,R8
			call	#measAndCorr
			; Scale it back to degrees Celsius. Typically, T = (V-0.986)/.00355
			; But the measurement M is 4092* V/1.5 = 2728*V.
			; So T = (M/2728 - 0.986)*281.75 = M/9.684 - 277.75
			; To divide by 9.684 counts/°C, multiply by 65536/9.684 = 6767, and keep the top half
			mov		R10,R8
			mov		#27069,R9
			call	#UMStar					; R10:R9 = meas*6767 so M/9.684 to R10
			sub		#1111,R10				; M/9.684 - 277.75
			add		#2,R10					; Add half the divisor for rounding
			rra2	R10						; Divide by 4
			mov.b	&TempCal,R8				; Subtract the offset calibration
			sxt		R8
			sub		R8,R10					; R10 now has temperature in degrees Celsius
			ret

linkV:
; Output: R10 = calibrated in millivolts, approx range -1500 to +1500.
; 9999 means linkV not valid, ignore.
; Trashes: R8, R9, R11
			mov.b		&LinkCal,R8		; Link offset calibration
			cmp.b		#$80,R8			; $80 is a special value representing "calibration failure"
			_IF			_EQ				; If link calibration value is $80
				mov		#9999,R10			; then use special value
			_ELSE
				; In the below, add ADC10DIV_7, which forces the link measurement to use the slowest (/8) clock
				mov			#LinkVChan<<12+ADC10DIV_7,R8	; Shifted ADC channel for link voltage divider
				call		#measAndCorrBolt	; Measure and correct using BoltPL corrections
				; Link voltage measurement in mV
				; Circuit has 2:1 voltage divider with Vref at the bottom.
				; So measure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
				; Reading = 2046 + (Vin/2)(4092/1.5)
				; R = 2046 + Vin * 1364 (Vin in volts)
				; R = 2046 + Vin * 1.364 (Vin in mV)
				; Vin = (R - 2046)/1.364 mV
				; To divide by 1.364, multiply by 65536/1.364 = 48047 and keep the top half
				sub			#2046,R10
				mov.b		&LinkCal,R8		; Link offset calibration
				sxt			R8				; Sign extend
				sub			R8,R10
				_IF			_NN
					mov			R10,R8
					mov			#48047,R9
					call		#UMStar
					; Most significant half is in R10
				_ELSE
					inv			R10
					inc			R10				; Negate
					mov			R10,R8
					mov			#48047,R9
					call		#UMStar
					inv			R10				; Only interested in top half
					inc			R10				; Negate back
				_ENDIF
			_ENDIF
			ret

#if INSULATION_MONITORING
touchV:
; Trashes: R8, R9, R11
; Output: R10 = uncalibrated reading (affected by optocoupler CTR), approx range 0 to 4092
			mov		#TouchVChan<<12,R8
			jmp		measAndCorr					; Tail-call measAndCorr and return
#endif // INSULATION_MONITORING

