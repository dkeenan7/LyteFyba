;
; Routine to perform an analogue measurement and put the "12 bit" result into R8.
; On input, R8 must contain the measurement channel number shifted left by 12 bits,
; e.g. $7000 for cell voltage, $A000 for temperature, $3000 for link voltage.
; Trashes R9-R10
; Calls aUMStar
; Suitable use at appropriate part of assembly file: #include ../common/measure.s43
; Sensitive to these defines:
;	TEST: set to 1 for setting P1.4 to digital zero, for testing BMUs in parallel
;	SLOWSAMP: set to 1 for 16 uS sample time, 0 gives ~13 uS that varies with individual devices

measure:
;
; Initialise the ADC10 system
;
; SREF_1 = 4 volt mode; ; REFBURST = save power by turning off buffer when not sampling
; ADC10SHT_3 = 64 ADC10CLKs (~ 13 uS sample time with ADCCLK)
; or ADC10SHT_2 = 16 clocks (16 uS with MCLK) (_3 = 64 clocks = 64uS for temperature measurement)
; MSC = continuous sampling; REFON = turn on internal reference; ADC10ON = power up the ADC system
#if TEST
		; When testing with BMUs in parallel, we want P1.4 to be digital output 0V so that even with the
		; link input = 3.6 V, P1.3 won't exceed Vcc and therefore won't upset the ADC10 readings
		cmp			#TempChan<<12,R8
		jnz			notTempChan
#if SLOWSAMP
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON,&ADC10CTL0		; Very slow 64uS sample for temperature
#else
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON,&ADC10CTL0		; NOTE: way too fast for temperature!
#endif
		jmp			doneCTL0
notTempChan
#if SLOWSAMP
		mov			#SREF_1+ADC10SHT_2+MSC+REFON+ADC10ON,&ADC10CTL0		; Slower 16 uS sample
#else
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON,&ADC10CTL0		; Faster ~~ 13 uS sample
#endif
doneCTL0
		cmp			#LinkVChan<<12,Rtos				; ADC channel for link voltage
		jnz			noRefOut
		bis.b		#1<<4,&ADC10AE0				;  then make P1.4 analogue, and
		bis			#REFOUT,&ADC10CTL0			;  set REFOUT
		jmp			p1_4_input
noRefOut
		mov.b		#(1<<7)+(1<<3),&ADC10AE0; Enable P1.7 and P1.3 as analogue inputs, i.e.
											; make P1.4 digital
		bis.b		#1<<4,&P1DIR			; Make P1.4 an output, so when testing with paralleled BMUs,
p1_4_input									; we don't see > Vcc on P1.3 (LinkV)
#else
		; On cells, we want P1.4 to be set as an analog I/O pin (ADC10AE.4=1) and we set REFOUT in ADC10CTL0
		; so that it always outputs Vref on P1.4. That way, even with regen putting negative voltages on the
		; link input, P1.3 doesn't go below analogue ground (would invalidate readings)
#if SLOWSAMP
		mov			#SREF_1+ADC10SHT_2+MSC+REFON+ADC10ON+REFOUT,&ADC10CTL0
#else
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON+REFOUT,&ADC10CTL0
#endif
		mov.b		#(1<<7)+(1<<3)+(1<<4),&ADC10AE	; Enable P1.7, P1.3  and P1.4 as analogue
#endif

; INCH_7 = ADC7 (VDIV); SHS_0 = software start; ADC10SSEL_0 = ADC10OSC or _2 = MCLK;
; CONSEQ_2 = repeat-single-channel
		; Note that Rtos has the channel number already in the right position
		mov			Rtos,R8
		swpb		R8						; Move channel number to top halfword
#if SLOWSAMP
		bis			#SHS_0+ADC10SSEL_2+CONSEQ_2,R8
#else
		bis			#SHS_0+ADC10SSEL_0+CONSEQ_2,R8
#endif
		mov			R8,&ADC10CTL1
		mov.b		#NumSamples,&ADC10DTC1	; 16 conversions
		mov			#sampleBuf,&ADC10SA		; Set start address
		bis			#ENC+ADC10SC,&ADC10CTL0	; Start conversion
convert	bit			#ADC10IFG,&ADC10CTL0	; Done conversion?
		jz			convert					; No, busy wait
		bic			#ADC10ON+ENC+ADC10SC,&ADC10CTL0	; Turn off the ADC
;
; Sum the samples
;
		mov			#sampleBuf,R9
		mov			#0,R8					; Initialise the sum
addSamp	add			@R9+,R8					; Add a sample
		cmp			#sampleBuf+2*NumSamples,R9
		jnz			addSamp
;
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading, 
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts. 
; That means we have to shift the product 17 bits to the right, which is equivalent to 
; throwing away the lo word and shifting the high word one bit to the right.
		mov.b		&VoltCalL,R9			; Get voltage calibration lo byte
		mov.b		&VoltCalH,R10			; Get voltage calibration hi byte
		swpb		R10						; Assemble the two bytes into a word
		bis			R10,R9					; as multiplicand in R9
											; Multiplier is sum-of-samples, already in R8
		call		#aUMStar				; Gives unsigned product in R10 (hi word) and R9 (lo word)
											; Note: calls assembler code that ends in ret
		inc			R10						; For correct rounding
		rra			R10						; Shift product hi word right one bit
		mov			R10,R8
		ret