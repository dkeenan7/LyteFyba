;
; Routine to perform an analogue measurement and put the 12.2 bit result into R8.
; No calibration is performed.
; On input, R8 must contain the measurement channel number shifted left by 12 bits,
; e.g. $7000 for cell voltage, $A000 for temperature, $3000 for link voltage.
; Trashes R9-R10
; Calls aUMStar
; Suitable use at appropriate part of assembly file: #include ../common/measure.s43
; Sensitive to these defines:
;	VoltCalL, VoltCalH: addresses of low and high bytes of the voltage calibration values

measure:
;
; Initialise the ADC10 system
;
; SREF_1 = 4 volt mode; ; REFBURST = save power by turning off buffer when not sampling
; ADC10SHT_3 = 64 ADC10CLKs (~ 13 uS sample time with ADCCLK)
; or ADC10SHT_2 = 16 clocks (16 uS with MCLK) (_3 = 64 clocks = 64uS for temperature measurement)
; MSC = continuous sampling; REFON = turn on internal reference; ADC10ON = power up the ADC system
		; When testing with BMUs in parallel, we want P1.4 to be digital output 0V so that even with the
		; link input = 3.6 V, P1.3 won't exceed Vcc and therefore won't upset the ADC10 readings
		cmp			#TempChan<<12,R8
		jnz			notTempChan
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON,&ADC10CTL0		; Very slow 64uS sample for temperature
		jmp			doneCTL0
notTempChan
		mov			#SREF_1+ADC10SHT_2+MSC+REFON+ADC10ON,&ADC10CTL0		; Slower 16 uS sample
doneCTL0
		cmp			#LinkVChan<<12,R8			; ADC channel for link voltage
		jnz			noRefOut
		bis.b		#1<<4,&ADC10AE0				;  then make P1.4 analogue, and
		bis			#REFOUT,&ADC10CTL0			;  set REFOUT
		jmp			p1_4_input
noRefOut
		mov.b		#(1<<7)+(1<<3),&ADC10AE0; Enable P1.7 and P1.3 as analogue inputs, i.e.
											; make P1.4 digital
		bis.b		#1<<4,&P1DIR			; Make P1.4 an output, so when testing with paralleled BMUs,
p1_4_input									; we don't see > Vcc on P1.3 (LinkV)

; INCH_7 = ADC7 (VDIV); SHS_0 = software start; ADC10SSEL_0 = ADC10OSC or _2 = MCLK;
; CONSEQ_2 = repeat-single-channel
		; Note that R8 has the channel number already in the right position
		bis			#SHS_0+ADC10SSEL_2+CONSEQ_2,R8
		mov			R8,&ADC10CTL1
		mov.b		#NumSamples,&ADC10DTC1	; 16 conversions
		mov			#sampleBuf,&ADC10SA		; Set start address
		bis			#ENC+ADC10SC,&ADC10CTL0	; Start conversion
convert	bit			#ADC10IFG,&ADC10CTL0	; Done conversion?
		jz			convert					; No, busy wait
		bic			#ADC10ON+ENC+ADC10SC,&ADC10CTL0	; Turn off the ADC
;
; Sum the samples
;
		mov			#sampleBuf,R9
		mov			#0,R8					; Initialise the sum
addSamp	add			@R9+,R8					; Add a sample
		cmp			#sampleBuf+2*NumSamples,R9
		jnz			addSamp
		ret