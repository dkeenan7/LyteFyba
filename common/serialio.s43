;*******************************************************************************
;	MSP430F20xx Software UART - Timer_A
;
;	Description: Use Timer_A CCR0 hardware output modes and SCCI data latch
;	to implement UART function @ 9600 baud. Software does not directly read and
;	write to RX and TX pins, instead proper use of output modes and SCCI data
;	latch are demonstrated. Use of these hardware features eliminates ISR
;	latency effects as hardware insures that output and input bit latching and
;	timing are perfectly synchronised with Timer_A regardless of other
;	software activity.
;	TACLK = SMCLK/4 = DCOCLK/8/4 = 250 kHz, MCLK = DCOCLK/2 = 4.00 MHz
;
;				MSP430F20xx
;			 ---------------
;		 /|\|				|
;		  | |				|
;		  --|RST			|
;			|				|
;			|		TA0/P1.1|--------> TXDm (mark = low)
;			|	   SCLK P1.5|--------> TXDp (mark = high; via internal inverter from TA0)
;			|				| 9600 8N1 full duplex
;			|	  CCI1A/P1.2|<-------- RXD
;
;
;	September 2010
;	Based on code by:
;	M. Buccini / L. Westlund
;	Texas Instruments Inc.
;	October 2005
;*******************************************************************************

; Timer A overflow is used for the regular processing "tick" or status frequency
; while its capture/compare regs are used for the interrupt-driven software UART
;
;	Conditions for 9600 Baud SW UART
DCOfreq		EQU		8000000				; DCO clock in Hz
DCOckPerMck	EQU		2					; Number of DCO clocks per MCK (CPU, ADC) (allowed values 1,2,4,8)
DCOckPerSMck EQU	8					; Number of DCO clocks per SMCK (Timer) (allowed values 1,2,4,8)
StatusFreq	EQU		2					; Status frequency in hertz (allowed 2, 4, 8 or 16)
SMckPerTAck	EQU		(DCOfreq/DCOckPerSMck/StatusFreq+(1<<15))/(1<<16)
										; Number of SMCK clocks per timer clock (allowed 1,2,4,8)
MckPerTAck	EQU		SMckPerTAck*DCOckPerSMck/DCOckPerMck
TAfreq		EQU		DCOfreq/(DCOckPerSMck*SMckPerTAck)	; Timer frequency in Hertz
BitTime96	EQU		(TAfreq+4800)/9600	; 104.17 us bit length in timer clock periods for 9600 baud
BitTime24	EQU		(TAfreq+1200)/2400	; 416.68 us bit length in timer clock periods for 2400 baud


;-------------------------------------------------------------------------------
; TxString	; Transmit counted string pointed to by R10 while accumulating checksum.
			; Warning: A zero length string will be treated as 256 bytes long.
			; If necessary, wait until the queue is not full.
			; Trashes R8 thru R11.
;-------------------------------------------------------------------------------

TxString: _DOb	@R10+,R11
				mov.b	@R10+,R8
				call	#TxByte
			_LOOPb	R11
			ret

;-------------------------------------------------------------------------------
; TxStringCk ; Transmit counted string pointed to by R10 while accumulating checksum.
			; Warning: A zero length string will be treated as 256 bytes long.
			; If necessary, wait until the queue is not full.
			; Trashes R8 thru R11.
;-------------------------------------------------------------------------------

TxStringCk: _DOb	@R10+,R11
				mov.b	@R10+,R8
				call	#TxByteCk
			_LOOPb	R11
			ret

;-------------------------------------------------------------------------------
; TxByteCk	; Transmit the character in R8 while accumulating checksum.
			; If necessary, wait until the queue is not full.
			; Trashes R9.
;-------------------------------------------------------------------------------

TxByteCk:
			xor.b	R8,&txCksum
TxByte:	; Alternative entry which does not accumulate checksum
			_BEGIN

				ClearWatchdog

				call	#TxByteNoWait
			_UNTIL	_NZ
			ret

;
; Attempt to put the character from R8 into the transmit queue.
; If the queue is full, return immediately with the Z status bit set.
; Preserves R8, trashes R9.
;
TxByteNoWait:
			mov.b	&txWr,R9				; Get the write index (not changed by TxIsr)
			mov.b 	R8,txBuf(R9)			; Tentatively write the character to the transmit queue
											;	there's always at least one free space,
											;	but don't increment the write index yet.
			inc.b	R9						; Increment a copy of the write index
			and.b	#TxSz-1,R9				;	modulo the queue size
			cmp.b	&txRd,R9				; If wr+1 mod sz = rd then it's full
			_IF		_NE
				mov.b	R9,&txWr			; Increment write index so char is officially in tx queue

				; If transmit interrupts are disabled, set up the timer for a new start bit
				; and enable transmit compare interrupts.
				bit		#CCIE,&TACCTLt		; Test transmit interrupts enabled bit
				_IF		_Z					; If transmit interrupts disabled
					mov.b	#8,&USICNT			; Load USI counter to keep USIIFG clear so TXDp (SCLK)
												;   will continue to be an inversion of TXDm (TA0).
					mov.b	#10,&bitCntTx		; Load bit transition counter: 10 bits
					; Ensure a predictable delay between reading timer and setting
					; compare time and output mode for a start bit.
					dint
					; Calculate max number of timer clocks till TACCRt & TACCTLt will be correctly set up.
					; First number is sum of cycles in paren below. The +MckPerTAck-1 is for rounding up.
					; Half of the +2 is in case the TAR increments just after we read it.
					; Don't understand why other half needed, but otherwise it fails when StatusFreq = 2
					; and hence MckPerTAck = 32.
					mov		#((23+MckPerTAck-1)/MckPerTAck)+2,R9 ; R9 := setup time. Not protected by dint
					add		&TAR,R9				; R9 := timer value + setup time
					_COND						; Start short circuit conditional
						bit		#CCIFG,&TACCTLt		; (5) Test transmit compare interrupt flag
					_OR_ELSE	_NZ				; (2) If previous stop bit has not completed Or Else
						cmp		&TACCRt,R9			; (4) Test (TAR+setup) - TACCRt
					_OR_IFS		_NN				; (2) Or If existing TACCRt AFTER TAR+setup, keep TACCRt
						mov		R9,&TACCRt			; (4) Set the new compare value for the start-bit
					_ENDIF						; Endif existing TACCRt is AFTER TAR+setup
					eint						; (1) Next instruction still protected
					mov		#OUTMOD_1+CCIE,&TACCTLt ; (5) Set out mode for start bit, enable compare ints

					ActLedOn					; Turn on the (inverted) activity LED for visual feedback
				_ENDIF 						; Endif transmit interrupts disabled

				clrz						; Indicate char was accepted
			_ENDIF
			ret

#if 0
TxByteNoWaitAlternateVersion:	; In progress. Requires 11 interrupts per byte instead of 10. -- DK
			mov.b	&txWr,R9				; Get the write index (not changed by TxIsr)
			mov.b 	R8,txBuf(R9)			; Tentatively write the character to the transmit queue
											;	there's always at least one free space,
											;	but don't increment the write index yet.
			inc.b	R9						; Increment a copy of the write index
			and.b	#txSz-1,R9				;	modulo the queue size
			cmp.b	&txRd,R9				; If wr+1 mod sz = rd then it's full
			_IF		_NE
				mov.b	R9,&txWr			; Increment write index so char is officially in tx queue

				; If we're in a stop bit and the next timer compare match would transition to idle state
				; and we have time to set it up it before the compare match occurs,
				; then set it up it so it will transition to a start bit instead.
				dint
				tst.b	&bitCntTx			; BitCntTx = 0 means stop -> idle
				_IF	_Z
					mov		&TACCRt,R9			; Get the compare value
					sub		&TAR,R9				; Subtract the timer value
					; Compare it with the required setup time.
					; First number is sum of cycles in paren below. The +MckPerTAck-1 is for rounding up.
					; The +1 is in case the TAR increments just after we read it.
					cmp		#((9+MckPerTAck-1)/MckPerTAck)+1,R9 ; (2)
					_IF _GE								; (2)
						mov		#OUTMOD_1+CCIE,&TACCTLt ; (5) Set out mode fr start bit, enble cmpare ints
						mov.b	#8,&USICNT			; Load USI counter to keep USIIFG clear so TXDp (SCLK)
													;   will continue to be an inversion of TXDm (TA0).
						mov.b	#10,&bitCntTx		; Load bit transition counter: 10 bits
					_ENDIF
				_ENDIF
				eint

				; If transmit interrupts are disabled, stop bit has finished,
				; so set up the timer for a new start bit ASAP
				; and enable transmit compare interrupts.
				bit		#CCIE,&TACCTLt		; Test transmit interrupts enabled bit
				_IF		_Z					; If transmit interrupts disabled
					mov.b	#8,&USICNT			; Load USI counter to keep USIIFG clear so TXDp (SCLK)
												;   will continue to be an inversion of TXDm (TA0).
					mov.b	#10,&bitCntTx		; Load bit transition counter: 10 bits
					; Ensure a predictable delay between reading timer and setting
					; compare time and output mode for a start bit.
					dint
					; We want the max number of clock cycles till TCCRt and TACCTLt are correctly set up.
					; First number is sum of cycles in paren below. The +MckPerTAck-1 is for rounding up.
					; The +1 is in case the TAR increments just after we read it.
					mov		#((23+MckPerTAck-1)/MckPerTAck)+1,R9 ; R9 := setup time. Not protected by dint
					add		&TAR,R9				; R9 := timer value + setup time
					_COND						; Start short circuit conditional
						bit		#CCIFG,&TACCTLt		; (5) Test transmit compare interrupt flag
					_OR_ELSE	_NZ				; (2) If previous stop bit has not completed Or Else
						cmp		&TACCRt,R9			; (4) Test (TAR+setup) - TACCRt
					_OR_IFS		_NN				; (2) Or If existing TACCRt AFTER TAR+setup, keep TACCRt
						mov		R9,&TACCRt			; (4) Set the new compare value for the start-bit
					_ENDIF						; Endif existing TACCRt is AFTER TAR+setup
					eint						; (1) Next instruction still protected
					mov		#OUTMOD_1+CCIE,&TACCTLt ; (5) Set out mode for start bit, enable compare ints

					ActLedOn					; Turn on the (inverted) activity LED for visual feedback
				_ENDIF 						; Endif transmit interrupts disabled

				clrz						; Indicate char was accepted
			_ENDIF
			ret
#endif

;
; Wait for the transmit queue to empty and last byte to be sent.
; Called by DoPassword in monitor and monolith before disabling interrupts and branching to BSLErase.
; Called before changing baud rate in monolith.
;
WaitTxComplete:
			_BEGIN						; Begin loop

				ClearWatchdog

				bit		#CCIE,&TACCTLt		; Test the transmit interrupts enabled bit
			_UNTIL	_Z					; Until it is cleared
			ret

;-------------------------------------------------------------------------------
TxIsr:	; Transmit (timer capture/compare 0) interrupt service routine
;-------------------------------------------------------------------------------
; 1st interrupt BitCntTx is 10 (dec to 9), falling edge of start-bit just sent, need to set up for LSB
; 8th interrupt, BitCntTx is 3, just transitioned to data bit 6, need to set up for transition to MSB
; 9th interrupt, BitCntTx is 2, just transitioned to MSB, need to set up for transition to stop bit (1)
; 10th interrupt, BitCntTx is 1 (dec to 0), just transitioned to stop bit,
; need to set up for transition to next start bit if there is another byte in the tx queue
; or disable Tx interrupts if there are no more characters.

; But perhaps we should instead setup for a transition to idle state (same as stop bit)
; if there are no more characters.
; Then we would have an 11th interrupt where stop bit is complete and we disable Tx interrupts.
; But TxByteNoWait would still have to deal specially with the case where the queue becomes non-empty
; before the stop bit has finished. The question is whether it would be less messy than it is now,
; use less code, or not need to disable interrupts for so long. -- DK

											; (6) cycles for interrupt accepted
			add.w	&txBitTime,&TACCRt		; (6) Set timer compare reg for when next transition is due
			dec.b	&bitCntTx				; (4) Decrement bit counter
			_IF		_NZ						; (2) If not Stop bit initiated

				cmp.b	#9,&bitCntTx			; (5) Test if start bit just started
				_IF		_EQ						; (2) If start bit just started
					push	R9
					mov.b 	&txRd,R9				; Get read index in R9
					mov.b	txBuf(R9),&txData		; Get next char from queue into TXData
					inc.b 	R9						; Increment the read index
					and.b 	#TxSz-1,R9				;	modulo the queue size.
					mov.b 	R9,&txRd				; Update the read index
					pop		R9
					; The below would just waste time and space. We don't need to wake up to do anything
					; in the mainline after taking a byte from the TX queue. -- DK
					; bic		#CPUOFF,0(SP)			; When return, wake CPU if needed
				_ENDIF							; Endif start bit just started
				rra.w	&txData					; (1) Next bit to C. NOTE: upper byte remains $FF always,
												;	so stop and idle bits are always treated like data 1s
				_IF		_NC						; (2) If bit is 0
					mov		#OUTMOD_1+CCIE,&TACCTLt ; (5) then set TXDm = TA0 output high
				_ELSE							; (2) Else bit is 1
					mov		#OUTMOD_5+CCIE,&TACCTLt	; (5) Else clear TXDm = TA0 output low
				_ENDIF							; Endif bit is 1
			_ELSE							; Else Stop bit initiated
				cmp.b 	&txWr,&txRd				; Test if TX queue is empty
				_IF		_EQ						; If TX queue is empty
					bic.w	#CCIE,&TACCTLt			; (5) Disable Tx interrupts
					ActLedOff						; (5) Turn off activity LED at end of the transmit
				_ELSE							; Else TX queue is not empty
					mov.b	#8,&USICNT				; Load USI counter to keep USIIFG clear so TXDp (SCLK)
													;   will continue to be an inversion of TXDm (TA0).
					mov.b	#10,&bitCntTx			; Load bit transition counter: 10 bits
					mov.w	#OUTMOD_1+CCIE,&TACCTLt ; (5) Set output mode for start bit

					ActLedOn						; Turn on the activity LED for visual feedback.
				_ENDIF							; Endif TX queue is not empty
			_ENDIF							; Endif Stop bit initiated
			reti

;-------------------------------------------------------------------------------
RxTiovIsr:	; Combined Receive (timer capture/compare 1) and timer overflow interrupt service routine
;-------------------------------------------------------------------------------
			; Warning: Do not be tempted to replace the two instructions below: mov &TAIV,R9 ; cmp #2,R9
			; with the single instruction cmp #2,&TAIV. This caused rare dropped bits on receive and
			; it took a lot of effort to trace the problem to this instruction.
			; It appears that despite only reading and not writing to its "destination" operand, the
			; compare instruction is still treated as making _two_ accesses to TAIV, in the sense that
			; it clears not only the interrupt flag being serviced but also any other TAIV interrupt
			; that might be pending, causing it to never be serviced.

											; (6) cycles for interrupt accepted
			push	R9						; (3) Save R9 (needed for queue use on last data bit anyway)
			mov		&TAIV,R9				; (3) Read the Timer-A interrupt sub-vector (one access only!)
			cmp		#4,R9					; (1) Was it a PWM interrupt (TACCR2)
			jeq		PwmCmp
			cmp		#2,R9					; (1) Was it a receive interrupt (TACCR1)
			jeq		RxIsr					; (2) Yes, jump to receive interrupt service routine
			; Otherwise fall thru to timer overflow interrupt service routine
;
;	Regular timer overflow interrupt: Cause the mainline code to measure voltages etc
;
TiovIsr:
 			bic.b	#bNotMeasureTime,&monFlags ; Notify mainline that it's time to measure
			jmp		WakeExit				; Arrange to wake CPU, restore R9 and return from interrupt

;
;	Receive interrupt: Handle start-bit timer-capture or data-bit timer-compare
;
RxIsr:		add		#BitTime96,&TACCRr		; (5) Time to next bit
			bit		#CAP,&TACCTLr			; (5) Capture mode = start bit edge
			_IF		_NZ						; (2) If start bit edge
				bic		#CAP,&TACCTLr		; (5) Switch to compare mode
				add		#BitTime96/2,&TACCRr; (5) First databit 1.5 bits from edge
			_ELSE							; (2) Else data bit sampled
				bit		#SCCI,&TACCTLr			; (4) Sampled bit to carry
				rrc.b	&rxData					; (4) Store received bit
				dec.b	&bitCntRx				; (4) All bits RXed?
				_IF		_Z						; (2) If this is the last data bit
					mov.b	#8,&bitCntRx			; Setup bit counter for next byte
					bis		#CAP,&TACCTLr			; Set back to capture mode

					; Put received data into the queue if there's space, otherwise it's lost
					mov.b	&rxWr,R9				; Get the write index
					mov.b	&rxData,rxBuf(R9)		; Tentatively write the character to the receive queue
													;  there's always at least one free space,
													;  but don't increment the write index yet.
					inc.b	R9						; Increment a copy of the write index
					and.b	#RxSz-1,R9				;  modulo the queue size
					cmp.b	&rxRd,R9				; If wr+1 mod sz = rd then it's full
					_IF		_NE						; If queue not full
						mov.b	R9,&rxWr				; Update write index so char is properly in queue
WakeExit				bic		#CPUOFF,2(SP)			; When return, wake CPU. 2(SP) due to saved R9
					_ENDIF							; Endif queue not full
				_ENDIF							; Endif last data bit
			_ENDIF							; Endif data bit sampled
			pop		R9						; (2) Restore R9
			reti							; (5) Return from interrupt

;
; TACCTL2 interrupt (compare match for PWM)
;
PwmCmp:
			xor.b	#(1<<3),&P1OUT			; (4) Toggle P1.3. NOTE: assume it stays in step with R9!
			bit.b	#(1<<3),&P1OUT			; (3) Test the bit
			_IF		_NZ						; (2) If now set,
				mov		&pwmAdv,R9				; (3) then just get advance value to R9
			_ELSE							;	  (2) But if now zero, need to calculate low time
				mov		#1000,R9				; (2)
				sub		&pwmAdv,R9				; (3) = 1000 (PWM period) - pwmAdv
			_ENDIF
			add		R9,&TACCR2				; (4) Advance TACCR2 by this amount
			; Note: no clear of the CPUOFF bit here, to save time. Not needed anyway.
			pop		R9						; (2) Restore R9
			reti							; (5) Return from interrupt

;--------------------------------------------------
; RxByte	; Subroutine Receives Character into R8
;			; Trashes R9
;--------------------------------------------------
#if 0
;
; Get a character from the receive queue into R8.
; If necessary, wait until the queue is not empty. Trashes R9
; NOT USED, and probably never will be
;
RxByte:
			_BEGIN

				ClearWatchdog

				call	#RxByteNoWait
			_UNTIL	_NZ
			ret
#endif

;
; Attempt to get a character from the receive queue into R8.
; If the queue is empty, return immediately with the Z status bit set.
; Trashes R9
;
RxByteNoWait:
			mov.b 	&rxRd,R9			; Get the read index into R9
			cmp.b 	&rxWr,R9			; Equal if queue empty
			_IF		_NE
				mov.b	rxBuf(R9),R8	; Read char from queue
				inc.b 	R9				; Increment the read index
				and.b 	#RxSz-1,R9		;	modulo the queue size
				mov.b 	R9,&rxRd		; Update the read index
				clrz					; Indicate char available
			_ENDIF
			ret

