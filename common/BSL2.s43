; ----------------------------------------------------------------------------
; The bootstrap loader (BSL2)
; ----------------------------------------------------------------------------
; This file is included by monitor.s43 and TestICal.s43 and other main-flash programs.
; This code will be assembled into the last main-flash segment which starts at $FE00.
; It is called directly on reset.
; It contains the reset and interrupt vectors which point to fixed locations at the end of the
; second-last main-flash segment.
; It is defined as a macro because TestICal needs to include it _twice_.
; Once at $FE00-$FFFF as expected, for when TestICal is JTAG-loaded,
; and elsewhere in main-flash for when TestICal is bootstrap-loaded,
; so that it can then be copied to $FE00-$FFFF by a 'b' command (updateBSL2).
; It's called "BSL2" because there was an earlier version BSL that we miraculously fitted in
; the 256 bytes of info-flash, along with the calibration data. The two BSLs coexisted for a time.

BSL2MACRO	MACRO	jBSL, jBSLErase, jReadByte, jWriteByte
			LOCAL	BSL, BSLErase, ReadByte, WriteByte
			LOCAL	MClock, BaudRate, BitCycles, BitCyc1_5, MckPerFTGck, initBSL2, mainLoop2
			LOCAL	resetFSM2, FSMloop2, processByte2, eraseLoop, progByte2, TestNoInterp2
			LOCAL	testNoInterp, WriteBrk, WriteBreak
			LOCAL	freeSpaceBSL2, BSL2presence, BSL2checksum
			LOCAL	TA0FllIsr
#if	REV >= 62
MClock		EQU		3686400			; MCLK (CPU clock) frequency in hertz (DCO software-locked to watch xtal)
#else
MClock		EQU		4000000			; MCLK (CPU clock) frequency in hertz (=DCOCLK/2)
#endif
BaudRate	EQU		9600			; Serial comms rate in bits per second
BitCycles	EQU		(MClock+BaudRate/2)/BaudRate	; CPU clock cycles per bit
BitCyc1_5	EQU		(MClock*3+BaudRate)/(BaudRate*2) ; CPU clock cycles per 1.5 bits
MckPerFTGck	EQU		(MClock+165000)/330000	; MCLK cycles per Flash Timing Generator cycle

#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading

; Fixed entry points to BSL2
jBSL: 		br		#BSL
jBSLErase:	br		#BSLErase
jReadByte:	br		#ReadByte
jWriteByte:	br		#WriteByte

BSL:		; Initialisation
			mov		#InitSP,SP		; Initialise the stack pointer ($300 or $400)
#if REV >= 62
			clr		&oldCCR0		; Clear this before interrupts are enabled
			; XCAP = 11, Choose 12.5 pF
			; LFXT1Sx = 00, Watch crystal (32768 kHz)
			mov.b	#XCAP1 | XCAP0, &BCSCTL3
			; SELM = 0, DCO for MCLK
			; DIVM = 0, Divide by 1 for MCLK
			; SELS = 0, DCO for SMCLK
			; DIVS = 0, Divide by 1 for SMCLK
			mov.b	#0, &BCSCTL2
			; XT2OFF = 1, Turn off non-existent oscillator. Defaults to 1 on reset
			; XTS = 0, Low frequency mode
			; DIVAx = 10, for ACLK = XIN div by 4
			; RSEL = $A, Range select guess for 3.6864 MHz
			mov.b	#XT2OFF | DIVA1 | $A, &BCSCTL1
			; DCO = 0, Frequency select guess for 3.6864 MHz
			; MOD = 4, Modulation select guess for 3.6864 MHz
			mov.b	#$80,&DCOCTL	; Initial guess DCO step + modulation for 3.6864 MHz
			; TASSSEL = 10, Use SMCLK for timer A source
			; ID = 0, Divide by 1
			; MC = 10, Continuous count mode
			; TAIE = 0, No overflow interrupt
			mov		#TASSEL1 | MC1, &TACTL
			; CM = 01, Capture on rising edge
			; CCIS = 01, Capture input = CCI0B
			; SCS = 1, synchronous capture
			; CAP = 1, Capture mode
			; CCIE = 1, enable interrupts
			mov		#CM0 | CCIS0 | SCS | CAP | CCIE, &TACCTL0

			; Use TA1 and TA1CCR0/TA1CCR1 to generate the 57.6 kHz clock on P2.1/TA1.1
			; NOTE: if this is a BMU, we will use TA1 for comms and override this
			mov		#TASSEL_2 + ID_0 + MC_1, &TA1CTL
			; Output mode 3 = set/reset: set on EQU1, reset on EQU0
			mov		#OUTMOD_3, &TA1CCTL1
			mov		#(3686400/57600)-1, &TA1CCR0 ; Sets period: want /64 (3,686,400/57,600)
			mov		#32, &TA1CCR1				; Sets duty cycle (here 50%)
			bis.b	#RelayP_Ir57k6,&P2SEL		; Set P2.1 as TA1.1
			bis.b	#RelayP_Ir57k6,&P2DIR		; and as an output

			; Initialise the UART
			bis.b	#UCSWRST,&UCA0CTL1			; Need while initialising other USCI registers
;			mov.b	#0,&UCA0CTL0			 	; UART mode, 8 bits, 1 stop bit, no parity
			; Above not needed since UCA0CTL0 defaults to 0
			mov.b	#UCSWRST | UCSSEL_2 ,&UCA0CTL1 ; Use SMCLK
			mov.b	#(MClock/9600/16)&$FF,&UCA0BR0 		; Set for 9600 b/s
			mov.b	#(MClock/9600/16)/256,&UCA0BR1
			mov.b	#UCOS16, &UCA0MCTL			; 16x oversampling mode
			bis.b	#TxMi|TxPl|Rx,&P1SEL		; Select the UART and
			bis.b	#TxMi|TxPl|Rx,&P1SEL2		;	comparator functions
			bic.b	#UCSWRST,&UCA0CTL1			; No longer resetting UCSI, clear to run
;			bic.b	#UCA0RXIE, &IE2				; Disable UART RX interrupts
			mov.b	#VrefP|PreI_TxMi|TxPl,&P1DIR ; Set VrefP, Tx bits as outputs
			bis.b	#PreI_TxMi,&TxMiPortSEL		; Select the comparator output function of P1.3
			bis.b	#PreI_TxMi,&TxMiPortSEL2	; Need both SEL bits
			; Use the Analog Comparator to get an inverted version of TxPlIn (P1.5/CA5)
			; (which is the UART TxPl looped back) to appear on TxMi (P1.3/CAOUT).
			mov.b	#CAON|CAREF_2,&CACTL1	; Half-supply to the comparator pos input and turn it on
			mov.b	#5<<3,&CACTL2			; Feed CA5 to the comparator neg input
			mov.b	#1<<5,&CAPD				; Disable the digital input buffer of P1.5 (TxPlIn)

; Need to init timer A1 to generate 57.6 kHz

			mov.w	#WDTPW+WDTHOLD,&WDTCTL		; Stop Watchdog Timer
			_DO		#0,R8						; Wait for ACLK
			_LOOP	R8							;	to stabilise
			eint								; Enable general interrupts for FLL

;			clr		&measureCount
#else
			mov.b	#DIVM_1+DIVS_3,&BCSCTL2		; Set MCLK = DCOCLK/2, SMCLK = DCOCLK/8 (watchdog)
			; Use original TI frequency calibration values, in case our values not set up or wildly bad
			mov.b	&CALBC1_8MHZ,&BCSCTL1	; Set DCO range for 8 MHz
			mov.b	&CALDCO_8MHZ,&DCOCTL	; Set DCO step + modulation for 8.00 MHz
#endif
#if REV >= 61
			mov.b	#TxPl,&P1OUT	; Set Txs to idle state, Vref output off
			bis.b	#TxPl|TxMi|VrefP,&P1DIR ; Set Txs and VrefP as outputs
	#if G2553
			mov.b	#TxMi,&P3DIR 			; Set TxMi because need comparator to invert output
											; Also done in Monitor, TestICal etc but they may not be
											;	downloaded properly
			bis.b	#TxMi,&P3SEL			; Select the comparator output function of P3.7
	#endif
#else
			mov.b	#TxMi,&P1OUT	; Set Txs to break state, (inverted) ActLed on, Vref output off
			bis.b	#TxPl|TxMi|ActLed|VrefP,&P1DIR ; Set Txs, activity LED and VrefP as outputs
#endif

			; On reset the Bypass pin is set as a crystal oscillator pin XIN
			; and the ErrLed pin is set as a crystal oscillator pin XOUT.
			; This is safe, as the bypass MOSFET has a pulldown on its gate,
			; so the BSL can avoid consuming flash space with the following code.
;			mov.b	#0,&P2SEL 		; Set Bypass and ErrLed to not be crystal osc pins
;			mov.b	#0,&P2OUT		; Set Bypass and ErrLed off
;			mov.b	#$FF,&P2DIR 	; Set Bypass and ErrLed as outputs

			; We really only want to do the following for use with monolith, where we need to
			; prevent breaks from eternally circulating around the loop.
			; So we give the monolith's IMU the ID 255 and then we're safe also doing this in an EV
			; because there cannot be any CMU after #255 anyway.

			cmp.b	#255,&infoID
			_IF		_NE				; If we're not an IMU
				; Send a 27 ms break
				#if	REV < 62
					mov.b	#$FF,R10		; Bit count 256 (terminates at -1)
					clr		R9				; Bit values (all zeros so it's a break)
				#endif
				call	#WriteBreak-jBSL+BSL2_START	; Address adjusted for BSL's relocation
			_ENDIF

			ClearWatchdog			; Clear and restart Watchdog Timer (32k)

			; Log the reason for the reset, as the contents of IFG1.
			; $A = RST pin (break), $6 = power on, $3 = watchdog, $2 = other bad stuff or JTAG.
			; It's a shame there's no way to tell a JTAG reset from a non-watchdog abnormal reset,
			; namely a flash key violation or an instruction fetch in range $0 to $1FF
			; (special function regs).

			mov			&resetCounter,R8
			and			#$0F,R8
			mov.b		&IFG1,resetBuffer(R8)
			inc			&resetCounter

mainLoop2:
			; Check for abnormal reset (watchdog, bad flash key, SFR instr fetch or JTAG reset)
			; or main program not present.
			; When JTAG debuging you need to write 4 or more to IFG1 ($0002) here,
			; to fake a normal reset.
#if 1	// Set to 1 only when JTAG debugging
	#message "Warning: BSL2 is set to ignore non-watchdog abnormal resets."
			bit.b	#WDTIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
			_IF		_Z				; If a non-watchdog abnormal reset (which may only be a JTAG reset)
				mov.b	#PORIFG,&IFG1	; Fake a Vcc power-up reset for the code below
			_ENDIF
#endif
			_COND					; Begin a short-circuit conditional
				cmp.b	#PORIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
				clr.b	&IFG1			; Clear those bits ready for next time
			_OR_ELSE	_L			; If Vcc power-up or /RST pin pulsed low Or Else
				cmp.b	#$AA,&ProgPresence ; Test for presence of main program.
			_OR_IFS		_NE			; Or If no main program
				mov.b	#WDTIFG,&IFG1	; Set watchdog int flag to indicate not to call jInterpretByte
			_ENDIF					; End short circuit conditional

			; Initialise main program, if allowed
			bit.b	#WDTIFG, &IFG1
			_IF		_Z
				call	#jInterpretInit
			_ENDIF
			; Used by TestICal or other main-flash code
			; to tell if the interpretByte call is for initialisation

resetFSM2:	mov		#4,&bsl2state	; Initialise FSM: waiting for first password character
FSMloop2:	call	#ReadByte-jBSL+BSL2_START	; Address adjusted for BSL's relocation
processByte2
			; Pass byte in R8 on to main program, if allowed
			call	#TestNoInterp2-jBSL+BSL2_START	; Adjust for relocation

			; Password-checking finite-state-machine (FSM)
			; After decrementing bsl2state below, 3 = waiting for 1st pwd char,
			; 2 = waiting for 2nd pwd char, 1 = waiting for 3rd pwd char,
			; 0 = waiting for last pwd char and erase if received,
			; any negative value = program, no interpret
			;
			dec		&bsl2state
			jn		progByte2		; If state is negative, program, don't test for password etc.

			; Check for a continuing password match $07 $06 $05 $04
			mov		&bsl2state,R9
#if PROG_START_FOR_BSL == $E000		; Changed password for 8 KiB image
			add.b	#2,R9			; Expected password character is equal to &bsl2state with 2 added
#else								; Assume non 8 KiB image
			bis.b	#4,R9			; Expected password character is equal to &bsl2state with bit 2 set
#endif
			cmp.b	R9,R8
			jne		resetFSM2
			tst		&bsl2state
			jnz		FSMloop2

			; Erase only those segments of main flash memory used for the main program, not the last.
			; Master will need to delay at least 7*16 ms = 112 ms before sending first byte to program.
			;
BSLErase:
			dint					; The main-flash program has probably turned on interrupts
									; Can't risk an interrupt while the vectors are erased
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
			mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

			mov		#PROG_START_FOR_BSL+$200,R12	; Start of program image in main flash + $200.
												; The +$200 saves a 2-word compare at the end
			; Erase
			mov		R12,R11			; R12 contains start of program image in main flash + $200
eraseLoop	mov		#FWKEY+ERASE,&FCTL1	; Enable single segment erase
			rra		-$200(R11)		; Dummy write: erase segment
			add		#$200,R11		; Increment to next segment
			jn		eraseLoop		; Stop when we wrap around to $0000

			mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled; only write-block that can't be)
			clr.b	Rcksum			; Initialise the checksum to 0

			; Assume a bad checksum, clear on good checksum.
			; Also prevents interpreting till the end of flash programming
			bis.b	#WDTIFG,&IFG1
			jmp		FSMloop2		; Read first byte to program

			; Program (flash write) byte in R8
			;
progByte2	mov.b	R8,-$200(R12)	; Program it (takes 90 microseconds)
			xor.b	R8,Rcksum		; Include in check-XOR
			inc		R12
			jnz		FSMloop2		; Repeat until R12 wraps to zero

			mov		#FWKEY,&FCTL1	; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
			tst.b	Rcksum			; Check the checksum
			jnz		resetFSM2		; If bad checksum, leave the no interpret flag set

			mov.b	#RSTIFG | OFIFG,&IFG1 ; Else clear no-interpret flag (watchdog flag), and fake a
									;  normal reset so InterpretInit and InterpretByte will be called.
			jmp		mainLoop2		; Go back to normal operation
			; end FSM code


; Call jInterpretByte, if it's safe to do so.
TestNoInterp2:
			bit.b	#WDTIFG,&IFG1	; Test no-interpret bit, due to watchdog, cksum error or programming
			_IF		_Z				; If we're interpreting
				tst.b	R8
				_IF		_L				; If data is a status byte (bit 7 set)
					mov.b	#$C1,R8			; Send status with comms error bit and bad check bit
											; $C1 to identify TestICal here, $C0 for BSL2 below
				_ENDIF

				; Echo the character if required
				_COND							; Begin short circuit conditional
					cmp.b		#$11,R8
				_OR_ELSE	_EQ					; If it's an XON (ctrl-Q) character Or Else
					bit.b	#bDontEcho,&interpFlags
				_OR_IFS		_Z					; Or If the dont-echo flag is clear
					call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
					ActLedOff						; Turn off the activity LED set in writeByte
				_ENDIF

				; We are about to jump to jInterpretByte. In case the flash is corrupted by a
				; partial download, set the watchdog timer to the shortest interval, 64 cycles
				; InterpretByte should set it back to the longest interval, 32k cycles
				mov.w	#WDTPW+WDTCNTCL+WDTIS0+WDTIS1,&WDTCTL ; Clear and enable Watchdog Timer

				; Tail-call InterpretByte in main flash. If you change this to a proper call, you also
				; need to change InterpretByte in TestICal to look one level deeper on the stack
				; when checking if this is an init call.
				; It must preserve at least R8 and bsl2state.
				; We get there via the PROG_START-independent vector "jInterpretByte".
				br		#jInterpretByte	; Tail call jInterpretByte
				; ret					; Effective ret to BSL2 init or main loop due to tail-call above
			_ELSE					; Else not interpreting
				; If we're not programming (bootstrap loading), toggle the error LED,
				; and set the comms error bit and a bad check bit on any passing status bytes,
				; since we are not calling the main program.
				tst		&bsl2state
				_IF		_NN				; If we're not programming (state not negative)
					ErrLedToggle
					tst.b	R8				; Test the character
					_IF		_L				; If the character is a status byte (bit 7 set)
						mov.b	#$C0,R8			; Send status with comms error and bad check bit, $C0
												; $C0 to identify BSL2 here, $C1 for TestICal above
					_ENDIF
				_ENDIF
				call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
				ActLedOff				; Turn off the (inverted) activity LED set in writeByte
			_ENDIF					; End if interpreting
			ret						; Return to BSL2 init or main loop


; ReadByte ( regs: -- R8 R9 R10 R11 )
; Reads a byte from serial input to R8. Trashes R9 R10 R11.
;
ReadByte:
#if	REV >= 62
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
			_BEGIN						; Loop
				bit.b	#UCA0RXIFG,&IFG2
			_UNTIL	_NZ					; Until byte received
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
			mov.b	&UCA0RXBUF,R8		; Return the received byte
			ret					; Return from ReadByte
#else
									; (Number of cycles)
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
			_BEGIN
				bit.b	#Rx,&P1IN		; (4) Start bit?
			_UNTIL	_Z					; (2) Loop until 0 (start bit)
			; The loop above takes 6 cycles so on average we will have missed the start bit by
									; (3) cycles
			push	SR				; (3) cycles
			dint					; (1) cycle
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; (5) Clear and enable the Watchdog Timer

			; Pad out the average delay between starting edge of start bit
			; and sampling of first bit below to ~ 1.5 bittimes
			mov.b	#(BitCyc1_5-21+1)/3,R11 ; (2) Loop count for waitMid delay loop
			_BEGIN
				dec		R11				; (1) Delay loop
			_UNTIL	_Z					; (2) Note: Clearing R11 here may be assumed in WriteByte below

			mov		#8,R10			; (1) Bit count
			_BEGIN
				bit.b	#Rx,&P1IN		; (4) Sampled bit to carry
				rrc.b	R8				; (1) Store received bit

				mov.b	#(BitCycles-10+1)/3,R11 ; (2) Pad RX bit loop out to one bit time
				_BEGIN
					dec		R11				; (1) Delay loop
				_UNTIL	_Z					; (2) Note: Clearing R11 here is assumed in WriteByte below
				dec		R10				; (1) All bits RXed?
			_UNTIL	_Z					; (2) Sample next bit

			; Normally there would be a 1 bit delay here so we return in the middle of the stop bit, so
			; calling ReadByte soon after returning doesn't mistake a zero in the MSB as a start bit.
			; But it's not needed, since we always send something before waiting for the next byte
			pop		SR
			ret					; Return from ReadByte
#endif


; WriteBreak ( R9 R10 -- R9 R10 R11 )
; Send a 27 ms break on the serial output. R9 must be zero and R10 must be $FF.
; Trashes R9 R10 R11.
WriteBreak:
#if	REV >= 62
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
			mov.b	#(MClock/9600/16*256/9+1)&$FF,&UCA0BR0 ; Slow baud rate to generate a 27 ms break,
			mov.b	#(MClock/9600/16*256/9+1)/256,&UCA0BR1 ; simulating the old 256 bits of 9600 b/s
			; Sending 26 consecutive breaks at 9600 b/s didn't work. It put an idle bit between them!
			mov.b	#0,&UCA0TXBUF		; Send all zero data bits
			_BEGIN						; Wait until finished sending
				bit.b	#UCBUSY,&UCA0STAT
			_UNTIL	_Z
			mov.b	#(MClock/9600/16)&$FF,&UCA0BR0 ; Restore to 9600 b/s
			mov.b	#(MClock/9600/16)/256,&UCA0BR1
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
			ret
#else
			push	SR
			dint
			jmp		WriteBrk
#endif

; WriteByte ( R8 -- R9 R10 R11 )
; Write the low byte of R8 to serial output.
; Trashes R9 R10 R11. Preserves R8.
WriteByte:
#if	REV >= 62
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
			mov.b	R8,&UCA0TXBUF		; Send byte
			_BEGIN						; Loop
				bit.b	#UCA0TXIFG,&IFG2
			_UNTIL	_NZ					; Until byte sent
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
			ret					; Return from WriteByte
#else
			clr		R11
			mov		R8,R9			; Allow R8 to be preserved for password compare

			mov.b	#8,R10			; Loop counter, 1 start + 8 data (decrements to -1)
			rla		R9				; Add the start bit
			; Stop bit was bis#1<<9,R9, but it's done after the loop now
			; to allow sending a break
			push	SR
			dint

			_BEGIN					; (Number of cycles)
				rra		R9				; (1) Next bit to C.
#if	G2553
				subc.b	#TxMi,R11		; (1) Bits 11111(1)(0)0 if C; 11111(0)(1)1 if NC
				inv.b	R11				; (1)
#else
				subc.b	#TxPl,R11		; (1) Bits 11(1)000(0)0 if C; 11(0)111(1)1 if NC
#endif
										; Note: R11 must be guaranteed clear in advance
				xor.b	&P1OUT,R11		; (3) Determine if Tx bits need toggling
#if REV >= 61
				and.b	#TxPl|TxMi,R11 ; (2) Ensure only Tx bits can be toggled below
#else
				; The activity LED has a lower bit number than TxPl so the below will
				; turn off the (inverted) activity LED when a zero bit or start bit is sent,
				; and turn it on when a one bit or stop bit is sent.
				and.b	#TxPl|ActLed|TxMi,R11 ; (2) Ensure only Tx and ActLed bits can be toggled below
#endif
				xor.b	R11,&P1OUT		; (4) Toggle as needed, to send bit

WriteBrk		mov.b	#(BitCycles-16+1)/3,R11 ; (2) Set the delay counter to pad out to one bit time
				_BEGIN
					dec		R11				; (1) Note: Clearing of R11 here is assumed by subc.b above
				_UNTIL	_Z					; (2)

				dec		R10				; (1) Decrement the bit counter
			_UNTIL	_NC				; (2) Loop until -1

#if REV >= 61
			mov.b	#TxPl,&P1OUT	; Send a stop bit
			; Harmless side-effect of turning off the Vref+ pin if it is still a digital output.
#else
			mov.b	#TxPl,&P1OUT	; Send a stop bit and leave the (inverted) ActLed on
			; Harmless side-effect of turning off the Vref+ pin if it is still a digital output.
#endif
			; To ensure the stop bit has sufficient duration we rely in the fact that
			; calls to WriteByte must be at least 2 byte-times apart
			; to allow any receiving CMU's BSL time to both read and echo the byte.
			pop		SR

			ret
#endif // REV >= 61


#if	REV >= 62
; Frequency locked loop interrupt service routine.
; Timer A0 is clocked at the DCO frequency. Its CCR0 captures the timer value on every rising edge of
; ACLK = watch_xtal / 4 = 8192 Hz, and generates this interrupt.?s
TA0FllIsr:
			tst		&oldCCR0
			_IF		_NZ
				push	R8
				mov		&TACCR0, R8		; Captured timer value at ACLK rising edge
				sub		&oldCCR0, R8	; Count of DCO clocks since previous ACLK rising edge
				sub		#MClock/(32768/4),R8 ; Expect 450 count. Calculate the error.
				sub.b	R8,&DCOCTL		; Fine adjust DCO frequency by the error amount
				pop		R8
			_ENDIF
			mov		&TACCR0, &oldCCR0 ; Save present captured timer value as old captured timer value
			xor.b	#Piezo,&PiezoPortOUT ; Toggle the piezo output
			inc		&measureCount	; Inc counter used to initiate measurement
			reti
#endif

			; Any free last-segment space is between here and the UART interrupt vectors
;freeSpaceBSL2	EQU		jBSL+$1EC - $		; Number of bytes spare in the BSL
freeSpaceBSL2	EQU		jBSL+($FFEC-BSL2_START) - $ ; Number of bytes spare in the BSL

; The end of the bootstrap loader (BSL2)
; -----------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Interrupt Vectors at the end of the last flash segment
;-------------------------------------------------------------------------------
				ORG		jBSL+($FFEC-BSL2_START)		; $FFEC, UART Vectors
				DW		jUCA0TxIsr		; UART transmit
				DW		jUCA0RxIsr		; UART receive

										; $FFF0, Timer A0 Vectors
				DW		jTA0RxTiovIsr	; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
#if	REV >= 62
				DW		TA0FllIsr		; Timer A CC0IFG (freq locked loop)
#else
				DW		jTA0TxIsr		; Timer A CC0IFG (transmit compare)
#endif
				DW		$FFFF, $FFFF	; FFF4, FFF6
										; $FFF8, Timer A1 Vectors
				DW		jTA1RxTiovIsr	; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
				DW		jTA1TxIsr		; Timer A CC0IFG (transmit compare)

										; $FFFC, Unused NMI vector location
BSL2presence	DB		$08				; No longer used. BSL1 used to check this before calling BSL2.
BSL2checksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg
				; The reset vector (at $FFFE) is set by monitor and TestICal, but could be done here.

				ENDM
