; ----------------------------------------------------------------------------
; The bootstrap loader (BSL2)
; ----------------------------------------------------------------------------
; This file is included by monitor.s43 and TestICal.s43 and other main-flash programs.
; This code will be assembled into the last main-flash segment which starts at $FC00.
; It is called directly on reset.
; It contains the reset and interrupt vectors which point to fixed locations at the end of the
; second-last main-flash segment.
; It is defined as a macro because TestICal needs to include it _twice_.
; Once at $FC00-$FFFF as expected, for when TestICal is JTAG-loaded,
; and elsewhere in main-flash for when TestICal is bootstrap-loaded,
; so that it can then be copied to $FC00-$FFFF by a 'b' command (updateBSL2).
; It's called "BSL2" because there was an earlier version BSL that we miraculously fitted in
; the 256 bytes of info-flash, along with the calibration data. The two BSLs coexisted for a time.

BSL2MACRO	MACRO	jBSL, jBSLErase, jReadByte, jWriteByte, jBslRevision, jWriteBreak
	LOCAL	BSL, BSLErase, ReadByte, WriteByte, BslRevision
	LOCAL	MckPerFTGck, TestNoInterp2, WriteBreak
	LOCAL	freeSpaceBSL2, BSL2presence, BSL2checksum
	LOCAL	ScuBaudRate, ScuBitCycles, ScuBitCyc1_5, TA0FllIsr

ScuBaudRate	EQU		9600			; SCU serial comms rate in bits per second
ScuBitCycles EQU	(MClock+BaudRate/2)/BaudRate	; CPU clock cycles per SCU bit
ScuBitCyc1_5 EQU	(MClock*3+BaudRate)/(BaudRate*2) ; CPU clock cycles per SCU 1.5 bits
MckPerFTGck	EQU		(MClock+165000)/330000	; MCLK cycles per Flash Timing Generator cycle

#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading

; Fixed entry points to BSL2
jBSL: 		br		#BSL-jBSL+BSL2_START		; Addresses of branches or calls within the BSL must be
jBSLErase:	br		#BSLErase-jBSL+BSL2_START	; adjusted so that, in both active and inactive copies,
jReadByte:	br		#ReadByte-jBSL+BSL2_START	; they are correct for the active copy, since a 'b'
jWriteByte:	br		#WriteByte-jBSL+BSL2_START	; command will copy the inactive to become the active.
jBslRevision: br	#BslRevision-jBSL+BSL2_START ; Return the BSL2 revision
jWriteBreak: br		#WriteBreak-jBSL+BSL2_START	; Send a break via the UART. Used by the 'Br' command

BSL:		; Initialisation
	mov		#InitSP,SP		; Initialise the stack pointer ($300 or $400)
	; XCAP = 11, Choose 12.5 pF
	; LFXT1Sx = 00, Watch crystal (32768 kHz)
	mov.b	#XCAP1 | XCAP0, &BCSCTL3
	; SELM = 0, DCO for MCLK
	; DIVM = 0, Divide by 1 for MCLK
	; SELS = 0, DCO for SMCLK
	; DIVS = 0, Divide by 1 for SMCLK
	mov.b	#0, &BCSCTL2
	; XT2OFF = 1, Turn off non-existent oscillator. Defaults to 1 on reset
	; XTS = 0, Low frequency mode
	; DIVAx = 11, for ACLK = XIN div by 8
	; RSEL = $A, Range select guess for 3.6864 MHz
	mov.b	#XT2OFF | DIVA_3 | $A, &BCSCTL1
	; DCO = 0, Frequency select guess for 3.6864 MHz
	; MOD = 4, Modulation select guess for 3.6864 MHz
	mov.b	#$80,&DCOCTL	; Initial guess DCO step + modulation for 3.6864 MHz
	; TASSSEL = 10, Use SMCLK for timer A source
	; ID = 0, Divide by 1
	; MC = 10, Continuous count mode
	; TAIE = 0, No overflow interrupt
	mov		#TASSEL_2 + LOG2(SMckPerTAck)*ID_1 + MC_2, &TA0CTL ; Used for FLL as well as comms
	; CM = 01, Capture on rising edge
	; CCIS = 01, Capture input = CCI0B
	; SCS = 1, synchronous capture
	; CAP = 1, Capture mode
	; CCIE = 1, enable interrupts
	mov		#CM0 | CCIS0 | SCS | CAP | CCIE, &TACCTL0

	; If this is a BMU, we will use TA1 for comms, so don't set up TA1's CCRs here
	; For CMUs, init timer A1 to generate 57.6 kHz
	cmp.b	#255,&infoID
	_IF		_NE				; If we're not a BMU
		; Use TA1 and TA1CCR0/TA1CCR1 to generate the 57.6 kHz clock on P2.1/TA1.1
		; TASSSEL = 10, Use SMCLK for timer A source
		; ID = 0, Divide by 1
		; MC = 01, Up mode, the counter counts to TACCR0
		; TAIE = 0, No overflow interrupt
		mov		#TASSEL_2 + ID_0 + MC_1, &TA1CTL
		; Output mode 3 = set/reset: set on EQU1, reset on EQU0
		mov		#OUTMOD_3, &TA1CCTL1
		mov		#(3686400/57600)-1, &TA1CCR0 ; Sets period: want /64 (3,686,400/57,600)
		mov		#32, &TA1CCR1				; Sets duty cycle (here 50%)
		bis.b	#TxMiChg2_RlyP_57k6,&P2SEL	; Set P2.1 as TA1.1
		bis.b	#TxMiChg2_RlyP_57k6,&P2DIR	; and as an output
	_ENDIF

	; Initialise the UART
	bis.b	#UCSWRST,&UCA0CTL1			; Need while initialising other USCI registers
;	mov.b	#0,&UCA0CTL0			 	; UART mode, 8 bits, 1 stop bit, no parity
	; Above not needed since UCA0CTL0 defaults to 0
	mov.b	#UCSWRST | UCSSEL_2 ,&UCA0CTL1 ; Use SMCLK
	mov.b	#(MClock/9600/16)&$FF,&UCA0BR0 		; Set for 9600 b/s
	mov.b	#(MClock/9600/16)/256,&UCA0BR1
	mov.b	#UCOS16, &UCA0MCTL			; 16x oversampling mode
	bis.b	#TxPl|Rx,&P1SEL				; Select the UART functions
	bis.b	#TxPl|Rx,&P1SEL2
	bic.b	#UCSWRST,&UCA0CTL1			; No longer resetting UCSI, clear to run
;	bic.b	#UCA0RXIE, &IE2				; Disable UART RX interrupts

	mov.w	#WDTPW+WDTHOLD,&WDTCTL		; Stop Watchdog Timer

	; Stabilise ACLK, enable interrupts, stabilise the FLL, DCO and MCLK
	_DO		#0,R8						; Allow time for the XTAL oscillator and hence ACLK to stabilise
	_LOOP	R8							;	before enabling FLL interrupts
	clr		&oldFllTime					; Avoid a clock-speed hiccup when FLL interrupts are enabled
	eint								; Enable general interrupts for FLL
	_DO		#0,R8						; Allow time for FFL interrupts to tune the DCO and hence MCLK
	_LOOP	R8							;	before interrupts get disabled in ReadByte

;	clr		&measureCount				; !!! Fix me please, Mike. Why am I here? Why am I commented out?

	; Initialise port 1
	mov.b	#TxPl,&P1OUT				; Set Txs to idle state, Vref output off
	bis.b	#Piezo|TxPl|VrefP,&P1DIR 	; Set Piezo, TxPl and VrefP as outputs

	; Initialise the interpreter flags
	clr.b	&interpFlags				; The bDontEcho bit is read by the BSL in some modes

	; We've been reset, so send a break to reset the next guy, unless we're a BMU,
	; in which case it would lead to endlessly circulating breaks.
	cmp.b	#255,&infoID
	_IF		_NE				; If we're not a BMU
		; Send a 27 ms break
		call	#WriteBreak-jBSL+BSL2_START	; Address adjusted for BSL's relocation
	_ENDIF

	ClearWatchdog			; Clear and restart the Watchdog Timer (32k)

	; Log the reason for the reset, as the contents of IFG1.
	; $08 = RST pin (break), $4 = power on, $2 = osc fault, $1 = watchdog, $0 = other bad stuff
	; $80 = UART TX interrupt flag, $40 = UART RX interrupt flag
	; or JTAG.
	; It's a shame there's no way to tell a JTAG reset from a non-watchdog abnormal reset,
	; namely a flash key violation or an instruction fetch in range $0 to $1FF
	; (special function regs).

	mov			&resetCounter,R8
	and			#$0F,R8
	mov.b		&IFG1,resetBuffer(R8)
	inc			&resetCounter
	bic.b		#OFIFG,&IFG1	; Clear the oscillator fault flag

	_BEGIN					; Main loop
		; Check for abnormal reset (watchdog, bad flash key, SFR instr fetch or JTAG reset)
		; or main program not present.
		; When JTAG debuging you need to write 4 or more to IFG1 ($0002) here,
		; to fake a normal reset.
#if 1	// Set to 1 only when JTAG debugging
#message "Warning: BSL2 is set to ignore non-watchdog abnormal resets."
		bit.b	#WDTIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
		_IF		_Z				; If a non-watchdog abnormal reset (may only be a JTAG reset)
			mov.b	#PORIFG,&IFG1	; Fake a Vcc power-up reset for the code below
		_ENDIF
#endif
		_COND					; Begin a short-circuit conditional
			cmp.b	#PORIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
			clr.b	&IFG1			; Clear those bits ready for next time
		_OR_ELSE	_L			; If Vcc power-up or /RST pin pulsed low Or Else
			cmp.b	#$AA,&ProgPresence ; Test for presence of main program.
		_OR_IFS		_NE			; Or If no main program
			mov.b	#WDTIFG,&IFG1	; Set watchdog int flag so we won't call jInterpretInit
		_ENDIF					; End short circuit conditional

		; Initialise main program, if allowed
		bit.b	#WDTIFG, &IFG1
		_IF		_Z
			call	#jInterpretInit
		_ENDIF
		; Used by TestICal or other main-flash code
		; to tell if the interpretByte call is for initialisation

		; Password checking loop
		mov		#4,&bsl2state	; Initialise FSM: waiting for first password character
		_BEGIN
			call	#ReadByte-jBSL+BSL2_START	; Wait for a byte from the appropriate port
			; Pass byte in R8 on to main program, if allowed
			call	#TestNoInterp2-jBSL+BSL2_START	; Adjusted for relocation

			; Password-checking finite-state-machine (FSM)
			; After decrementing bsl2state below, 3 = waiting for 1st pwd char,
			; 2 = waiting for 2nd pwd char, 1 = waiting for 3rd pwd char,
			; 0 = waiting for last pwd char and erase if received,
			;
			dec		&bsl2state
			; Check for a continuing password match
			_IF		_NZ					; If not the final password character
				mov		&bsl2state,R9		; Passwords are $05 $04 $03 $01-or-$02
				add		#2,R9				; Expected password char is &bsl2state plus 2
				cmp.b	R9,R8				; Check for a match
				_IF		_NE					; If not a match
					mov		#4,&bsl2state		; Go back to waiting for first password character
					;clrz						; NE = NZ. So we don't leave the password checking loop
				_ENDIF
			_ELSE						; Else the final character
				; No matter what happens now, we want to begin a new password match after we return
				mov.b	#4,&bsl2state		; Go back to waiting for first password character
				_CASE
				_OFb	#2,R8				; If matched 05 04 03 already, now 02 (rev61 password)
					; Start a fake download, reading and discarding a complete download worth of bytes
					push	R10					; Don't trash R10
					_DO		#REV61_BSL2_ST-REV61_PROG_ST,R10 ; Set count of bytes to ignore
						call	#ReadByte-jBSL+BSL2_START	; Wait for a byte from the appropriate port
						call	#WriteByte-jBSL+BSL2_START	; Echo it to the CMU port
					_LOOP 	R10
					pop		R10
					; The last byte read could look like a command char. Clear it so that it will be
					clr		R8					;	ignored by ACCEPT
					clrz						; Clear Z flag so we don't leave password checking loop
				_ENDOF						; End of fake download case
				_OFb	#1,R8				; If matched complete real download pwd 05 04 03 01
BSLErase:			; Erase segments of main flash used for the main program, not the BSL.
					; Reflash tool will need to delay at least number_of_segments * 16 ms
					; = number_of_KiB * 32 ms before sending the first byte to program.
					; Don't need to disable interrupts during flash operations,
					; because the flash controller holds the CPU.
					mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
					mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
					mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

					mov		#PROG_START_FOR_BSL,R12	; Start of program image in main flash
					; Erase
					mov		R12,R11			; R12 contains start of program image in main flash
					_BEGIN
						mov		#FWKEY+ERASE,&FCTL1	; Enable single segment erase
						push	SR				; Save the interrupt state
						dint					; Disable interrupts so the FLL can't interrupt
												;	between the erase and the clr &oldFllTime below
						rra		@R11			; Dummy write to erase segment. Takes 16 milliseconds.
						clr		&oldFllTime		; Avoid a clock-speed hiccup when the FLL interrupt is
												;	next called, because it will have missed
												;	several ACLK rising edges during the flash erase.
						pop		SR				; Restore the interrupt state
						add		#$200,R11		; Increment to next segment
						cmp		#BSL2_START,R11
					_UNTIL	_HS				; Stop when we get to the start of the BSL

					mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled)
					clr.b	Rcksum			; Initialise the checksum to 0

					; Assume a bad checksum, clear on good checksum.
					bis.b	#WDTIFG,&IFG1

					; Program using received bytes
					_BEGIN					; Programming loop
						call	#ReadByte-jBSL+BSL2_START	; Wait for a byte from the appropriate port
						call	#WriteByte-jBSL+BSL2_START	; Echo it to the CMU port
						mov.b	R8,0(R12)		; Program it. Takes 90 microseconds. No problem for FLL
						xor.b	R8,Rcksum		; Include in check-XOR
						inc		R12
						cmp		#BSL2_START,R12
					_UNTIL	_HS				; Repeat until we get to the start of the BSL

					mov		#FWKEY,&FCTL1	; Done. Clear WRT
					mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
					tst.b	Rcksum			; Check the checksum
					_IF		_Z		; If good checksum
						mov.b	#RSTIFG | OFIFG,&IFG1 ; Clear no-interpret flag (watchdog flag), and
							; fake a normal reset so InterpretInit and InterpretByte will be called.
						; And Z-flag set will cause us to leave the password checking loop below
					_ENDIF
					; Else bad checksum, so leave the no-interpret flag (watchdog flag) set,
					; and we won't leave the password checking loop.
				_ENDOF
				; Otherwise the last password byte didn't match either trunk or rev61
					clrz					; Clear Z flag so we don't leave the password checking loop
				_ENDCASE				; End of final character cases
			_ENDIF					; End else the final password character
		_UNTIL	_Z				; Until successfully programmed
	_AGAIN					; Go back to normal operation as if reset (main loop)
	; end FSM code


; Call jInterpretByte, if it's safe to do so.
TestNoInterp2:
	bit.b	#WDTIFG,&IFG1	; Test no-interpret bit, due to watchdog, cksum error or programming
	_IF		_Z				; If we're interpreting
		tst.b	R8
		_IF		_L				; If data is a status byte (bit 7 set)
			mov.b	#$C1,R8			; Send status with comms error bit and bad check bit
									; $C1 to identify TestICal here, $C0 for BSL2 below
		_ENDIF

		; Echo the character if required
		_COND							; Begin short circuit conditional
			cmp.b		#$11,R8
		_OR_ELSE	_EQ					; If it's an XON (ctrl-Q) character Or Else
			bit.b	#bDontEcho,&interpFlags
		_OR_IFS		_Z					; Or If the dont-echo flag is clear
			call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
		_ENDIF

		; We are about to jump to jInterpretByte. In case the flash is corrupted by a
		; partial download, set the watchdog timer to the shortest interval, 64 cycles
		; InterpretByte should set it back to the longest interval, 32k cycles
		mov.w	#WDTPW+WDTCNTCL+WDTIS0+WDTIS1,&WDTCTL ; Clear and enable Watchdog Timer

		; Tail-call InterpretByte in main flash. If you change this to a proper call, you also
		; need to change InterpretByte in TestICal to look one level deeper on the stack
		; when checking if this is an init call.
		; It must preserve at least R8 and bsl2state.
		; We get there via the PROG_START-independent vector "jInterpretByte".
		br		#jInterpretByte	; Tail call jInterpretByte
		; ret					; Effective ret to BSL2 init or main loop due to tail-call above
	_ELSE					; Else not interpreting (and not programming)
		; Toggle the error LED, and set the comms error bit and a bad check bit on any passing
		; status bytes, since we are not calling the main program.
		ErrLedToggle
		tst.b	R8				; Test the character
		_IF		_L				; If the character is a status byte (bit 7 set)
			mov.b	#$C0,R8			; Send status with comms error and bad check bit, $C0
									; $C0 to identify BSL2 here, $C1 for TestICal above
		_ENDIF
		call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
	_ENDIF					; End if interpreting
	ret						; Return to BSL2 init or main loop


; ReadByte ( regs: -- R8 R9 R10 R11 )
; Reads a byte from the CMU port if we're a CMU, or the SCU port if we're a BMU, to R8.
; Trashes R9 R10 R11.
;
ReadByte:
	cmp.b	#255,&infoID		; Check our ID
	_IF		_NE					; If we're a CMU
		; Wait for a byte from the CMU port -- Uses a UART, but without interrupts
		mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
		_BEGIN						; Loop
			bit.b	#UCA0RXIFG,&IFG2
		_UNTIL	_NZ					; Until byte received
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
		mov.b	&UCA0RXBUF,R8		; Return the received byte
	_ELSE						; Else we're a BMU
		; Wait for a byte from the SCU port -- Uses bit banging with timed busy-wait loops
		push	SR				; Save the interrupt state
		dint					; Disable interrupts (FLL and comms) to guarantee timings below
		mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
		_BEGIN						; Numbers in parentheses are numbers of cycles (timed waits)
			bit.b	#RxScu,&ScuPortIN ; (4) Start bit?
		_UNTIL	_Z					; (2) Loop until 0 (start bit)
		; The loop above takes 6 cycles so on average we will have missed the start bit by
								; (3) cycles
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; (5) Clear and enable the Watchdog Timer

		; Pad out the average delay between starting edge of start bit
		; and sampling of first bit below to ~ 1.5 bittimes
		mov.b	#(ScuBitCyc1_5-17+1)/3,R11 ; (2) Loop count for waitMid delay loop
		_BEGIN
			dec		R11				; (1) Delay loop
		_UNTIL	_Z					; (2)

		mov		#8,R10			; (1) Bit count
		_BEGIN
			bit.b	#RxScu,&ScuPortIN ; (4) Sampled bit to carry
			rrc.b	R8				; (1) Store received bit

			mov.b	#(ScuBitCycles-10+1)/3,R11 ; (2) Pad RX bit loop out to one bit time
			_BEGIN
				dec		R11				; (1) Delay loop
			_UNTIL	_Z					; (2) Note: Clearing R11 here is assumed in WriteByte below
			dec		R10				; (1) All bits RXed?
		_UNTIL	_Z					; (2) Sample next bit

		clr		&oldFllTime			; Avoid clock-speed hiccup when FLL interrupts are reenabled
		pop		SR					; (2) Restore the interrupt state
	_ENDIF						; End else we're a BMU
	ret							; (2) Return from ReadByte

; WriteBreak ( R9 R10 -- R9 R10 R11 )
; Send a 27 ms break on the serial output. R9 must be zero and R10 must be $FF.
; Trashes R9 R10 R11.
WriteBreak:
	mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
	mov.b	#(MClock/9600/16*256/9+1)&$FF,&UCA0BR0 ; Slow baud rate to generate a 27 ms break,
	mov.b	#(MClock/9600/16*256/9+1)/256,&UCA0BR1 ; simulating the old 256 bits of 9600 b/s
	; Sending 26 consecutive breaks at 9600 b/s didn't work. It put an idle bit between them!
	mov.b	#0,&UCA0TXBUF		; Send all zero data bits
	_BEGIN						; Wait until finished sending
		bit.b	#UCBUSY,&UCA0STAT
	_UNTIL	_Z
	mov.b	#(MClock/9600/16)&$FF,&UCA0BR0 ; Restore to 9600 b/s
	mov.b	#(MClock/9600/16)/256,&UCA0BR1
	mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
	ret

; WriteByte ( R8 -- R9 R10 R11 )
; Write the low byte of R8 to serial output.
; Trashes R9 R10 R11. Preserves R8.
WriteByte:
	mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
	mov.b	R8,&UCA0TXBUF		; Send byte
	_BEGIN						; Loop
		bit.b	#UCA0TXIFG,&IFG2
	_UNTIL	_NZ					; Until byte sent
	mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
	ret					; Return from WriteByte

; Frequency locked loop interrupt service routine.
; Timer A0 is clocked at the DCO frequency. Its CCR0 captures the timer value on every rising edge of
; ACLK = watch_xtal / 8 = 4096 Hz, and generates this interrupt.
TA0FllIsr:
	push	R8				; (3)
	mov		&oldFllTime,R8	; (3) Get the old captured timer value. Cleared before enabling interrupts
	tst		R8				; (1) Check the old captured timer value
	_IF		_NZ				; (2) If interrupts haven't just been (re-)enabled
		sub		&TACCR0,R8		; (3) Subtract the timer value captured at latest ACLK rising edge from
								; old timer value to get negative of MCLKs since prior ACLK rising edge
		add		#MClock/(32768/8),R8 ; (2) Expect -900. Calculate the error.
		rra		R8				; (1) Halve the error
		add.b	R8,&DCOCTL		; (4) Fine adjust the DCO frequency using half the error
	_ENDIF
	mov		&TACCR0,&oldFllTime	; (6) Save present captured timer value as old captured timer value
	inc		&measureCount	; (4) Increment counter used to initiate measurement
	pop		R8				; (2)
	reti					; Max 31 cycles (the interrupt call and return add another 11 cycles)
	; Note: Using more registers to reduce RAM accesses won't save any cycles
	; unless a reg is dedicated to oldFllTime, because the push/pop of the reg costs 5 cycles
	; and changing a RAM access to a reg access only saves 2 cycles.

#if 0 	// Faster version of FLL ISR. Requires a dedicated register.
// This was of interest if we needed to leave interrupts enabled during the busy-wait for a start bit
// in the bit-sniffing version of ReadByte, as used by BMUs.
TA0FllIsr:
#define	RoldFllTime R15	// The two existing users of R15 (DoMeasurement and insulationTest)
						// could replace it with R13 (= Rthd), and push and pop R13.
	push	R8				; (3)
	mov		&TACCR0,R8		; (3) Get the the timer value captured at latest ACLK rising edge
	tst		RoldFllTime		; (1) Check the old captured timer value. Cleared before enabling interrupts
	_IF		_NZ				; (2) If interrupts haven't just been (re-)enabled
		sub		R8,RoldFllTime	; (1) Subtract the timer value captured at latest ACLK rising edge from
								; old timer value to get negative of MCLKs since prior ACLK rising edge
		add		#MClock/4096,RoldFllTime ; (2) Expect -900. Calculate the error.
		rra		RoldFllTime		; (1) Halve the error
		add.b	RoldFllTime,&DCOCTL	; (4) Fine adjust the DCO frequency using half the error
	_ENDIF
	mov		R8,RoldFllTime	; (1) Save present captured timer value as old captured timer value
	inc		&measureCount	; (4) Increment counter used to initiate measurement
	pop		R8				; (2)
	reti					; Max 24 cycles (the interrupt call and return add another 11 cycles)
	; It might also be possible to move the "inc &measureCount" instruction out of the above and into
	; a timer overflow interrupt routine, which would only be called every 65,536 cycles,
	; instead of every 900 cycles like the above.
#endif

BslRevision:
	mov		#BSL_REV,R8			; Return the SVN revision for this file
	ret

	; Any free last-segment space is between here and the UART interrupt vectors
;freeSpaceBSL2	EQU		jBSL+$1EC - $		; Number of bytes spare in the BSL
freeSpaceBSL2	EQU		jBSL+($FFEC-BSL2_START) - $ ; Number of bytes spare in the BSL

; The end of the bootstrap loader (BSL2)
; -----------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Interrupt Vectors at the end of the last flash segment
;-------------------------------------------------------------------------------
		ORG		jBSL+($FFEC-BSL2_START)		; $FFEC, UART Vectors
		DW		jUCA0TxIsr		; UART transmit
		DW		jUCA0RxIsr		; UART receive

								; $FFF0, Timer A0 Vectors
		DW		jTA0TxRxIsr		; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
		DW		TA0FllIsr-jBSL+BSL2_START; Timer A CC0IFG (freq lock loop). In BSL, not main prg
		DW		$FFFF, $FFFF	; FFF4, FFF6
								; $FFF8, Timer A1 Vectors
		DW		jTA1TxRxIsr		; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
		DW		jTA1PwmIsr		; Timer A CC0IFG (transmit compare)

								; $FFFC, Unused NMI vector location
BSL2presence	DB		$08				; No longer used. BSL1 used to check this before calling BSL2.
BSL2checksum	DB		$FF				; Placeholder for checksum added by LyteFlash or SendProg
		; The reset vector (at $FFFE) is set by monitor and TestICal, but could be done here.

		ENDM
