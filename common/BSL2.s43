; ----------------------------------------------------------------------------
; The bootstrap loader (BSL2)
; ----------------------------------------------------------------------------
; This file is included by monitor.s43 and TestICal.s43 and other main-flash programs.
; This code will be assembled into the last main-flash segment which starts at $FC00.
; It is called directly on reset.
; It contains the reset and interrupt vectors which point to fixed locations at the end of the
; second-last main-flash segment.
; It is defined as a macro because TestICal needs to include it _twice_.
; Once at $FE00-$FFFF as expected, for when TestICal is JTAG-loaded,
; and elsewhere in main-flash for when TestICal is bootstrap-loaded,
; so that it can then be copied to $FE00-$FFFF by a 'b' command (updateBSL2).
; It's called "BSL2" because there was an earlier version BSL that we miraculously fitted in
; the 256 bytes of info-flash, along with the calibration data. The two BSLs coexisted for a time.

BSL2MACRO	MACRO	jBSL, jBSLErase, jReadByte, jWriteByte
			LOCAL	BSL, BSLErase, ReadByte, WriteByte
			LOCAL	MClock, BaudRate, BitCycles, BitCyc1_5, MckPerFTGck, initBSL2, mainLoop2
			LOCAL	resetFSM2, FSMloop2, processByte2, eraseLoop, progByte2, TestNoInterp2
			LOCAL	testNoInterp, WriteBrk, WriteBreak
			LOCAL	freeSpaceBSL2, BSL2presence, BSL2checksum
			LOCAL	TA0FllIsr
MClock		EQU		3686400			; MCLK (CPU clock) frequency in hertz (DCO software-locked to watch xtal)
BaudRate	EQU		9600			; Serial comms rate in bits per second
BitCycles	EQU		(MClock+BaudRate/2)/BaudRate	; CPU clock cycles per bit
BitCyc1_5	EQU		(MClock*3+BaudRate)/(BaudRate*2) ; CPU clock cycles per 1.5 bits
MckPerFTGck	EQU		(MClock+165000)/330000	; MCLK cycles per Flash Timing Generator cycle

#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading

; Fixed entry points to BSL2
jBSL: 		br		#BSL
jBSLErase:	br		#BSLErase
jReadByte:	br		#ReadByte
jWriteByte:	br		#WriteByte

BSL:		; Initialisation
			mov		#InitSP,SP		; Initialise the stack pointer ($300 or $400)
			clr		&oldCCR0		; Clear this before interrupts are enabled
			; XCAP = 11, Choose 12.5 pF
			; LFXT1Sx = 00, Watch crystal (32768 kHz)
			mov.b	#XCAP1 | XCAP0, &BCSCTL3
			; SELM = 0, DCO for MCLK
			; DIVM = 0, Divide by 1 for MCLK
			; SELS = 0, DCO for SMCLK
			; DIVS = 0, Divide by 1 for SMCLK
			mov.b	#0, &BCSCTL2
			; XT2OFF = 1, Turn off non-existent oscillator. Defaults to 1 on reset
			; XTS = 0, Low frequency mode
			; DIVAx = 11, for ACLK = XIN div by 8
			; RSEL = $A, Range select guess for 3.6864 MHz
			mov.b	#XT2OFF | DIVA_3 | $A, &BCSCTL1
			; DCO = 0, Frequency select guess for 3.6864 MHz
			; MOD = 4, Modulation select guess for 3.6864 MHz
			mov.b	#$80,&DCOCTL	; Initial guess DCO step + modulation for 3.6864 MHz
			; TASSSEL = 10, Use SMCLK for timer A source
			; ID = 0, Divide by 1
			; MC = 10, Continuous count mode
			; TAIE = 0, No overflow interrupt
			mov		#TASSEL1 | ID_0 | MC_2, &TA0CTL
			; CM = 01, Capture on rising edge
			; CCIS = 01, Capture input = CCI0B
			; SCS = 1, synchronous capture
			; CAP = 1, Capture mode
			; CCIE = 1, enable interrupts
			mov		#CM0 | CCIS0 | SCS | CAP | CCIE, &TACCTL0

			; If this is a BMU, we will use TA1 for comms, so don't set up TA1's CCRs here
			cmp.b	#255,&infoID
			_IF		_NE				; If we're not a BMU
				; Use TA1 and TA1CCR0/TA1CCR1 to generate the 57.6 kHz clock on P2.1/TA1.1
				; TASSSEL = 10, Use SMCLK for timer A source
				; ID = 0, Divide by 1
				; MC = 01, Up mode, the counter counts to TACCR0
				; TAIE = 0, No overflow interrupt
				mov		#TASSEL_2 + ID_0 + MC_1, &TA1CTL
				; Output mode 3 = set/reset: set on EQU1, reset on EQU0
				mov		#OUTMOD_3, &TA1CCTL1
				mov		#(3686400/57600)-1, &TA1CCR0 ; Sets period: want /64 (3,686,400/57,600)
				mov		#32, &TA1CCR1				; Sets duty cycle (here 50%)
				bis.b	#RelayP_57k6,&P2SEL			; Set P2.1 as TA1.1
				bis.b	#RelayP_57k6,&P2DIR			; and as an output
			_ENDIF

			; Initialise the UART
			bis.b	#UCSWRST,&UCA0CTL1			; Need while initialising other USCI registers
;			mov.b	#0,&UCA0CTL0			 	; UART mode, 8 bits, 1 stop bit, no parity
			; Above not needed since UCA0CTL0 defaults to 0
			mov.b	#UCSWRST | UCSSEL_2 ,&UCA0CTL1 ; Use SMCLK
			mov.b	#(MClock/9600/16)&$FF,&UCA0BR0 		; Set for 9600 b/s
			mov.b	#(MClock/9600/16)/256,&UCA0BR1
			mov.b	#UCOS16, &UCA0MCTL			; 16x oversampling mode
			bis.b	#TxPl|Rx,&P1SEL				; Select the UART functions
			bis.b	#TxPl|Rx,&P1SEL2
			bic.b	#UCSWRST,&UCA0CTL1			; No longer resetting UCSI, clear to run
;			bic.b	#UCA0RXIE, &IE2				; Disable UART RX interrupts

; Need to init timer A1 to generate 57.6 kHz

			mov.w	#WDTPW+WDTHOLD,&WDTCTL		; Stop Watchdog Timer
			_DO		#0,R8						; Wait for ACLK
			_LOOP	R8							;	to stabilise
			eint								; Enable general interrupts for FLL

;			clr		&measureCount
			mov.b	#TxPl,&P1OUT				; Set Txs to idle state, Vref output off
			bis.b	#Piezo|TxPl|VrefP,&P1DIR 	; Set Piezo, TxPl and VrefP as outputs

			; We've been reset, so send a break to reset the next guy, unless we're a BMU,
			; (or the IMU in the Helidon Monolith), in which case it would lead to
			; endlessly circulating breaks. We give these devices the ID 255.

			cmp.b	#255,&infoID
			_IF		_NE				; If we're not a BMU
				; Send a 27 ms break
				call	#WriteBreak-jBSL+BSL2_START	; Address adjusted for BSL's relocation
			_ENDIF

			ClearWatchdog			; Clear and restart the Watchdog Timer (32k)

			; Log the reason for the reset, as the contents of IFG1.
			; $A = RST pin (break), $6 = power on, $3 = watchdog, $2 = other bad stuff or JTAG.
			; It's a shame there's no way to tell a JTAG reset from a non-watchdog abnormal reset,
			; namely a flash key violation or an instruction fetch in range $0 to $1FF
			; (special function regs).

			mov			&resetCounter,R8
			and			#$0F,R8
			mov.b		&IFG1,resetBuffer(R8)
			inc			&resetCounter

mainLoop2:
			; Check for abnormal reset (watchdog, bad flash key, SFR instr fetch or JTAG reset)
			; or main program not present.
			; When JTAG debuging you need to write 4 or more to IFG1 ($0002) here,
			; to fake a normal reset.
#if 1	// Set to 1 only when JTAG debugging
	#message "Warning: BSL2 is set to ignore non-watchdog abnormal resets."
			bit.b	#WDTIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
			_IF		_Z				; If a non-watchdog abnormal reset (which may only be a JTAG reset)
				mov.b	#PORIFG,&IFG1	; Fake a Vcc power-up reset for the code below
			_ENDIF
#endif
			_COND					; Begin a short-circuit conditional
				cmp.b	#PORIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
				clr.b	&IFG1			; Clear those bits ready for next time
			_OR_ELSE	_L			; If Vcc power-up or /RST pin pulsed low Or Else
				cmp.b	#$AA,&ProgPresence ; Test for presence of main program.
			_OR_IFS		_NE			; Or If no main program
				mov.b	#WDTIFG,&IFG1	; Set watchdog int flag to indicate not to call jInterpretByte
			_ENDIF					; End short circuit conditional

			; Initialise main program, if allowed
			bit.b	#WDTIFG, &IFG1
			_IF		_Z
				call	#jInterpretInit
			_ENDIF
			; Used by TestICal or other main-flash code
			; to tell if the interpretByte call is for initialisation

resetFSM2:	mov		#4,&bsl2state	; Initialise FSM: waiting for first password character
FSMloop2:	call	#ReadByte-jBSL+BSL2_START	; Address adjusted for BSL's relocation
processByte2
			; Pass byte in R8 on to main program, if allowed
			call	#TestNoInterp2-jBSL+BSL2_START	; Adjust for relocation

			; Password-checking finite-state-machine (FSM)
			; After decrementing bsl2state below, 3 = waiting for 1st pwd char,
			; 2 = waiting for 2nd pwd char, 1 = waiting for 3rd pwd char,
			; 0 = waiting for last pwd char and erase if received,
			; any negative value = program, no interpret
			;
			dec		&bsl2state
			jn		progByte2		; If state is negative, program, don't test for password etc.

			; Check for a continuing password match $07 $06 $05 $04
			mov		&bsl2state,R9
			add.b	#2,R9			; Expected password character is equal to &bsl2state with 2 added
			cmp.b	R9,R8
			jne		resetFSM2
			tst		&bsl2state
			jnz		FSMloop2

			; Erase only those segments of main flash memory used for the main program, not the last.
			; Master will need to delay at least 7*16 ms = 112 ms before sending first byte to program.
			;
BSLErase:
			dint					; The main-flash program has probably turned on interrupts
									; Can't risk an interrupt while the vectors are erased
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
			mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

			mov		#PROG_START_FOR_BSL,R12	; Start of program image in main flash
			; Erase
			mov		R12,R11			; R12 contains start of program image in main flash
eraseLoop	mov		#FWKEY+ERASE,&FCTL1	; Enable single segment erase
			rra		@R11			; Dummy write: erase segment
			add		#$200,R11		; Increment to next segment
			cmp		#BSL2_START,R11
			jlo		eraseLoop		; Stop when we get to the start of the BSL

			mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled; only write-block that can't be)
			clr.b	Rcksum			; Initialise the checksum to 0

			; Assume a bad checksum, clear on good checksum.
			; Also prevents interpreting till the end of flash programming
			bis.b	#WDTIFG,&IFG1
			jmp		FSMloop2		; Read first byte to program

			; Program (flash write) byte in R8
			;
progByte2	mov.b	R8,0(R12)		; Program it (takes 90 microseconds)
			xor.b	R8,Rcksum		; Include in check-XOR
			inc		R12
			cmp		#BSL2_START,R12
			jlo		FSMloop2		; Repeat until we get to the start of the BSL

			mov		#FWKEY,&FCTL1	; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
			tst.b	Rcksum			; Check the checksum
			jnz		resetFSM2		; If bad checksum, leave the no interpret flag set

			mov.b	#RSTIFG | OFIFG,&IFG1 ; Else clear no-interpret flag (watchdog flag), and fake a
									;  normal reset so InterpretInit and InterpretByte will be called.
			jmp		mainLoop2		; Go back to normal operation
			; end FSM code


; Call jInterpretByte, if it's safe to do so.
TestNoInterp2:
			bit.b	#WDTIFG,&IFG1	; Test no-interpret bit, due to watchdog, cksum error or programming
			_IF		_Z				; If we're interpreting
				tst.b	R8
				_IF		_L				; If data is a status byte (bit 7 set)
					mov.b	#$C1,R8			; Send status with comms error bit and bad check bit
											; $C1 to identify TestICal here, $C0 for BSL2 below
				_ENDIF

				; Echo the character if required
				_COND							; Begin short circuit conditional
					cmp.b		#$11,R8
				_OR_ELSE	_EQ					; If it's an XON (ctrl-Q) character Or Else
					bit.b	#bDontEcho,&interpFlags
				_OR_IFS		_Z					; Or If the dont-echo flag is clear
					call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
				_ENDIF

				; We are about to jump to jInterpretByte. In case the flash is corrupted by a
				; partial download, set the watchdog timer to the shortest interval, 64 cycles
				; InterpretByte should set it back to the longest interval, 32k cycles
				mov.w	#WDTPW+WDTCNTCL+WDTIS0+WDTIS1,&WDTCTL ; Clear and enable Watchdog Timer

				; Tail-call InterpretByte in main flash. If you change this to a proper call, you also
				; need to change InterpretByte in TestICal to look one level deeper on the stack
				; when checking if this is an init call.
				; It must preserve at least R8 and bsl2state.
				; We get there via the PROG_START-independent vector "jInterpretByte".
				br		#jInterpretByte	; Tail call jInterpretByte
				; ret					; Effective ret to BSL2 init or main loop due to tail-call above
			_ELSE					; Else not interpreting
				; If we're not programming (bootstrap loading), toggle the error LED,
				; and set the comms error bit and a bad check bit on any passing status bytes,
				; since we are not calling the main program.
				cmp		#1,&bsl2state
				_IF		_GE				; If we're not programming (state >= 1)
					ErrLedToggle
					tst.b	R8				; Test the character
					_IF		_L				; If the character is a status byte (bit 7 set)
						mov.b	#$C0,R8			; Send status with comms error and bad check bit, $C0
												; $C0 to identify BSL2 here, $C1 for TestICal above
					_ENDIF
				_ENDIF
				call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
			_ENDIF					; End if interpreting
			ret						; Return to BSL2 init or main loop


; ReadByte ( regs: -- R8 R9 R10 R11 )
; Reads a byte from serial input to R8. Trashes R9 R10 R11.
;
ReadByte:
		mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
		_BEGIN						; Loop
			bit.b	#UCA0RXIFG,&IFG2
		_UNTIL	_NZ					; Until byte received
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
		mov.b	&UCA0RXBUF,R8		; Return the received byte
		ret					; Return from ReadByte


; WriteBreak ( R9 R10 -- R9 R10 R11 )
; Send a 27 ms break on the serial output. R9 must be zero and R10 must be $FF.
; Trashes R9 R10 R11.
WriteBreak:
		mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
		mov.b	#(MClock/9600/16*256/9+1)&$FF,&UCA0BR0 ; Slow baud rate to generate a 27 ms break,
		mov.b	#(MClock/9600/16*256/9+1)/256,&UCA0BR1 ; simulating the old 256 bits of 9600 b/s
		; Sending 26 consecutive breaks at 9600 b/s didn't work. It put an idle bit between them!
		mov.b	#0,&UCA0TXBUF		; Send all zero data bits
		_BEGIN						; Wait until finished sending
			bit.b	#UCBUSY,&UCA0STAT
		_UNTIL	_Z
		mov.b	#(MClock/9600/16)&$FF,&UCA0BR0 ; Restore to 9600 b/s
		mov.b	#(MClock/9600/16)/256,&UCA0BR1
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
		ret

; WriteByte ( R8 -- R9 R10 R11 )
; Write the low byte of R8 to serial output.
; Trashes R9 R10 R11. Preserves R8.
WriteByte:
		mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
		mov.b	R8,&UCA0TXBUF		; Send byte
		_BEGIN						; Loop
			bit.b	#UCA0TXIFG,&IFG2
		_UNTIL	_NZ					; Until byte sent
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable the Watchdog Timer
		ret					; Return from WriteByte

; Frequency locked loop interrupt service routine.
; Timer A0 is clocked at the DCO frequency. Its CCR0 captures the timer value on every rising edge of
; ACLK = watch_xtal / 8 = 4096 Hz, and generates this interrupt.
TA0FllIsr:
			tst		&oldCCR0
			_IF		_NZ
				push	R8
				mov		&TACCR0, R8		; Captured timer value at ACLK rising edge
				sub		&oldCCR0, R8	; Count of DCO clocks since previous ACLK rising edge
				sub		#MClock/(32768/8),R8 ; Expect 900 count. Calculate the error.
				rra		R8
				sub.b	R8,&DCOCTL		; Fine adjust DCO frequency by half the error amount
				pop		R8
			_ENDIF
			mov		&TACCR0, &oldCCR0 ; Save present captured timer value as old captured timer value
			inc		&measureCount	; Inc counter used to initiate measurement
			reti

			; Any free last-segment space is between here and the UART interrupt vectors
;freeSpaceBSL2	EQU		jBSL+$1EC - $		; Number of bytes spare in the BSL
freeSpaceBSL2	EQU		jBSL+($FFEC-BSL2_START) - $ ; Number of bytes spare in the BSL

; The end of the bootstrap loader (BSL2)
; -----------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Interrupt Vectors at the end of the last flash segment
;-------------------------------------------------------------------------------
				ORG		jBSL+($FFEC-BSL2_START)		; $FFEC, UART Vectors
				DW		jUCA0TxIsr		; UART transmit
				DW		jUCA0RxIsr		; UART receive

										; $FFF0, Timer A0 Vectors
				DW		jTA0TxRxIsr		; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
				DW		TA0FllIsr		; Timer A CC0IFG (freq locked loop). In BSL, not main program.
				DW		$FFFF, $FFFF	; FFF4, FFF6
										; $FFF8, Timer A1 Vectors
				DW		jTA1TxRxIsr		; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
				DW		jTA1PwmIsr		; Timer A CC0IFG (transmit compare)

										; $FFFC, Unused NMI vector location
BSL2presence	DB		$08				; No longer used. BSL1 used to check this before calling BSL2.
BSL2checksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg
				; The reset vector (at $FFFE) is set by monitor and TestICal, but could be done here.

				ENDM
