; ----------------------------------------------------------------------------
; The second bootstrap loader (BSL2)
; ----------------------------------------------------------------------------
; This file is included by monitor.s43 and TestICal.s43.
; This code will be assembled into the last main-flash segment which starts at $FE00.
; It is called directly on reset.
; It contains the reset and interrupt vectors which point to fixed locations at the end of the
; second-last main-flash segment.
; It is defined as a macro because TestICal needs to include it _twice_.
; Once at $FE00-$FFFF as expected, for when TestICal is JTAG-loaded,
; and elsewhere in main-flash for when TestICal is bootstrap-loaded,
; so that it can then be copied to $FE00-$FFFF by a 'b' command (updateBSL2).

BSL2MACRO	MACRO	initRetAddr2, BSLErase2, ReadByte, WriteByte
			LOCAL	BSL2, MClock, BaudRate, BitCycles, BitCyc1_5, MckPerFTGck, initBSL2, mainLoop2
			LOCAL	resetFSM2, FSMloop2, processByte2, eraseLoop, progByte2, testNoInterp2
			LOCAL	testNoInterp, WriteBreak
			LOCAL	freeSpaceBSL2, BSL2presence, BSL2checksum

MClock		EQU		4000000			; MCLK (CPU clock) frequency in hertz (=DCOCLK/2)
BaudRate	EQU		9600			; Serial comms rate in bits per second
BitCycles	EQU		(MClock+BaudRate/2)/BaudRate	; CPU clock cycles per bit
BitCyc1_5	EQU		(MClock*3+BaudRate)/(BaudRate*2) ; CPU clock cycles per 1.5 bits
MckPerFTGck	EQU		(MClock+165000)/330000	; MCLK cycles per Flash Timing Generator cycle

#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading

;			ORG		$FE00			; Start of the last 512 byte flash segment
BSL2:		; Initialisation
			mov.b	#DIVM_1+DIVS_3,&BCSCTL2		; Set MCLK = DCOCLK/2, SMCLK = DCOCLK/8 (watchdog)
			mov.b	&info8MHzCalB,&BCSCTL1	; Set DCO range for 8 MHz
			mov.b	&info8MHzCalD,&DCOCTL	; Set DCO step + modulation for 8.00 MHz
#if REV61
			mov.b	#TXDm,&P1OUT	; Set TXDs to break state, Vref output off
			bis.b	#TXDp|TXDm|VREFp,&P1DIR ; Set TXDs and VREFp as outputs
#else
			mov.b	#TXDm,&P1OUT	; Set TXDs to break state, (inverted) ACTLED on, Vref output off
			bis.b	#TXDp|TXDm|ACTLED|VREFp,&P1DIR ; Set TXDs, activity LED and VREFp as outputs
#endif
			mov		#$300,SP		; Initialise the stack pointer

			; On reset the BYPASS pin is set as a crystal oscillator pin XIN
			; and the ERRLED pin is set as a crystal oscillator pin XOUT.
			; This is safe, as the bypass MOSFET has a pulldown on its gate,
			; so the BSL can avoid consuming flash space with the following code.
;			mov.b	#0,&P2SEL 		; Set BYPASS and ERRLED to not be crystal osc pins
;			mov.b	#0,&P2OUT		; Set BYPASS and ERRLED off
;			mov.b	#$FF,&P2DIR 	; Set BYPASS and ERRLED as outputs

			; Send a 27 ms break
			mov.b	#$FF,R10		; Bit count 256 (terminates at -1)
			clr		R9				; Bit values (all zeros so it's a break)
			call	#WriteBreak-BSL2+$FE00 ; WriteByte without init part and w/o needing R11 clear
									; Address adjusted for BSL's relocation
			; End of the initialisation that used to be in BSL1 in info-flash.

			ClearWatchdog			; Clear and restart Watchdog Timer (32k)
#if 0
			; Check to see if this is an init call (from BSL1)
			cmp		#infoInitRetAddr,0(SP)	; Is the call merely for initialisation?
			_IF		_EQ				; If for initialisation, initialise, and return
				call	#initBSL2-BSL2+$FE00	; Adjust for relocation
				ret						; Return to BSL1
			_ENDIF					; Endif call is for initialisation
			jmp		processByte2	; Skip over the init routine below
#endif

			; Log the reason for the reset, as the contents of IFG1.
			; $A = RST pin (break), $6 = power on, $3 = watchdog, $2 = other bad stuff or JTAG.
			; It's a shame there's no way to tell a JTAG reset from a non-watchdog abnormal reset, namely
			; a flash key violation or an instruction fetch in range $0 to $1FF (special function regs).

			mov			&resetCounter,R8
			and			#$0F,R8
			mov.b		&IFG1,resetBuffer(R8)
			inc			&resetCounter

mainLoop2:
			; Check for abnormal reset (watchdog, bad flash key, SFR instr fetch or JTAG reset)
			; or main program not present.
			; When JTAG debuging you need to write 4 or more to IFG1 ($0002) here, to fake a normal reset.
#if 1	// Set to 1 only when JTAG debugging
	#message "Warning: BSL2 is set to ignore non-watchdog abnormal resets."
			bit.b	#WDTIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
			_IF		_Z				; If a non-watchdog abnormal reset (which may only be a JTAG reset)
				mov.b	#PORIFG,&IFG1	; Fake a Vcc power-up reset for the code below
			_ENDIF
#endif
			_COND					; Begin a short-circuit conditional
				cmp.b	#PORIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
				clr.b	&IFG1			; Clear those bits ready for next time
			_OR_ELSE	_L			; If Vcc power-up or /RST pin pulsed low Or Else
				cmp.b	#$AA,&ProgPresence ; Test for presence of main program.
			_OR_IFS		_NE			; Or If no main program
				mov.b	#WDTIFG,&IFG1	; Set watchdog int flag to indicate not to call jInterpretByte
			_ENDIF					; End short circuit conditional

			; Pass initialisation on to main program, if allowed
			clr.b	R8				; A null to pass to interpretByte (if allowed)
			call	#testNoInterp2-BSL2+$FE00	; Adjust for relocation
initRetAddr2:	; Used by TestICal or other main-flash code
			; to tell if the interpretByte call is for initialisation

resetFSM2:	mov		#4,&bsl2state	; Initialise FSM: waiting for first password character
FSMloop2:	call	#ReadByte-BSL2+$FE00	; Address adjusted for BSL's relocation
processByte2
			; Pass byte in R8 on to main program, if allowed
			call	#testNoInterp2-BSL2+$FE00	; Adjust for relocation

			; Password-checking finite-state-machine (FSM)
			; After decrementing bsl2state below, 3 = waiting for 1st pwd char,
			; 2 = waiting for 2nd pwd char, 1 = waiting for 3rd pwd char,
			; 0 = waiting for last pwd char and erase if received,
			; any negative value = program, no interpret
			;
			dec		&bsl2state
			jn		progByte2		; If state is negative, program, don't test for password etc.

			; Check for a continuing password match $07 $06 $05 $04
			mov		&bsl2state,R9
#if PROG_START_FOR_BSL == $E000		; Changed password for 8 KiB image
			add.b	#2,R9			; Expected password character is equal to &bsl2state with 2 added
#else								; Assume non 8 KiB image
			bis.b	#4,R9			; Expected password character is equal to &bsl2state with bit 2 set
#endif
			cmp.b	R9,R8
			jne		resetFSM2
			tst		&bsl2state
			jnz		FSMloop2

			; Erase only those segments of main flash memory used for the main program, not the last.
			; Master will need to delay at least 7*16 ms = 112 ms before sending first byte to program.
			;
BSLErase2:
			dint					; The main-flash program has probably turned on interrupts
									; Can't risk an interrupt while the vectors are erased
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
			mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

			mov		#PROG_START_FOR_BSL+$200,R12	; Start of program image in main flash + $200.
												; The +$200 saves a 2-word compare at the end
			; Erase
			mov		R12,R11			; R12 contains start of program image in main flash + $200
eraseLoop	mov		#FWKEY+ERASE,&FCTL1	; Enable single segment erase
			rra		-$200(R11)		; Dummy write: erase segment
			add		#$200,R11		; Increment to next segment
			jn		eraseLoop		; Stop when we wrap around to $0000

			mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled; only write-block that can't be)
			clr.b	Rcksum			; Initialise the checksum to 0

			; Assume a bad checksum, clear on good checksum.
			; Also prevents interpreting till the end of flash programming
			bis.b	#WDTIFG,&IFG1 ; FIXME: MOVE ME EARLIER?
			jmp		FSMloop2		; Read first byte to program

			; Program (flash write) byte in R8
			;
progByte2	mov.b	R8,-$200(R12)	; Program it (takes 90 microseconds)
			xor.b	R8,Rcksum		; Include in check-XOR
			inc		R12
			jnz		FSMloop2		; Repeat until R12 wraps to zero

			mov		#FWKEY,&FCTL1	; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
			tst.b	Rcksum			; Check the checksum
			jnz		resetFSM2		; If bad checksum, leave the no interpret flag set

			mov.b	#RSTIFG | OFIFG,&IFG1	; Good checksum, reset no interpret flag (watchdog flag),
									;	fake a normal reset so BSL2 will call interpretByte
		; FIXME: need to call interpretByte with 00 for initialisation. Dave says may not want above
			jmp		mainLoop2		; Back to looking for password,
									; but first make init call to jInterpretByte
			; end FSM code

testNoInterp2:
			bit.b	#WDTIFG,&IFG1	; Test no-interpret bit, due to watchdog, cksum error or programming
			_IF		_Z				; If we're interpreting
				tst.b	R8
				_IF		_L				; If data is a status byte (bit 7 set)
					mov.b	#$C1,R8			; Send status with comms error bit and bad check bit
											; $C1 to identify TestICal here, $C0 for BSL2 below
				_ENDIF

				; Echo the character if required
				_COND							; Begin short circuit conditional
					cmp.b		#$11,R8
				_OR_ELSE	_EQ					; If it's an XON (ctrl-Q) character Or Else
					bit.b	#bDontEcho,&intFlags
				_OR_IFS		_Z					; Or If the dont-echo flag is clear
					call	#WriteByte-BSL2+$FE00	; Echo. Call address adjusted for relocation						ActLedOff						; Turn off the activity LED set in writeByte
					ActLedOff						; Turn off the activity LED set in writeByte
				_ENDIF

				; We are about to jump to $FFF8 to interpretByte. In case the flash is corrupted by a
				; partial download, set the watchdog timer to the shortest interval, 64 cycles
				; InterpretByte should set it back to the longest interval, 32k cycles
				mov.w	#WDTPW+WDTCNTCL+WDTIS0+WDTIS1,&WDTCTL ; Clear and enable Watchdog Timer

				; Tail-call interpretByte in main flash. If you change this to a proper call, you also
				; need to change interpretByte in TestICal to look one level deeper on the stack
				; when checking if this is an init call.
				; It must preserve at least R8 and bsl2state.
				; We get there via the PROG_START-independent vector "jInterpretByte".
				br		#jInterpretByte
				; ret					; Effective ret to BSL2 init or main loop due to tail-call above
			_ELSE					; Else not interpreting
				; If we're not programming (bootstrap loading), set comms error bit and a bad check bit
				; on any passing status bytes, since we are not calling the main program
				tst		&bsl2state
				_IF		_NN				; If we're not programming (state not negative)
					tst.b	R8
					_IF		_L				; If data is a status byte (bit 7 set)
						mov.b	#$C0,R8			; Send status with comms error bit and bad check bit, $C0
												; $C0 to identify BSL2 here, $C1 for TestICal above
					_ENDIF
				_ENDIF
				call	#WriteByte-BSL2+$FE00	; Echo. Call address adjusted for relocation
				ActLedOff				; Turn off the (inverted) activity LED set in writeByte
			_ENDIF					; End if interpreting
			ret						; Return to BSL2 init or main loop


; ReadByte ( regs: -- R8 R9 R10 R11 )
; Reads a byte from serial input to R8. Trashes R9 R10 R11.
; Also echoes the byte to serial output (either by falling through to WriteByte, or calling
;	interpretByte)
;
ReadByte:
									; (Number of cycles)
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; (5) Hold the Watchdog Timer
			_BEGIN
				bit.b	#RXD,&P1IN		; (4) Start bit?
			_UNTIL	_Z					; (2) Loop until 0 (start bit)
			; The loop above takes 6 cycles so on average we will have missed the start bit by
									; (3) cycles
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; (5) Clear and enable the Watchdog Timer

			; Pad out the average delay between starting edge of start bit
			; and sampling of first bit below to ~ 1.5 bittimes
			mov.b	#(BitCyc1_5-17+1)/3,R11 ; (2) Loop count for waitMid delay loop
			_BEGIN
				dec		R11				; (1) Delay loop
			_UNTIL	_Z					; (2) Note: Clearing R11 here may be assumed in WriteByte below

			mov		#8,R10			; (1) Bit count
			_BEGIN
				bit.b	#RXD,&P1IN		; (4) Sampled bit to carry
				rrc.b	R8				; (1) Store received bit

				mov.b	#(BitCycles-10+1)/3,R11 ; (2) Pad RX_bit loop out to one bit time
				_BEGIN
					dec		R11				; (1) Delay loop
				_UNTIL	_Z					; (2) Note: Clearing R11 here is assumed in WriteByte below
				dec		R10				; (1) All bits RXed?
			_UNTIL	_Z					; (2) Sample next bit

			; Normally there would be a 1 bit delay here so we return in the middle of the stop bit, so
			; calling ReadByte soon after returning doesn't mistake a zero in the MSB as a start bit.
			; But it's not needed, since we always send something before waiting for the next byte

			ret					; Return from ReadByte


; WriteByte ( R8 -- R9 R10 R11 )
; Write the low byte of R8 to serial output.
; Trashes R9 R10 R11. Preserves R8.
;
; WriteBreak ( R9 R10 -- R9 R10 R11 ) (an alternative entry point into WriteByte)
; Send a 27 ms break on the serial output. R9 must be zero and R10 must be $FF.
; Trashes R9 R10 R11.

WriteByte:
			clr		R11
			mov		R8,R9			; Allow R8 to be preserved for password compare

			mov.b	#8,R10			; Loop counter, 1 start + 8 data (decrements to -1)
			rla		R9				; Add the start bit
			; Stop bit was bis#1<<9,R9, but it's done after the loop now
			; to allow sending a break

			_BEGIN					; (Number of cycles)
				rra		R9				; (1) Next bit to C.
				subc.b	#TXDp,R11		; (1) Bits 11(1)000(0)0 if C; 11(0)111(1)1 if NC
										; Note: R11 must be guaranteed clear in advance
				xor.b	&P1OUT,R11		; (3) Determine if TXD bits need toggling
#if REV61
				and.b	#TXDp|TXDm,R11 ; (2) Ensure only TXD bits can be toggled below
#else
				; The activity LED has a lower bit number than TXDp so the below will
				; turn off the (inverted) activity LED when a zero bit or start bit is sent,
				; and turn it on when a one bit or stop bit is sent.
				and.b	#TXDp|ACTLED|TXDm,R11 ; (2) Ensure only TXD and ACTLED bits can be toggled below
#endif
				xor.b	R11,&P1OUT		; (4) Toggle as needed, to send bit

WriteBreak:		mov.b	#(BitCycles-16+1)/3,R11 ; (2) Set the delay counter to pad out to one bit time
				_BEGIN
					dec		R11				; (1) Note: Clearing of R11 here is assumed by subc.b above
				_UNTIL	_Z					; (2)

				dec		R10				; (1) Decrement the bit counter
			_UNTIL	_NC				; (2) Loop until -1

#if REV61
			mov.b	#TXDp,&P1OUT	; Send a stop bit
			; Harmless side-effect of turning off the Vref+ pin if it is still a digital output.
#else
			mov.b	#TXDp,&P1OUT	; Send a stop bit and leave the (inverted) ACTLED on
			; Harmless side-effect of turning off the Vref+ pin if it is still a digital output.
#endif
			; To ensure the stop bit has sufficient duration we rely in the fact that
			; calls to WriteByte must be at least 2 byte-times apart
			; to allow any receiving CMU's BSL time to both read and echo the byte.
			ret

			; Any free last segment space is between here and the timer-A interrupt vectors
freeSpaceBSL2	EQU		BSL2+$1F0 - $		; Number of bytes spare in the second BSL

; The end of the second bootstrap loader (BSL2)
; -----------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Interrupt Vectors at the end of the last flash segment
;-------------------------------------------------------------------------------

				ORG		BSL2+$1F0		; $FFF0, Timer A Vectors
				DW		jRX_TIOV_ISR	; Combined CC1IFG (receive capture/compare) & TAIFG (overflow)
				DW		jTX_ISR			; Timer A CC0IFG (transmit compare)

				ORG		BSL2+$1F8		; $FFF8
				br		#BSL2			; No longer used. Was so it still worked with an old BSL1.

				ORG		BSL2+$1FC		; $FFFC, Unused NMI vector location
BSL2presence	DB		$08				; No longer used. BSL1 used to check this before calling BSL2.
BSL2checksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg
				; The reset vector (at $FFFE) is set by monitor and TestICal, but could be done here.

				ENDM
