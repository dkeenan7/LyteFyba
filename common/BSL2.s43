;
; Branch: Rev61
; CMUs and IMUs use MSP430G2452 microcontroller, BMUs use MSP430G2553.
; As used in Mike's solar (24 V and 48 V), Helidon off-grid solar power system (CMUs only),
; Kingscliff Demand Charge Management system, Kingscliff off-grid solar power system.
; The Helidon BMU is really a modified IMU and so its code is in the Rev58 branch.
;
; ----------------------------------------------------------------------------
; The bootstrap loader (BSL2)
; ----------------------------------------------------------------------------
; This file is included by monitor.s43 and TestICal.s43 and other main-flash programs.
; This code will be assembled into the last main-flash segment which starts at $FE00.
; It is called directly on reset.
; It contains the reset and interrupt vectors which point to fixed locations at the end of the
; second-last main-flash segment.
; It is defined as a macro because TestICal needs to include it _twice_.
; Once at $FE00-$FFFF as expected, for when TestICal is JTAG-loaded,
; and elsewhere in main-flash for when TestICal is bootstrap-loaded,
; so that it can then be copied to $FE00-$FFFF by a 'b' command (updateBSL2).
; It's called "BSL2" because there was an earlier version BSL that we miraculously fitted in
; the 256 bytes of info-flash, along with the calibration data. The two BSLs coexisted for a time.

BSL2MACRO	MACRO	jBSL, jBSLErase, jReadByte, jWriteByte, jBslRevision
			LOCAL	BSL, BSLErase, ReadByte, WriteByte, BslRevision
			LOCAL	MClock, BaudRate, BitCycles, BitCyc1_5, MckPerFTGck, initBSL2, mainLoop2
			LOCAL	resetFSM2, FSMloop2, processByte2, eraseLoop, progByte2, TestNoInterp2
			LOCAL	testNoInterp, WriteBrk, WriteBreak
			LOCAL	freeSpaceBSL2, BSL2presence, BSL2checksum
			LOCAL	TA0FllIsr
MClock		EQU		4000000			; MCLK (CPU clock) frequency in hertz (=DCOCLK/2)
BaudRate	EQU		9600			; Serial comms rate in bits per second
BitCycles	EQU		(MClock+BaudRate/2)/BaudRate	; CPU clock cycles per bit
BitCyc1_5	EQU		(MClock*3+BaudRate)/(BaudRate*2) ; CPU clock cycles per 1.5 bits
MckPerFTGck	EQU		(MClock+165000)/330000	; MCLK cycles per Flash Timing Generator cycle

#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading

; Fixed entry points to BSL2
jBSL: 		br		#BSL-jBSL+BSL2_START		; Addresses of branches or calls within the BSL must be
jBSLErase:	br		#BSLErase-jBSL+BSL2_START	; adjusted so that, in both active and inactive copies,
jReadByte:	br		#ReadByte-jBSL+BSL2_START	; they are correct for the active copy, since a 'b'
jWriteByte:	br		#WriteByte-jBSL+BSL2_START	; command will copy the inactive to become the active.
jBslRevision: br	#BslRevision-jBSL+BSL2_START ; Return the BSL2 revision

BSL:		; Initialisation
			mov		#InitSP,SP		; Initialise the stack pointer ($300 or $400)
			mov.b	#DIVM_1+DIVS_3,&BCSCTL2		; Set MCLK = DCOCLK/2, SMCLK = DCOCLK/8 (watchdog)
			; Use original TI frequency calibration values, in case our values not set up or wildly bad
			mov.b	&CALBC1_8MHZ,&BCSCTL1	; Set DCO range for 8 MHz
			mov.b	&CALDCO_8MHZ,&DCOCTL	; Set DCO step + modulation for 8.00 MHz
			mov.b	#TxPl,&P1OUT			; Set Txs to idle state, Vref output off
			bis.b	#TxPl|VrefP,&P1DIR 		; Set TxPl and VrefP as outputs
			bis.b	#TxMi,&TxMiPortDIR 		; Set TxMi as output (CMU port1, BMU port3)
		#if G2553
			; Use the Analog Comparator to get an inverted version of TxPlIn (P1.3/CA3)
			; (which is the UART TxPl looped back) to appear on TxMi (P3.7/CAOUT).
			; This initialisation also done in Monitor, TestICal etc
			; but they may not be bootstrap-loaded properly.
			bis.b	#TxMi,&TxMiPortSEL		; Select the comparator output function of P3.7
			mov.b	#CAON|CAREF_2,&CACTL1	; Half-supply to the comparator pos input and turn it on
			mov.b	#P2CA2|P2CA1,&CACTL2	; Feed CA3 to the comparator neg input
			mov.b	#TxPlIn,&CAPD			; Disable the digital input buffer of P1.3
		#endif // G2553

			; We've been reset, so send a break to reset the next guy, unless we're a BMU (ID = 255),
			; in which case it would lead to endlessly circulating breaks.

			cmp.b	#255,&infoID
			_IF		_NE				; If we're not a BMU
				; Send a 27 ms break
					mov.b	#$FF,R10		; Bit count 256 (terminates at -1)
					clr		R9				; Bit values (all zeros so it's a break)
				call	#WriteBreak-jBSL+BSL2_START	; Address adjusted for BSL's relocation
			_ENDIF

			ClearWatchdog			; Clear and restart the Watchdog Timer (32k)

			; Log the reason for the reset, as the contents of IFG1.
			; $A = RST pin (break), $6 = power on, $3 = watchdog, $2 = other bad stuff or JTAG.
			; It's a shame there's no way to tell a JTAG reset from a non-watchdog abnormal reset,
			; namely a flash key violation or an instruction fetch in range $0 to $1FF
			; (special function regs).

			mov			&resetCounter,R8
			and			#$0F,R8
			mov.b		&IFG1,resetBuffer(R8)
			inc			&resetCounter

mainLoop2:
			; Check for abnormal reset (watchdog, bad flash key, SFR instr fetch or JTAG reset)
			; or main program not present.
			; When JTAG debuging you need to write 4 or more to IFG1 ($0002) here,
			; to fake a normal reset.
#if 1	// Set to 1 only when JTAG debugging
	#message "Warning: BSL2 is set to ignore non-watchdog abnormal resets."
			bit.b	#WDTIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
			_IF		_Z				; If a non-watchdog abnormal reset (which may only be a JTAG reset)
				mov.b	#PORIFG,&IFG1	; Fake a Vcc power-up reset for the code below
			_ENDIF
#endif
			_COND					; Begin a short-circuit conditional
				cmp.b	#PORIFG,&IFG1	; Test for Vcc power-up or /RST pin pulsed low
				clr.b	&IFG1			; Clear those bits ready for next time
			_OR_ELSE	_L			; If Vcc power-up or /RST pin pulsed low Or Else
				cmp.b	#$AA,&ProgPresence ; Test for presence of main program.
			_OR_IFS		_NE			; Or If no main program
				mov.b	#WDTIFG,&IFG1	; Set watchdog int flag to indicate not to call jInterpretByte
			_ENDIF					; End short circuit conditional

			; Initialise main program, if allowed
			bit.b	#WDTIFG, &IFG1
			_IF		_Z
				call	#jInterpretInit
			_ENDIF

resetFSM2:	mov		#4,&bsl2state	; Initialise FSM: waiting for first password character
FSMloop2:	call	#ReadByte-jBSL+BSL2_START	; Address adjusted for BSL's relocation
processByte2
			; Pass byte in R8 on to main program, if allowed
			call	#TestNoInterp2-jBSL+BSL2_START	; Adjust for relocation

			; Password-checking finite-state-machine (FSM)
			; After decrementing bsl2state below, 3 = waiting for 1st pwd char,
			; 2 = waiting for 2nd pwd char, 1 = waiting for 3rd pwd char,
			; 0 = waiting for last pwd char and erase if received,
			; any negative value = program, no interpret
			;
			dec		&bsl2state
			jn		progByte2		; If state is negative, program, don't test for password etc.

			; Check for a continuing password match $07 $06 $05 $04
			mov		&bsl2state,R9
#if PROG_START_FOR_BSL == $E000		; Changed password for 8 KiB image
			add.b	#2,R9			; Expected password character is equal to &bsl2state with 2 added
#else								; Assume non 8 KiB image
			bis.b	#4,R9			; Expected password character is equal to &bsl2state with bit 2 set
#endif
			cmp.b	R9,R8
			jne		resetFSM2
			tst		&bsl2state
			jnz		FSMloop2

			; Erase only those segments of main flash memory used for the main program, not the last.
			; Master will need to delay at least 7*16 ms = 112 ms before sending first byte to program.
			;
BSLErase:
			dint					; The main-flash program has probably turned on interrupts
									; Can't risk an interrupt while the vectors are erased
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
			mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

			mov		#PROG_START_FOR_BSL,R12	; Start of program image in main flash
			; Erase
			mov		R12,R11			; R12 contains start of program image in main flash
eraseLoop	mov		#FWKEY+ERASE,&FCTL1	; Enable single segment erase
			rra		@R11			; Dummy write: erase segment
			add		#$200,R11		; Increment to next segment
			cmp		#BSL2_START,R11
			jlo		eraseLoop		; Stop when we get to the start of the BSL

			mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled; only write-block that can't be)
			clr.b	Rcksum			; Initialise the checksum to 0

			; Assume a bad checksum, clear on good checksum.
			; Also prevents interpreting till the end of flash programming
			bis.b	#WDTIFG,&IFG1
			jmp		FSMloop2		; Read first byte to program

			; Program (flash write) byte in R8
			;
progByte2	mov.b	R8,0(R12)		; Program it (takes 90 microseconds)
			xor.b	R8,Rcksum		; Include in check-XOR
			inc		R12
			cmp		#BSL2_START,R12
			jlo		FSMloop2		; Repeat until we get to the start of the BSL

			mov		#FWKEY,&FCTL1	; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
			tst.b	Rcksum			; Check the checksum
			jnz		resetFSM2		; If bad checksum, leave the no interpret flag set

			mov.b	#RSTIFG | OFIFG,&IFG1 ; Else clear no-interpret flag (watchdog flag), and fake a
									;  normal reset so InterpretInit and InterpretByte will be called.
			jmp		mainLoop2		; Go back to normal operation
			; end FSM code


; Call jInterpretByte, if it's safe to do so.
TestNoInterp2:
			bit.b	#WDTIFG,&IFG1	; Test no-interpret bit, due to watchdog, cksum error or programming
			_IF		_Z				; If we're interpreting
				tst.b	R8
				_IF		_L				; If data is a status byte (bit 7 set)
					mov.b	#$C1,R8			; Send status with comms error bit and bad check bit
											; $C1 to identify TestICal here, $C0 for BSL2 below
				_ENDIF

				; Echo the character if required
				_COND							; Begin short circuit conditional
					cmp.b		#$11,R8
				_OR_ELSE	_EQ					; If it's an XON (ctrl-Q) character Or Else
					bit.b	#bDontEcho,&interpFlags
				_OR_IFS		_Z					; Or If the dont-echo flag is clear
					call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
				_ENDIF

				; We are about to jump to jInterpretByte. In case the flash is corrupted by a
				; partial download, set the watchdog timer to the shortest interval, 64 cycles
				; InterpretByte should set it back to the longest interval, 32k cycles
				mov.w	#WDTPW+WDTCNTCL+WDTIS0+WDTIS1,&WDTCTL ; Clear and enable Watchdog Timer

				; Tail-call InterpretByte in main flash.
				; It must preserve at least R8 and bsl2state.
				; We get there via the PROG_START-independent vector "jInterpretByte".
				br		#jInterpretByte	; Tail call jInterpretByte
				; ret					; Effective ret to BSL2 main loop due to tail-call above
			_ELSE					; Else not interpreting
				; If we're not programming (bootstrap loading), toggle the error LED,
				; and set the comms error bit and a bad check bit on any passing status bytes,
				; since we are not calling the main program.
				cmp		#1,&bsl2state
				_IF		_GE				; If we're not programming (greater or equal to 1)
					ErrLedToggle
					tst.b	R8				; Test the character
					_IF		_L				; If the character is a status byte (bit 7 set)
						mov.b	#$C0,R8			; Send status with comms error and bad check bit, $C0
												; $C0 to identify BSL2 here, $C1 for TestICal above
					_ENDIF
				_ENDIF
				call	#WriteByte-jBSL+BSL2_START	; Echo. Call address adjusted for relocation
			_ENDIF					; End if interpreting
			ret						; Return to BSL2 init or main loop


; ReadByte ( regs: -- R8 R9 R10 R11 )
; Reads a byte from serial input to R8. Trashes R9 R10 R11.
;
ReadByte:
									; (Number of cycles)
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Hold the Watchdog Timer
			_BEGIN
				bit.b	#Rx,&P1IN		; (4) Start bit?
			_UNTIL	_Z					; (2) Loop until 0 (start bit)
			; The loop above takes 6 cycles so on average we will have missed the start bit by
									; (3) cycles
			push	SR				; (3) cycles
			dint					; (1) cycle
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; (5) Clear and enable the Watchdog Timer

			; Pad out the average delay between starting edge of start bit
			; and sampling of first bit below to ~ 1.5 bittimes
			mov.b	#(BitCyc1_5-21+1)/3,R11 ; (2) Loop count for waitMid delay loop
			_BEGIN
				dec		R11				; (1) Delay loop
			_UNTIL	_Z					; (2) Note: Clearing R11 here may be assumed in WriteByte below

			mov		#8,R10			; (1) Bit count
			_BEGIN
				bit.b	#Rx,&P1IN		; (4) Sampled bit to carry
				rrc.b	R8				; (1) Store received bit

				mov.b	#(BitCycles-10+1)/3,R11 ; (2) Pad RX bit loop out to one bit time
				_BEGIN
					dec		R11				; (1) Delay loop
				_UNTIL	_Z					; (2) Note: Clearing R11 here is assumed in WriteByte below
				dec		R10				; (1) All bits RXed?
			_UNTIL	_Z					; (2) Sample next bit

			; Normally there would be a 1 bit delay here so we return in the middle of the stop bit, so
			; calling ReadByte soon after returning doesn't mistake a zero in the MSB as a start bit.
			; But it's not needed, since we always send something before waiting for the next byte
			pop		SR
			ret					; Return from ReadByte


; WriteBreak ( R9 R10 -- R9 R10 R11 )
; Send a 27 ms break on the serial output. R9 must be zero and R10 must be $FF.
; Trashes R9 R10 R11.
WriteBreak:
			push	SR
			dint
			jmp		WriteBrk

; WriteByte ( R8 -- R9 R10 R11 )
; Write the low byte of R8 to serial output.
; Trashes R9 R10 R11. Preserves R8.
WriteByte:
			clr		R11
			mov		R8,R9			; Allow R8 to be preserved for password compare

			mov.b	#8,R10			; Loop counter, 1 start + 8 data (decrements to -1)
			rla		R9				; Add the start bit
			; Stop bit was bis#1<<9,R9, but it's done after the loop now
			; to allow sending a break
			push	SR
			dint

			_BEGIN					; (Number of cycles)
				rra		R9				; (1) Next bit to C.
				subc.b	#TxPl,R11		; (1) Bits 11(1)000(0)0 if C; 11(0)111(1)1 if NC
										; Note: R11 must be guaranteed clear in advance
				xor.b	&P1OUT,R11		; (3) Determine if Tx bits need toggling
#if	G2553
				and.b	#TxPl,R11 		; (2) Ensure only TxPl can be toggled below
#else
				and.b	#TxPl|TxMi,R11	; (2) Ensure only Tx bits can be toggled below
#endif
				xor.b	R11,&P1OUT		; (4) Toggle as needed, to send bit

WriteBrk		mov.b	#(BitCycles-16+1)/3,R11 ; (2) Set the delay counter to pad out to one bit time
				_BEGIN
					dec		R11				; (1) Note: Clearing of R11 here is assumed by subc.b above
				_UNTIL	_Z					; (2)

				dec		R10				; (1) Decrement the bit counter
			_UNTIL	_NC				; (2) Loop until -1

#if	G2553 // BMU
			; Send a stop bit
			bis.b	#TxPl,&P1OUT	; Set TxPl high. TxMi is its inversion by the analog comparator.
#else // CMU
			; Send a stop bit
			mov.b	#TxPl,R11		; We want TxPl high and TxMi low
			xor.b	&P1OUT,R11		; Get one bits in R11 for bits that need to toggle
			and.b	#TxPl|TxMi,R11	; Mask so we only change those we want to change
			xor.b	R11,&P1OUT		; Toggle bits as required

			bit.b	#ErrLed,&P2OUT		; Activity and error LEDs share an output.
			_IF		_Z					; If the error LED is off
				bic.b	#ErrLed,&P2DIR		; make output high-Z so activity LED goes off
			_ENDIF							; without turning error LED on.
#endif
			; To ensure the stop bit has sufficient duration we rely in the fact that
			; calls to WriteByte must be at least 2 byte-times apart
			; to allow any receiving CMU's BSL time to both read and echo the byte.

			; The Activity-LED-on is done in PrettyPrint now since the Activity LED drive is combined
			; with the Error LED and ErrAct is not on port 1.
			; In the BMU, the Activity LED is not on any port but driven by MOSFET off TxMi.

			pop		SR
			ret

BslRevision:
			mov		#BSL_REV,R8			; Return the SVN revision for this file
			ret

			; Any free last-segment space is between here and the UART interrupt vectors
;freeSpaceBSL2	EQU		jBSL+$1EC - $	; Number of bytes spare in the BSL
freeSpaceBSL2	EQU		jBSL+($FFEC-BSL2_START) - $ ; Number of bytes spare in the BSL

; The end of the bootstrap loader (BSL2)
; -----------------------------------------------------------------------------

;-------------------------------------------------------------------------------
; Interrupt Vectors at the end of the last flash segment
;-------------------------------------------------------------------------------
				ORG		jBSL+($FFEC-BSL2_START)		; $FFEC, UART Vectors
				DW		jUCA0TxIsr		; UART transmit
				DW		jUCA0RxIsr		; UART receive

										; $FFF0, Timer A0 Vectors
				DW		jTA0RxTiovIsr	; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
				DW		jTA0TxIsr		; Timer A CC0IFG (transmit compare)
				DW		$FFFF, $FFFF	; FFF4, FFF6
										; $FFF8, Timer A1 Vectors
				DW		jTA1RxTiovIsr	; Combined CC1,2IFG (receive capture/compare) & TAIFG (overflow)
				DW		jTA1TxIsr		; Timer A CC0IFG (transmit compare)

										; $FFFC, Unused NMI vector location
BSL2presence	DB		$08				; No longer used. BSL1 used to check this before calling BSL2.
BSL2checksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg
				; The reset vector (at $FFFE) is set by monitor and TestICal, but could be done here.

				ENDM
