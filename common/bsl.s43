; ----------------------------------------------------------------------------
; The bootstrap loader (BSL)
;
; This will be relocated to info-flash which starts at $1000.
; This code is common to the debugger and the BSLwriter, which may still be needed
;	occasionally if a BMU loses its frequency calibration data and it needs to be forced.

MClock		EQU		4000000			; MCLK (CPU clock) frequency in hertz (=DCOCLK/2)
BaudRate	EQU		9600			; Serial comms rate in bits per second
BitCycles	EQU		(MClock+BaudRate/2)/BaudRate	; CPU clock cycles per bit
BitCyc1_5	EQU		(MClock*3+BaudRate)/(BaudRate*2) ; CPU clock cycles per 1.5 bits
MckPerFTGck	EQU		(MClock+165000)/330000	; MCLK cycles per Flash Timing Generator cycle

; Bits in i/o port 1
TXDm		EQU		1<<1			; Code requires TXDm bit somewhere to right of TXDp bit
RXD			EQU		1<<2			; Receive data on P1.2 (bit number >3 costs 2 words)
VREFp		EQU		1<<4			; Analog reference output. Sometimes changed to low digital output
TXDp		EQU		1<<5			; Prefer bit number <= 3 for code compactness (costs 2 word if not)
#if PCBVERSION < 57
LED			EQU		1<<6			; LED (red) on P1.6 used for both error and activity
BYPASS		EQU		1<<0			; Bypass transistor on pin P1.0
#else
ACTLED		EQU		1<<3			; Actvity LED (blue) inverted on P1.3
ERRLED		EQU		1<<7			; Error LED (red) on P2.7
BYPASS		EQU		1<<6			; Bypass transistor on pin P2.6
#endif

#define		Rstate	R15				// Register holding the state of the password checking FSM
#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading


for1000:	; This will be relocated to info-flash at $1000.

			mov.b	#DIVM_1,&BCSCTL2		; Set MCLK = DCOCLK/2
			mov.b	&info8MHzCalB,&BCSCTL1	; Set DCO range for 8 MHz			
			mov.b	&info8MHzCalD,&DCOCTL	; Set DCO step + modulation for 8.00 MHz
#if PCBVERSION < 57
			mov.b	#TXDp,&P1OUT	; Set TXD to idle state. Set BYPASS, error LED and Vref outputs off
			bis.b	#TXDp+TXDm+BYPASS+LED+VREFp,&P1DIR ; Set TXDs, BYPASS, LED and VREFp as outputs
#else
			mov.b	#TXDp+ACTLED,&P1OUT	; Set TXD to idle, (inverted) activity LED off, Vref output off
			bis.b	#TXDp+TXDm+ACTLED+VREFp,&P1DIR ; Set TXDs, activity LED and VREFp as outputs
			; so the BSL can avoid consuming flash space with the following code.
			; On reset the BYPASS pin is set as a crystal oscillator pin XIN
			; and the ERRLED pin is set as a crystal oscillator pin XOUT.
			; This is safe, as the bypass MOSFET has a pulldown on its gate,
;			mov.b	#0,&P2SEL ; Set BYPASS and ERRLED to not be crystal osc pins
;			mov.b	#0,&P2OUT	; Set BYPASS and ERRLED off
;			mov.b	#$FF,&P2DIR ; Set BYPASS and ERRLED as outputs
#endif			
			mov		#$280,SP
mainLoop:							; Start of the main BSL loop

			; Initialise the interpreter (or BSL-writer), if possible
			clr.b	R8				; A null to pass to interpretByte (if allowed)
									;	to initialise the main-flash code
			call	#testNoInterp-for1000+$1000	; Address adjusted for BSL's relocation to info-flash
mainInitRetAddr:	; Used by BSL-writer and interpreter to tell if the byte in R8 should be echoed

			; Password-checking finite-state-machine (FSM)
			; After decrementing Rstate below, 3 = waiting for 1st pwd char,
			; 2 = waiting for 2nd pwd char, 1 = waiting for 3rd pwd char,
			; 0 = waiting for last pwd char and erase if received, any negative value = program, no interpret
			;
resetFSM:	mov		#4,Rstate		; Initialise FSM: waiting for first password character
FSMloop:	call	#ReadByte-for1000+$1000	; Address adjusted for BSL's relocation to info-flash

			dec		Rstate
			jn		progByte		; If state is negative, program, don't interpret

			; Check for a continuing password match
;			cmp.b	infoPWtable(Rstate),R8	; Address adjusted for BSL's relocation to info-flash
			cmp.b	Rstate,R8		; Made expected password character equal to Rstate to save space
			jne		resetFSM
			tst		Rstate
			jnz		FSMloop

			; Erase main flash memory
			; Master will need to delay at least 33 ms before sending first byte to program.
			;
mainBSLErase:
			dint					; Main-flash has probably turned on interrupts; can't have them now
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
			mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

			mov		#$F800+2,R12	; Start of main flash +2. The +2 saves a 2-word compare at the end
			mov		#FWKEY+MERAS,&FCTL1 ; Enable bulk segment erase
			rra		@R12			; Dummy write: erase segments
			
			; Immediately replace reset vector to this boot loader
			mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled; only write-block that can't be)
			mov		#$1000,&$FFFE	; Write reset vector to point to start of info-flash (start of BSL)
			clr.b	Rcksum			; Initialise the checksum to 0
			
			; Assume a bad checksum, clear on good checksum.
			; Also prevents interpreting till the end of flash programming			
			bis.b	#WDTIFG,&IFG1
			jmp		FSMloop			; Read first byte to program

			; Program (flash write) byte in R8
			;
progByte	mov.b	R8,-2(R12)		; Program it
			xor.b	R8,Rcksum		; Include in check-XOR
			inc		R12
			jnz		FSMloop			; Repeat until R12 wraps to zero

			mov		#FWKEY,&FCTL1	; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
			tst.b	Rcksum			; Check the checksum
			jnz		resetFSM		; If bad checksum, leave the no interpret flag set
			
			bic.b	#WDTIFG,&IFG1	; Good checksum, reset no interpret flag
			jmp		mainLoop		; Back to looking for ^B, but first send a null to interpretByte
			
			; end FSM code

; ReadByte ( regs: -- R8 R9 R10 R11 )
; Reads a byte from serial input to R8. Trashes R9 R10 R11.
; Also echoes the byte to serial output (either by falling through to WriteByte, or calling
;	interpretByte)
;
ReadByte:
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer
waitStartR							; (Number of cycles)
			; The loop below takes 6 cycles so on average we will have missed the start bit by
									; (3) cycles
			bit.b	#RXD,&P1IN		; (4) Start bit?
			jnz		waitStartR		; (2) Loop while not 0 (start bit)
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; (5) Clear and restart Watchdog Timer

			; Pad out the average delay between starting edge of start bit
			; and sampling of first bit below to ~ 1.5 bittimes
			mov.b	#(BitCyc1_5-17+1)/3,R11 ; (2) Loop count for waitMid delay loop
waitMid		dec		R11				; (1) Delay loop
			jnz		waitMid			; (2) Note: Clearing R11 here may be assumed in WriteByte below

			mov		#8,R10			; (1) Bit count
RX_Bit		bit.b	#RXD,&P1IN		; (4) Sampled bit to carry
			rrc.b	R8				; (1) Store received bit
			
			mov.b	#(BitCycles-10+1)/3,R11 ; (2) Pad RX_bit loop out to one bit time
waitNextR	dec		R11				; (1) Delay loop
			jnz		waitNextR		; (2) Note: Clearing R11 here is assumed in WriteByte below
			dec		R10				; (1) All bits RXed?
			jnz		RX_Bit			; (2) Sample next bit
			
			; Normally there would be a 1 bit delay here so we return in the middle of the stop bit, so
			; calling ReadByte soon after returning doesn't mistake a zero in the MSB as a start bit.
			; But it's not needed, since we always send something before waiting for the next byte
			
testNoInterp
			bit.b	#WDTIFG,&IFG1	; Test the no interpret bit (due to watchdog or checksum error)
			jnz		WriteByte		; Jump around call, if set
			br		#interpretByte	; tail-call interpretByte in main flash
									; It must preserve at least R8, Rstate(=R15)

; WriteByte ( R8 R11 -- R9 R10 R11 )
; Write the low byte of R8 to serial output. R11 must be clear on entry.
; Trashes R9 R10 R11. Preserves R8.
;
WriteByte:
			mov		R8,R9			; Allow R8 to be preserved for password compare
			
			mov.b	#10,R10			; 8 data + 1 start and 1 stop
			rla		R9				; Add a start bit
			bis		#1<<9,R9		; Add a stop bit
		
write_next							; (Number of cycles)
			rrc		R9				; (1) Next bit to C.
			subc.b	#TXDp,R11		; (1) Bits 11(1)000(0)0 if C; 11(0)111(1)1 if NC
									; Note: R11 must be guaranteed clear in advance
			xor.b	&P1OUT,R11		; (3) Determine if TXD bits need toggling
#if LEDWITHTX
#if PCBVERSION < 57
			; The below will turn the LED on for every bit sent. It's not how it was meant to be
			; but it works well enough. It would be as intended if LED had a lower bit number than TXDp.
			and.b	#TXDp+TXDm+LED,R11 ; (2) Ensure only TXD and LED bits can be toggled below			; activity LED had a lower bit number than TXDp.
#else // not PCBVERSION < 57
			; The activity LED has a bit number lower than TXDp so
			; the below will turn the (inverted) activity LED off when a zero bit or start bit is sent,
			; and on when a one bit or stop bit is sent.
			and.b	#TXDp+ACTLED+TXDm,R11 ; (2) Ensure only TXD and ACTLED bits can be toggled below
#endif // PCBVERSION < 57
#else // not LEDWITHTX
			and.b	#TXDp+TXDm,R11	; (alt 2) Ensure only TXD bits can be toggled below
#endif // LEDWITHTX
			xor.b	R11,&P1OUT		; (4) Toggle as needed, to send bit

			mov.b	#(BitCycles-16+1)/3,R11 ; (2) Set the delay counter to pad out to one bit time
write_dly	dec		R11				; (1) Note: Clearing of R11 here is assumed by write_next above
			jnz		write_dly		; (2)
			dec		R10				; (1)
			jnz		write_next		; (2)
			ret
			
			; Any free info-flash space is between this line and the next
			ORG		for1000+$F8
			; Calibration data
mainDataStart						; Used when copying between ram and info-flash
mainVoltCal		ds		2			; Voltage scale calibration word; may be written by BSL writer
mainTempCal		ds		1			; Temperature offset calibration; may be written by BSL writer
mainLinkCal		ds		1			; Link voltage offset calibration data; may be written by BSL writer
main8MHzCalD	ds		1			; 8 MHz DCO frequency calibration byte (same address as in new chip)
main8MHzCalB	ds		1			; 8 MHz DCO range calibration byte (same address as in new chip)
mainID			ds		1			; Cell/BMU identifier byte; first cell is 1; written by 'i' cmd
; Note that xxxDataEnd is one PAST the last calibration byte, i.e. the address of the start of what
;	comes after the calibration bytes
mainDataEnd							; Used when copying between ram and info-flash
mainDataVers db		DATAVERS		; Data Version byte (cannot move)

; The end of the bootstrap loader (BSL)
; -----------------------------------------------------------------------------

