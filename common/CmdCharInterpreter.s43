; Contains both an outer (packet) interpreter with backspace editing
; and an inner (command character) interpreter.

;-------------------------------------------------------------------------------
;
; Status flag usage
;
; Bit 15 = literal in progress
; Bit 14 = hex literal (otherwise decimal)

#define		Rip		R5		// Interpreter instruction pointer
#define		Rlit	R6		// Holds partial literals
#define		Rw		R8		// Working register - temporary - anyone can use

; Macros for 3-register interpreter data stack
; Not sure which choice of registers is best
#if 1
	#define 	Rtos	R7		// Top element of data stack
	#define 	Rsec	R4		// Second element from top
	#define 	Rthd	R13		// Third element from top
#else
	#define 	Rtos	R8		// Top element of data stack
	#define 	Rsec	R9		// Second element from top
	#define 	Rthd	R10		// Third element from top
#endif

DPUSH		MACRO	arg
			mov		Rsec,Rthd
			mov		Rtos,Rsec
			mov		arg,Rtos
			ENDM

DPUSHb		MACRO	arg
			mov		Rsec,Rthd
			mov		Rtos,Rsec
			mov.b	arg,Rtos
			ENDM

DPOP		MACRO	arg
			mov		Rtos,arg
			mov		Rsec,Rtos
			mov		Rthd,Rsec
			ENDM

DPOPb		MACRO	arg
			mov.b	Rtos,arg
			mov		Rsec,Rtos
			mov		Rthd,Rsec
			ENDM

DROP		MACRO
			mov		Rsec,Rtos
			mov		Rthd,Rsec
			ENDM

TwoDROP		MACRO
			mov		Rthd,Rtos
			ENDM

SWAP		MACRO
			xor		Rtos,Rsec
			xor		Rsec,Rtos
			xor		Rtos,Rsec
			ENDM

DUP			MACRO
			mov		Rsec,Rthd
			mov		Rtos,Rsec
			ENDM

OVER		MACRO
			mov		Rsec,Rthd
			mov		Rtop,Rsec
			mov		Rthd,Rtop
			ENDM

NIP			MACRO
			mov		Rthd,Rsec
			ENDM

TUCK		MACRO
			mov		Rtos,Rthd
			ENDM

ROT			MACRO
			xor		Rsec,Rthd
			xor		Rthd,Rsec
			xor		Rsec,Rthd
			xor		Rtos,Rsec
			xor		Rsec,Rtos
			xor		Rtos,Rsec
			ENDM

MinusROT	MACRO
			xor		Rtos,Rsec
			xor		Rsec,Rtos
			xor		Rtos,Rsec
			xor		Rsec,Rthd
			xor		Rthd,Rsec
			xor		Rsec,Rthd
			ENDM

;-------------------------------------------------------------------------------
; Command-character-table Macros

; The command-character lookup table is in high memory.
; It contains one word per command character from $21 to $7F.
; That word is the address of the code that implements the operation.

_LO_CMDCHR	EQU	' '+1						; Lowest definable cmd-character is char after space, "!"
_HI_CMDCHR	EQU	$7F							; Highest definable cmd-character has low 7 bits set, DEL

_CMDCHRTBL	EQU	CMDCHRTBLEND-(2*(_HI_CMDCHR+1-_LO_CMDCHR))	; Table ends immediately below lowest used
											; interrupt vector

; The "x" at the start of the following macro names stands for "cross-compiling"
; to distinguish them from possible native versions on the MSP430 in other versions.
; The name "CODE" is from Forth.


; Assemble a command-character-table entry that has a machine-code definition.

xCODE	MACRO	CMDCHR,CMDCHRNAM,_ADDRLBL
						LSTOUT-
		EVEN								; Force to word boundary
_ADDRLBL:									; Define the machine-code address label
CMDCHRNAM EQU	CMDCHR						; Define the command-character name
		ORG		_CMDCHRTBL-(_LO_CMDCHR*2)+(CMDCHR)*2	; Point to correct command-character-table entry
						LSTOUT+
		DW		_ADDRLBL					; Assemble the address
						LSTOUT-
		ORG		_ADDRLBL					; Point back to where the machine code will be assembled
						LSTOUT+
						ENDM

;-------------------------------------------------------------------------------
; The inner (command character) interpreter

; Interpreter for 7 bit command characters
_ENTER
_NEXT
		ClearWatchdog		; Clear and restart Watchdog Timer before each
							; command character is interpreted
		mov.b	@Rip+,Rw	; Fetch the next character

_RUN	cmp.b	#_LO_CMDCHR,Rw ; Treat all undefinable characters, including space,
		jlo		NotDigit	; as literal-separator no-ops
		cmp.b	#_HI_CMDCHR+1,Rw
		jhs		NotDigit

		rla.b	Rw			; Multiply character code by 2
FncOPCD mov _CMDCHRTBL-(_LO_CMDCHR*2)(Rw),Rw ; Use 2*charcode to index the command-character-table to get
							;	the code address

		cmp		#$FFFF,Rw	; Check for undefined characters, either $FFFF or $0000
		jge		DoUNDEF		; Note: Will fail on processors with > 32K of flash and code below $8000

FncLIT	tst		SR			; Check for an implied push-literal
		jge		DoOPCD		; If there's an operand-in-progress
							;	there's an implied LIT now
		bic		#(1<<15)+(1<<14),SR	; Clear the operand-in-progress flag and the hex flag
;		push	Rtos		;	Push the operand now, before doing the
;		mov		Rlit,Rtos	;	operation
		DPUSH	Rlit

DoOPCD	call	Rw			; Call the machine-code implementation of the command character
							; It must end with an RET
		jmp		_NEXT


DoUNDEF ; Attempt to interpret undefined command characters as hex/decimal digits,
		; otherwise treat them as literal-separating no-ops.
        dec		Rip			; Decrement the instruction pointer to
		mov.b	@Rip+,Rw	;  re-fetch the character
        sub.b	#'0',Rw		; '0'-'9','A'-'F' -> $0-$9,$11-$16
		jn		NotDigit	; Ignore undefined characters below '0'
		cmp.b	#$0A,Rw
		_IF		_GE
			cmp.b	#$17,Rw
			jge		NotDigit ; Ignore undefined characters above 'F'
			cmp.b	#$11,Rw
			jl		NotDigit ; Ignore undefined between '9' and 'A'
			sub.b	#'A'-('9'+1),Rw	; $11-$16 -> $0A-$0F
		_ENDIF

FncPFX4 tst		SR			; Test the operand-in-progress flag
		bis		#1<<15,SR	; Set the operand-in-progress flag
		jn		DatMor4		; If there was no operand-in-progress

DatFst4 mov		Rw,Rlit		;	Move 4-bit data to partial-operand register
		jmp		_NEXT		; Else (operand-in-progress)

DatMor4 rla		Rlit		;	Multiply the partial operand by 16 or 10
		mov		Rlit,R9		;	Save 2*Rlit in R9
		rla		Rlit		;	4*Rlit
		rla		Rlit		;	8*Rlit
		bit		#1<<14,SR	; Test the hex flag
		_IF		_Z			; If decimal
			add		R9,Rlit	;	10*Rlit
		_ELSE				; Else hex
			rla		Rlit	;	16*Rlit
		_ENDIF				; Endif
		add		Rw,Rlit		;	Add data into operand reg
DatEnd4 jmp		_NEXT		; Endif

NotDigit mov	#_Space,Rw	; Treat as literal-separator no-op
		jmp		FncLIT


;-------------------------------------------------------------------------------
; The outer (packet) interpreter
; ACCEPT	( char -- )	; Accept the character in R8 into the line buffer.
; Trashes R8 and R9, and more if carriage return is processed.
; Implements backspace editing, Xon/Xoff and Escape, and calls the inner interpreter
; to interpret the line when a valid checksum and a carriage return are received.
; Outputs go to the default port (usually CMU, but SCU for the case of a BMU running wmonolith)
ACCEPT:
		mov		&ToIN,R9
		_CASE

		_OFb	#$0A,R8			; Throw away any line feeds (after carriage returns from modbus)
		_ENDOF

		_OFb	#$0D,R8			; Carriage return = end of packet
			cmp		#TIBEnd,R9
			_IF		_LO				; If packet buffer not full
				mov.b	R8,0(R9)		; Store CR in the buffer; simplifies later logic
				bit.b	#bEchoResponses,&interpFlags
				; This is e.g. to allow SCU to see Wunth or Modbus responses from CMUs
				_IF		_NZ				; If echoing responses
					mov.b	&TIB,R8				; Get first char of text input buffer
					xor.b	#'\\',R8			; R8 is 0 iff it was a slosh, starting a Wunth resp.
					_IF		_NZ					; Otherwise,
						cmp.b	#':',&TIB			; Does it start with a colon? (modBus resp or cmd)
						_IF		_EQ
							cmp		#TIB+13,R9			; Is the CR  at position 13?
							_IF		_EQ					; If so, it's a Modbus response
								clr		R8					; Clear boolean R8 if so
							_ENDIF
						_ENDIF
					_ENDIF
					tst		R8						; Test our condition flag
					_IF		_Z						; Zero indicates a response to be echoed
						; Echo the response
						push	R9
						push	R10
						push	R11
						mov		#TIB,R10			; Start of TIB to R10
						mov		R9,R11				; R11 has position of CR
						sub		#TIB-1,R11			; R11 has length including CR
						call	#TxBytes			; Send the response packet (ptr R10 length R11)
						cmp.b	#':',&TIB			; If it started with a colon (modbus)
						_IF		_EQ
							mov.b	#$0A,R8				; Send a line-feed
							call	#TxByte
						_ENDIF
						pop		R11
						pop		R10
						pop		R9
					_ENDIF					; Endif copying this response
				_ENDIF					; Endif bEchoResponses
				bit.b	#bChecksumming,&interpFlags
				_IF		_NZ				; If checksumming
					cmp.b	#':',&TIB
					_IF		_NE				; And if not a modbus packet (starts with colon)
						tst.b	&rxCksum
						_IF		_Z				; And if good checksum
							dec		R9				; Prepare to overwrite checksum with EXIT command char
							cmp		#TIB,R9			; Handle case of empty packet with no checksum
							_IF		_LO
								mov		#TIB,R9
							_ENDIF
					_END_PRIOR_IF			; End if not modbus
				_END_PRIOR_IF			; End if checksumming
							; We get here when not-checksumming or a modbus packet or a good checksum
							mov.b	#EXIT,0(R9) 	; Overwrite checksum or CR with EXIT command character
							bit.b	#bDontInterpret,&interpFlags
							_IF		_Z				; If the dont-interpret flag is clear
								mov		#TIB,Rip		; Interpret the packet as command characters
								call	#_ENTER
								bic.b	#bModbusOutput,&interpFlags	; Clear the modbus output mode flag
							_ENDIF					; End if dont-interpret flag is clear
						_ENDIF					; End if good checksum
			_ENDIF					; End if packet buffer not full
			mov		#TIB,&ToIN		; Initialise packet buffer pointer
			clr.b	&rxCksum		; Clear the packet checksum
		_ENDOF					; End of carriage return

		_OFb	#$08,R8			; Backspace editing
			cmp		#TIBEnd,R9
			_IF		_LO				; If packet buffer not full
				dec		R9				; Decrement the pointer, but
				cmp		#TIB,R9			; don't go back past start of packet
				_IF		_LO
					mov		#TIB,R9
				_ENDIF
				mov		R9,&ToIN
			_ENDIF					; Endif packet buffer not full
		_ENDOF					; EndOf backspace

		_OFb	#$11,R8			; XON (ctrl-Q) to exit no-echo mode
			bic.b	#bDontEcho,&interpFlags ; Clear the don't-echo flag
		_ENDOF					; EndOf XON

		_OFb	#$13,R8			; XOFF (ctrl-S) to enter no-echo mode
			bit.b	#bDontInterpret,&interpFlags
			_IF		_Z				; If the dont-interpret flag is clear
				bis.b	#bDontEcho,&interpFlags ; Set the don't-echo flag
			_ENDIF
		_ENDOF					; EndOf XOFF

		_OFb	#$1B,R8			; Escape to exit eXclusive mode (single CMU interaction)
			bic.b	#bDontInterpret,&interpFlags ; Clear the don't-interpret flag
		_ENDOF					; EndOf escape

		; Default case, if not CR, BS, XON, XOFF or ESC
			cmp		#TIBEnd,R9
			_IF		_LO				; If packet buffer not full
				mov.b	R8,0(R9)		; Write the byte to the buffer
				inc		&ToIN			; Increment the pointer
				xor.b	R8,&rxCksum	; Accumulate the Wunth checksum
			_ENDIF					; Endif packet buffer not full

		_ENDCASE				; End Case char

		ret


