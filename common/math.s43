;
; Mathematical functions used by all CMU software
; Use #include "../common/math.s43"
;

; UMStar -- Unsigned mixed multiply
; R8 * R9 -> R10:R9. Clears R11
;
; In ANS Forth: UM* ( u1 u2 -- ud )
; Multiply u1 by u2, giving the unsigned double-word product ud. All values and arithmetic are unsigned.
;
; Starts with 16 bit multiplicand in R8, multiplier in R9 and
; ends with 32 bit product in R10 (hi) and R9 (lo).
; Algorithm described in http://cs.hiram.edu/~walkerel/cs252/multiply.ppt
; 138 to 154 cycles
;
; UMStarPlus -- Unsigned mixed multiply and add. (Alternative entry point)
; R8 * R9 + R10 -> R10:R9. Clears R11
; This is the exact inverse of UMSlashMod below

UMStar:							; (4) Cycles required for Call
			clr		R10			; (1) Clear hi word of product-so-far
UMStarPlus:
			_FOR	#16,R11		; (2) Repeat 16 times
				bit		#1,R9		; (1) Test low bit of multiplier
				_IF		NZ			; (2) If low bit of multiplier is a 1
					add		R8,R10		; (1) Add multiplicand to product-hi
				_ENDIF				; (0) Endif
				rrc		R10			; (1) Shift product-hi (including carry) right
				rrc		R9			; (1) into product-lo and simultaneously shift multiplier right
			_NEXT_DEC R11		; (3) Decrement loop counter. Repeat until zero
			ret					; (3) Return from subroutine


; UMSlashMod -- Unsigned mixed divide and modulo
; R10:R9 / R8 -> R9, remainder R10. Clears R11
;
; In ANS Forth: UM/MOD ( ud u1 -- u2 u3 )
; Divide ud by u1, giving the remainder u2 and the quotient u3.
; All values and arithmetic are unsigned. An ambiguous condition exists
; if u1 is zero or if the quotient lies outside the range of a single-word
; unsigned integer.
;
; In cases of overflow or div by zero we return a saturated $FFFF for the quotient
; and a remainder of $FFFF which cannot occur otherwise.
; Algorithm is from eForth by Bill Muench.
; It is essentially the reverse of the multiplication algorithm above.
; 172 to 204 cycles (excluding overflow or div by zero)

UMSlashMod:						; (4) Cycles required for Call
			cmp		R8,R10		; (1) Test for overflow, including divide by zero
			_IF		LO			; (2) If no overflow, i.e. if dividend-hi less than divisor
				_FOR	#16,R11		; (2) Repeat 16 times
					_COND				; (0) Start a short-circuit conditional
						rla		R9			; (1) Shift quotient left, and simultaneously shift
						rlc		R10			; (1) dividend-lo into dividend-hi
					_OR_ELSE C			; (2) If carry, or else
						cmp		R8,R10		; (1) Test for remainder-so-far >= divisor
					_OR_IFS	HS			; (2) if no carry, but remainder-so-far >= divisor
						sub		R8,R10		; (1) Subtract divisor from remainder-so-far
						bis		#1,R9		; (1) Set low bit of quotient-so-far
					_ENDIF				; (0) End of short-circuit conditional
				_NEXT_DEC R11		; (3) Decrement loop counter. Repeat until zero
				ret					; (3) Return from subroutine
			_ENDIF				; (0) End If no overflow
			mov		#$FFFF,R9	; (1) Error exit if overflow or divide by zero
			mov		#$FFFF,R10	; (1) Return $FFFF for both quotient and remainder
			ret					; (3) Return from subroutine
