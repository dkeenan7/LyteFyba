;
; Mathematical functions used by all CMU software
; Use #include "../common/math.s43"
;

; UMStar -- Unsigned mixed multiply
; R8 * R9 -> R10:R9. Clears R11
;
; In ANS Forth: UM* ( u1 u2 -- ud )
; Multiply u1 by u2, giving the unsigned double-word product ud. All values and arithmetic are unsigned.
;
; Starts with 16 bit multiplicand in R8, multiplier in R9 and
; ends with 32 bit product in R10 (hi) and R9 (lo).
; Algorithm described in http://cs.hiram.edu/~walkerel/cs252/multiply.ppt
; 138 to 154 cycles
;
; UMStarPlus -- Unsigned mixed multiply and add. (Alternative entry point)
; R8 * R9 + R10 -> R10:R9. Clears R11
; This is the exact inverse of UMSlashMod below

UMStar:							; (4) Call
			clr		R10			; (1) Clear hi word of product so far
UMStarPlus:	mov		#16,R11		; (2) Do 16 times

mullp		bit		#1,R9		; (1) Test low bit of multiplier
			jz		mulz		; (2) If it's a 1
			add		R8, R10		; (1)   add multiplicand to product hi word; Endif
mulz		rrc		R10			; (1) Shift product hi word (incl. carry) right
			rrc		R9			; (1) into product lo and simul. shift multiplier right
			dec		R11			; (1) Decrement loop counter
			jnz		mullp		; (2) Loop until zero
			ret					; (3)


; UMSlashMod -- Unsigned mixed divide and modulo
; R10:R9 / R8 -> R9, remainder R10. Clears R11
;
; In ANS Forth: UM/MOD ( ud u1 -- u2 u3 )
; Divide ud by u1, giving the remainder u2 and the quotient u3.
; All values and arithmetic are unsigned. An ambiguous condition exists
; if u1 is zero or if the quotient lies outside the range of a single-word
; unsigned integer.
;
; In cases of overflow or div by zero we return a saturated $FFFF for the quotient
; and a remainder of $FFFF which cannot occur otherwise.
; Algorithm is from eForth by Bill Muench.
; It is essentially the reverse of the multiplication algorithm above.
; 172 to 204 cycles (excluding overflow or div by zero)

UMSlashMod:						; (4) Call
			cmp		R8,R10		; (1) Overflow?
			jhs		oflo		; (2) Jump to error exit if divide by zero or overflow.
			mov		#16,R11		; (2) Do 16 times

ummlp		rla		R9			; (1) Shift quotient left and simul. shift dividend lo
			rlc		R10			; (1)   into dividend hi
			jc		umm2		; (2) If carry OR
			cmp		R8,R10		; (1)
			jlo		umm1		; (2) no carry AND remainder-so-far >= divisor
umm2		sub		R8,R10		; (1)	Subtract divisor from remainder-so-far
			bis		#1,R9		; (1)	Set low bit of quotient-so-far
								;	  Endif
umm1		dec		R11			; (1) Decrement loop counter
			jnz		ummlp		; (2) Loop until zero
			ret					; (3)

oflo		mov	#-1,R9			; (1)
			mov	#-1,R10         ; (1)
			ret					; (3)

#ifdef	MONOLITH
; Not the right place for these
; Update the RTC if necessary. Call at least every 15 seconds.
; Trashes R8, R9
UpdateRtc:
			mov		&measureCount,R9			; Counter that is incremented 4096 times per sec
			and		#$F000,R9					; Keep only upper 4 bits
			mov		&oldRtcMeasCnt,R8			; Get last saved
			sub		R9,R8						; R8 = new - old
			_IF		_Z							; If no difference
				ret									; then nothing to do; return
			_ENDIF
			mov		R9,&oldRtcMeasCnt			; then save this different count
			; R8 has the difference between old and new counts in the upper nibble.
			; Need to shift R8 right logical 12 bits, to get the mumber of seconds to advance the
			; RTC by. Shift as 8 then 4. The and instruction above guarantees that the other 12 bits
			; of R8 were zero.
			swpb	R8							; Move top byte to lower byte
			rra4	R8							; Move second lowest nibble to lowest nibble
			; Fall through to BumpRtc

; Do not insert code here
; Bump the "real time clock" by R8 seconds. Callable as a function, but not currently used that way.
; Changes no registers
BumpRtc
			add		R8,&rtcSec		; Add to the seconds
			cmp		#60,&rtcSec		; Is it now >=60 seconds?
			_IF		_GE
				sub		#60,&rtcSec	; Wrap seconds
				inc		&rtcMin		; Bump minutes
				cmp		#60,&rtcMin	; Now 60?
				_IF		_EQ
					clr		&rtcMin		; Clear minutes
					inc		&rtcHour	; Bump hour
					cmp		#24,rtcHour	; Now 24?
					_IF		_EQ
						clr		&rtcHour
						inc		&rtcDay		; Bump day of week
						cmp		#7,&rtcDay	; Now 7?
						_IF		_EQ
							clr		&rtcDay		; Clear day of week
							; Allow to wrap around
						_ENDIF
					_ENDIF
				_ENDIF
			_ENDIF
			ret
#endif