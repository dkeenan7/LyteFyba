; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve the Bootstrap Loader and calibration data.
			COL		132				; Nice wide listings
; This is a Bootstrap-loader writer (BSL-writer) for an MSP430F2012 microcontroller.
;
; It was developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; This BSL-writer should be the first program written to the 2kB of main-flash on the MSP430F2012.
; This must be done using a flash programmer connected to the chip's JTAG port.
; The BSL-writer contains a copy of a bootstrap loader (BSL).
; It writes this BSL to the 256 bytes of info-flash, while preserving some of the
; digitally controlled oscillator (DCO) calibration bytes that are stored there by the chip manufacturer.
; It may also be configured to perform voltage and temperature calibrations
; and store this calibration data in info-flash as well.
; It then passes control to the BSL.

; The BSL consists of a software UART providing RS422-style serial communications,
; and a password-recognising state-machine.
; The state-machine normally passes incoming serial data to a command interpreter in main-flash.
; But when the password is recognised, the state-machine instead writes incoming serial data to main-flash.
; This allows it to overwrite the BSL-writer with the initial command interpreter, sent via the serial input.
; And because the BSL transmits all data received on its serial input, to its serial output,
; a cascaded series of these MSP boards can all be updated simultaneously.
; You only need to send a new version of the command interpreter to the first board in the chain.
;
; But what if you want to update the BSL itself?
; In that case, instead of sending a new interpreter, you send this BSL-writer
; carrying the new version of the BSL.
; This time you send the BSL-writer via the serial input not the JTAG port.
; That way you will update the BSLs of all the MSP boards in the chain simultaneously.
;
; The existing BSL will dutifully load the BSL-writer into main flash,
; completely unaware that it has just loaded the instrument of its own demise.
; When the old BSL calls the BSL-writer, thinking it is initialising a new interpreter,
; the BSL-writer will write the new BSL to info-flash and pass control to it.
; Then the interpreter must be sent again, to replace the BSL-writer.
; The BSL-writer still preserves the calibration data, which may now include
; voltage and temperature calibration data in addition to the DCO calibration data
; from the manufacturer.
;
; The BSL code is made to fit in the tiny 256 bytes of info-flash because
; this segment can be protected when the rest of the flash is erased,
; and all other flash segments are 512 bytes and contiguous with each other,
; but not with info-flash.
;
; For this reason, the BSL code is highly hand-optimised for space and
; uses many tricks that can make it hard to follow and hard to modify.
;
; The following is true of this BSL-writer, and the BSL itself:fco
;   They use no interrupts, since the interrupt vectors will be reprogrammed.
;   They use no timer; too many 6-byte instructions!
; The BSL serial input code has some noise immunity.

; Conditional assembly parameters which may be changed for special purposes

LEDWITHTX	EQU		1				; Set to 1 for LED flashing with each TX byte
CALIBRATE	EQU		0				; Set to 1 to perform volts and tempterature calibration
									;	(all BMUs) in addition to BSL-programming
CALONLYONE	EQU		0				; Set to 1 to calibrate volts and temp on only 1 BMU
									;	(NOTE: IDs must be set)
									; CALIBRATE and CALONLYONE are mutually exclusive
CALTHIS		EQU		4				; The cell with this ID is used when CALONLYONE is on
CALVOLTS	EQU		3600			; Put the exact test voltage (in millivolts) here
CALVOLTOFF	EQU		0				; Fudge factor to make the measurements better
CALTEMP		EQU		19				; Ambient temperature in degrees Centigrade
DEBUG		EQU		0				; 1 for debug, e.g. copy voltage reading to $FFF0
PRESERVEIDS	EQU		1				; 1 to preserve IDs
FORCEFCAL	EQU		0				; 1 to force calibration frequency
FREQCAL		EQU		$86C0			; Value to force frequency calibration to
FORCEFCAL4	EQU		0				; 1 to force compressed 4MHz cal (temporary)
FREQCAL4	EQU		$8AA6			; Uncompressed value to set 4MHz cal to

CellVChan	EQU		$7				; ADC channel number for cell voltage
TempChan	EQU		$A				; ADC channel number for temperature
LinkVChan	EQU		$3				; ADC channel number for link voltage
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)
SLOWSAMP	EQU		1				; Use 16 uS
MHz4		EQU		1				; Use 4 MHz clock

; To get n more bits of resolution, add up 4^n samples and shift the result right by n bits.
; i.e. By adding up 4^n samples you get 2n more bits in the result,
; but half of them are noise and should be thrown away,
; leaving us with n bits of additional information.

; Address imported from the interpreter

interpretByte EQU	$F800			; Where to call the main flash code

; Locations in info-flash, of routines and calibration data
; These addresses must be manually exported to the interpreter.
; Assemble this file with listing-generation enabled, then look at the listing file
; to determine the absolute addresses to put into the interpreter.

infoInitRetAddr	EQU		mainInitRetAddr-for1000+$1000	; Return address when interpretByte is called for initialisation
infoReadByte	EQU		ReadByte	-for1000+$1000		; Where to call ReadByte when relocated to info-flash
infoWriteByte	EQU		WriteByte	-for1000+$1000		; Where to call WriteByte when relocated to info-flash
info1MHzCalB	EQU		main1MHzCalB-for1000+$1000		; Address of 1 MHz DCO range calibration when relocated to info-flash
infoID			EQU		mainID		-for1000+$1000		; Address of BMU ID byte when relocated to info-flash
info1MHzCalD	EQU		main1MHzCalD-for1000+$1000		; Address of 1 MHz DCO frequency calibration when relocated to info-flash
infoVoltCalL	EQU		mainVoltCalL-for1000+$1000		; Address of voltage scale calibration lo byte when relocated to info-flash
infoVoltCalH	EQU		mainVoltCalH-for1000+$1000		; Address of voltage scale calibration hi byte when relocated to info-flash
infoTempCal		EQU		mainTempCal	-for1000+$1000		; Address of temperature offset calibration byte when relocated to info-flash
infoLinkCal		EQU		mainLinkCal	-for1000+$1000		; Address of link voltage offset calibration byte when relocated to info-flash
info4MHzCal		EQU		main4MHzCal	-for1000+$1000		; Address of compressed 4 MHz DCO calibration when relocated to info-flash
infoPWtable		EQU		mainPWtable	-for1000+$1000		; Address of BSL password in reverse-order when relocated to info-flash
infoDataVers	EQU		mainDataVers-for1000+$1000		; Address of Data Version byte when relocated to info-flash
DATAVERS		EQU		4								; This is version 4 of the BMU info-flash data structure

; Locations in info-flash, of calibration data in previous versions of the BSL
; to allow us to update them to the current version without losing their calibration data.

; Version 3 (has $03 at infoDataVers ($10FF))
inf31MHzCalB	EQU		$1002		; Address of 1 MHz DCO range calibration when relocated to info-flash
inf3ID			EQU		$1003		; Address of BMU ID byte when relocated to info-flash
inf31MHzCalD	EQU		$1008		; Address of 1 MHz DCO frequency calibration when relocated to info-flash
inf3VoltCalL	EQU		$1009		; Address of voltage scale calibration lo byte when relocated to info-flash
inf3VoltCalH	EQU		$100F		; Address of voltage scale calibration hi byte when relocated to info-flash
inf3TempCal		EQU		$10A9		; Address of temperature offset calibration byte when relocated to info-flash
inf3LinkCal		EQU		$10C7		; Address of link voltage offset calibration byte when relocated to info-flash
inf34MHzCal		EQU		$10D5		; Address of compressed 4 MHz DCO calibration when relocated to info-flash
inf3PWtable		EQU		$10FC		; Address of BSL password in reverse-order when relocated to info-flash

; Version 2 (has $02 at infoDataVers ($10FF))
inf21MHzCalB	EQU		$1002		; Address of 1 MHz DCO range calibration when relocated to info-flash
inf2VoltCal		EQU		$1003		; Address of voltage scale calibration byte when relocated to info-flash
inf21MHzCalD	EQU		$1008		; Address of 1 MHz DCO frequency calibration when relocated to info-flash
inf2TempCal		EQU		$1009		; Address of temperature offset calibration byte when relocated to info-flash
inf2ID			EQU		$100F		; Address of BMU ID byte when relocated to info-flash
inf24MHzCal		EQU		$10FC		; Address of compressed 4 MHz DCO calibration when relocated to info-flash
inf2PWtable		EQU		$10FD		; Address of BSL password in reverse-order when relocated to info-flash

; Version 1 (has $8x at infoDataVers ($10FF))
inf1ID			EQU		$10F7		; Address of BMU ID byte when relocated to info-flash
inf1TempCal		EQU		$10F8		; Address of temperature offset calibration byte when relocated to info-flash
inf1VoltCal		EQU		$10F9		; Address of voltage scale calibration byte when relocated to info-flash
inf1PWtable		EQU		$10FA		; Address of BSL password in reverse-order when relocated to info-flash
inf14MHzCal		EQU		$10FD		; Address of compressed 4 MHz DCO calibration when relocated to info-flash
inf11MHzCalD	EQU		$10FE		; Address of 1 MHz DCO frequency calibration when relocated to info-flash
inf11MHzCalB	EQU		$10FF		; Address of 1 MHz DCO range calibration when relocated to info-flash

; New chip (has $FFFF at $10C0)
infN4MHzCalD	EQU		$10F6		; Address of 4 MHz DCO frequency calibration (presumed to be for 4 MHz, not documented by manufacturer)
infN4MHzCalB	EQU		$10F7		; Address of 4 MHz DCO range calibration (presumed to be for 4 MHz, not documented by manufacturer)
infN1MHzCalD	EQU		$10FE		; Address of 1 MHz DCO frequency calibration
infN1MHzCalB	EQU		$10FF		; Address of 1 MHz DCO range calibration

#include "msp430.h"					; #define controlled include file

; Error register. 0 means no error
#define		rERR	r4

; The LOCKA bit in FCTL3 is a *toggle*, for reasons unknown to me. Use this macro to set; write a 1 to reset later.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm


			ORG		$200			; Start of RAM
sampleBuf	ds		NumSamples*2	; Room for 4 or 16, 10-bit samples


            ORG		$FFFE			; The reset vector
;			dw		$1000			; If this BSL-writer is bootstrap-loaded
									; the reset vector will remain pointing to the BSL
									; and it will be called via interpretByte.
			dw		BSLwriter		; If this BSL-writer is JTAGged
									; the reset vector will point to it directly.
;
; BSL-writer code in main-flash.
; This code copies any existing calibration data from info-flash to the image of the new BSL
; in main-flash, then erases info-flash and copies the new BSL there from its main-flash image.
			ORG		$F800
;
; We need a dummy interpret-byte here; the BSL will call this when
; any bytes are received by the serial port, including "password" bytes.
; The BSL will also call this with a null that was not received by the serial port
; but is intended to initialise the interpreter or BSL-writer.
; It will do this on any reset and after successfully bootstrap-loading
; a new interpreter or BSL-writer.
dummyInterpretByte:
			cmp		#infoInitRetAddr,0(SP)	; Is the call merely for initialisation?
			jeq		checkNull				; No, don't echo the byte, check if it's a null
			call	#WriteByte				; Yes, echo the byte, as the BSL has not
			
checkNull	tst.b	R8						; Is this a null, meaning initialise?
			jz		anInit					; Yes, check if BSL is already updated
			bic.b	#LED,&P1OUT				; No, turn off the error LED to show successful download
			ret								; Return to the BSL
			
anInit		call	#compareImage			; Is it before the BSLwriter is run?
			jnz		BSLwriter				; Yes, start it now
			ret								; Return, hopefully safely, to the BSL

;
; Start of the actual BSL-writer
;
BSLwriter:	mov		#$280,SP
StopWDT		mov.w   #WDTPW+WDTHOLD,&WDTCTL  ; Stop Watchdog Timer
; If the calibration words get corrupted, we're probably better off not using them here:
;			MOV.B     &CALBC1_1MHZ, &BCSCTL1  ; Set range for 0.54 to 1.06 MHz
;			MOV.B     &CALDCO_1MHZ,&DCOCTL    ; Set DCO step + modulation for 1.00 MHz
			; Set P1.4 as an output as well as the LED. This will put 0V at the bottom of the link
			; voltage divider, so we can test with paralleled boards, and not have > Vcc on any
			; analogue input (trust me, you get meaningless conversions)
			mov.b	#LED+(1<<4),&P1DIR				; Set LED and P1.4 bits to output
			bic.b	#LED+(1<<4),&P1OUT				; Turn off LED and set P1.4 to 0V
			clr		rERR					; Clear error register

; Prepare to flash-program over some $FFs in the BSL image in main flash
; Assumes ACCVIE = NMIIE = OFIE = 0.
; FSSEL: 1=MCLK FN: 2=divide by 3, 5=divide by 6. Must end up in the range 257-476 kHz
			MOV     #FWKEY+FSSEL_1+3-1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV     #FWKEY,&FCTL3       ; Clear LOCK, don't toggle LOCKA
            MOV		#FWKEY+WRT,&FCTL1	; Enable write (can leave enabled; only write block that can't be)
;
; If we find $FFFF (erased flash) at $10C0 (start of info-flash protected segment A),
; then assume it's a new chip.
			cmp		#$FFFF,&$10C0	; Don't look at $1000 in case JTAG debugger is set to erase it before downloading
			jeq		newChip
			
; It's not a new chip so check the data version number at the end of info-flash.
			cmp.b	#DATAVERS,&infoDataVers
			jeq		currVersBSL
			jge		unknownVersBSL
			cmp.b	#3,&infoDataVers
			jeq		vers3BSL
			cmp.b	#2,&infoDataVers
			jeq		vers2BSL
			jl		vers1BSL


newChip
; A new chip. We want to preserve some of the existing DCO calibration data

			; Leave the voltage and temperature calibration as $FF
			mov.w	&infN4MHzCalD,R8			; 4 MHz calibration word (presumed, not documented)
			rra		R8							; Shift right
			mov.b	R8,&main4MHzCal				; Use bottom half; flash-program
			; If you ever need to restore the full word of 4 MHz calibration data, shift left one bit and OR with $8A00
			;  then find the least significant bit by trial and error.
			mov.b	&infN1MHzCalB,&main1MHzCalB	; Copy 1 MHz calibration data
			mov.b	&infN1MHzCalD,&main1MHzCalD
			jmp		donePrep
			
			
unknownVersBSL
; Version number is higher or lower than this BSL-writer knows about,
; so we should leave it alone and raise an error.
			mov		#4,rERR
			jmp		errorFlash
			

currVersBSL
; We don't preserve the ID here because the user may be rewriting the BSL specifically because
; that's the only way to erase the ID. It's easy to reset the IDs with the interpreter 'i' (SetID) command.
;			mov.b	&infoID,&mainID				; Copy ID (commented out)
#if CALONLYONE | PRESERVEIDS
			mov.b	&infoID,&mainID				; Exception: Copy ID since this is a special case, or if PRESERVEIDs is set
#endif
#if !CALIBRATE
#if CALONLYONE
			cmp.b	#CALTHIS,&mainID			; Calibrate only one... is this the one?
			jeq		noCopyCalNew
#endif
			mov.b	&infoVoltCalL,&mainVoltCalL	; Copy calibration data, since not recalibrating
			mov.b	&infoVoltCalH,&mainVoltCalH
			mov.b	&infoTempCal,&mainTempCal
;			mov.b	&infoLinkCal,&mainLinkCal
			mov.b	&infoDataVers,&mainDataVers
#endif
#if	FORCEFCAL4
			mov.b	#((FREQCAL4>>1) & $FF),&main4MHzCal	; Set compressed version of forced value
#else
			mov.b	&info4MHzCal,&main4MHzCal	; Copy compressed 4 MHz calibration
#endif
noCopyCalNew
#if FORCEFCAL
			mov.b	#FREQCAL >> 8,&main1MHzCalB
			mov.b	#FREQCAL & $FF,&main1MHzCalD
#else
			mov.b	&info1MHzCalB,&main1MHzCalB	; Copy 1 MHz calibration
			mov.b	&info1MHzCalD,&main1MHzCalD
#endif
			jmp		donePrep


vers3BSL
; We don't preserve the ID here because the user may be updating the BSL specifically because
; that's the only way to erase the ID. It's easy to reset the IDs with the interpreter 'i' (SetID) command.
;			mov.b	&infoID,&mainID				; Copy ID (commented out)
#if CALONLYONE | PRESERVEIDS
			mov.b	&inf3ID,&mainID				; Exception: Copy ID since this is a special
#endif
#if !CALIBRATE
#if CALONLYONE
			cmp.b	#CALTHIS,&mainID
			jeq		noCopyCalOld3
#endif
			mov.b	&inf3VoltCalL,&mainVoltCalL	; Copy calibration data, since not recalibrating
			mov.b	&inf3VoltCalH,&mainVoltCalH
			mov.b	&inf3TempCal,&mainTempCal
			mov.b	&inf3LinkCal,&mainLinkCal
#endif
			mov.b	&inf34MHzCal,&main4MHzCal	; Copy compressed 4 MHz calibration
noCopyCalOld3
#if FORCEFCAL
			mov.b	#FREQCAL >> 8,&main1MHzCalB
			mov.b	#FREQCAL & $FF,&main1MHzCalD
#else
			mov.b	&inf31MHzCalB,&main1MHzCalB	; Copy 1 MHz calibration
			mov.b	&inf31MHzCalD,&main1MHzCalD
#endif	
			jmp		donePrep


vers2BSL
; We don't preserve the ID here because the user may be updating the BSL specifically because
; that's the only way to erase the ID. It's easy to reset the IDs with the interpreter 'i' (SetID) command.
;			mov.b	&infoID,&mainID				; Copy ID (commented out)
#if CALONLYONE | PRESERVEIDS
			mov.b	&inf2ID,&mainID				; Exception: Copy ID since this is a special
#endif
#if !CALIBRATE
#if CALONLYONE
			cmp.b	#CALTHIS,&mainID
			jeq		noCopyCalOld2
#endif
			mov.b	&inf2TempCal,&mainTempCal
;			mov.b	#0,&mainLinkCal				; No link offset calibration in this old version
			
			; Uncompress the old compressed voltage scale factor
			mov.b	&inf2VoltCal,R8		; Get old voltage calibration figure
			rla		R8					; Shift it left one bit
			bit		#$100,R8			; Test MSB
			jnz		noSet12v2			; If it was 0
			bis		#$1000,R8			;   then bit 12 needs to be on
			jmp		set12v2
noSet12v2								; else
			bis			#$e00,R8		;   set these extra 3 bits on, leave bit 12 off
set12v2
			rla		R8					; Shift it 3 bits left
			rla		R8					; to become a 1.15 bit fixed-point number
			rla		R8
			mov.b	R8,&mainVoltCalL	; Write the voltage calibration lo byte to info-flash
			swpb	R8
			mov.b	R8,&mainVoltCalH	; Write the voltage calibration hi byte to info-flash
#endif
			mov.b	&inf24MHzCal,&main4MHzCal	; Copy compressed 4 MHz calibration
noCopyCalOld2
#if FORCEFCAL
			mov.b	#FREQCAL >> 8,&main1MHzCalB
			mov.b	#FREQCAL & $FF,&main1MHzCalD
#else
			mov.b	&inf21MHzCalB,&main1MHzCalB	; Copy 1 MHz calibration
			mov.b	&inf21MHzCalD,&main1MHzCalD
#endif	
			jmp		donePrep


vers1BSL
; We don't preserve the ID here because the user may be updating the BSL specifically because
; that's the only way to erase the ID. It's easy to reset the IDs with the interpreter 'i' (SetID) command.
;			mov.b	&infoID,&mainID				; Copy ID (commented out)
#if CALONLYONE | PRESERVEIDS
			mov.b	&inf1ID,&mainID				; Exception: Copy ID since this is a special
#endif
#if !CALIBRATE
#if CALONLYONE
			cmp.b	#CALTHIS,&mainID
			jeq		noCopyCalOld1
#endif
			mov.b	&inf1TempCal,&mainTempCal
;			mov.b	#0,&mainLinkCal				; No link offset calibration in this old version
			; Uncompress the old compressed voltage scale factor
			mov.b	&inf1VoltCal,R8		; Get old voltage calibration figure
			rla		R8
			bit		#$100,R8			; Test MSB
			jnz		noSet12v1			; If it was 0
			bis		#$1000,R8			;   then bit 12 needs to be on
			jmp		set12v1
noSet12v1								; else
			bis			#$e00,R8		;   set these extra 3 bits on, leave bit 12 off
set12v1
			rla		R8					; Shift it 3 bits left
			rla		R8					; to become a 1.15 bit fixed-point number
			rla		R8
			mov.b	R8,&mainVoltCalL	; Write the voltage calibration lo byte to info-flash
			swpb	R8
			mov.b	R8,&mainVoltCalH	; Write the voltage calibration hi byte to info-flash
#endif
			mov.b	&inf14MHzCal,&main4MHzCal	; Copy compressed 4 MHz calibration
noCopyCalOld1
#if FORCEFCAL
			mov.b	#FREQCAL >> 8,&main1MHzCalB
			mov.b	#FREQCAL & $FF,&main1MHzCalD
#else
			mov.b	&inf11MHzCalB,&main1MHzCalB	; Copy 1 MHz calibration
			mov.b	&inf11MHzCalD,&main1MHzCalD
#endif
			
donePrep

#if CALONLYONE
			cmp.b	#CALTHIS,&mainID		; When CALONLYONE is set, mainID is already programmed at this point
			jne		doneCalibrate
#endif

#if CALIBRATE | CALONLYONE
			mov		#CellVChan<<12,R8		; ADC channel for scaled cell voltage input
			call	#measure
#if DEBUG
			mov		R8,&$FFF0				; Copy voltage reading to flash
#endif

; The calibration scale factor will be the expected value divided by the reading.
; The expected value is an unsigned 12 bit integer of millivolts and
; the reading is an unsigned 12.2 bit fixed-point number of millivolts.
; We want the calibration scale factor to be represented as an unsigned 1.15 fixed-point number
; i.e. a number with 1 integer bit and 15 fractional bits.
; So we shift the expected value 17 places left before the division.
CalVoltDividend	SET	(CALVOLTS+CALVOLTOFF)<<17	; The CALVOLTOFF is just a fudge factor to make the voltage measurements come out better
			mov		#LWRD CalVoltDividend,R9	; Dividend lo word into R9
			mov		#HWRD CalVoltDividend,R10	; Dividend hi word into R10
			mov		R8,R11						; The divisor is the voltage reading in R8
			rra		R11							; Add half the divisor to the dividend for correct rounding
			add		R11,R9
			adc		R10
			call	#aUMSlashMOD				; Gives quotient in R9, remainder in R10
			
; The following disabled compression code was used in earlier versions of the BSL-writer
; when there was only one byte used to store voltage calibration. Now we use two.
; It can be deleted when this version is fully tested. !!!
#if 0		
			; We now have a number like 1 0000 cccccccx or 0 1111 cccccccx where c are the calibration bits, and x is don't care
			; We check that the 4 bits are as expected (opposite to MSB), so we can compress the other bits out
			mov		R9,R11
			bit		#$1000,R11				; Look at bit 12
			jz		vcMsbZ					; If 1
			and		#$F00,R11				;   look at next 4 bits
			jz		calVoltOk				;   if not 0
			mov		#1,rERR					;      VOLT READING TOO LOW
			jmp		startErase				;      Carry on and flash with no cal bytes
											; endif endif
vcMsbZ		and		#$F00,R11 				;   look at next 4 bits
			cmp		#$F00,R11				;   check for all 1s
			jz		calVoltOk				;   if not all 1s
			mov		#2,rERR					;      VOLT READING TOO HIGH
			jmp		startErase
calVoltOk									; endif endif
			; We can reproduce this number now from the 8 bits 8 .. 1 (so shift right)
			rra		R9
#endif

			mov.b	R9,&mainVoltCalL		; Flash write calibration value lo byte
			swpb	R9
			mov.b	R9,&mainVoltCalH		; Flash write calibration value hi byte

;
; Temperature offset calibration
; M = 4096/1.5 * (.00355 T + typ0.986)
;   = 9.694*T + typ2692
; M/9.694  = T + typ277.7
; Per the MSP430F2012 datasheet, typ277.7 aims at 273, so the reading is proportional
; to the absolute temperature, with an offset of +- 100 mV.
			; We use offsetByte = (M/9.694 - T) >> 1
; So we use offsetByte = (M/9.694 - T) - 273
; and T = M/9.694 - 273 - offsetByte
;
			mov		#TempChan<<12,R8			; ADC channel for temperature sensor
			call	#measure
			
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
			mov.b		&mainVoltCalL,R9		; Get voltage calibration lo byte
			mov.b		&mainVoltCalH,R10		; Get voltage calibration hi byte
			swpb		R10						; Assemble the two bytes into a word
			bis			R10,R9					; as multiplicand in R9
											; Multiplier is sum-of-samples, already in R8
			call		#aUMStar				; Gives unsigned product in R10 (hi word) and R9 (lo word)
											; Note: calls assembler code that ends in ret
			inc			R10						; For correct rounding
			rra			R10						; Shift product hi word right one bit

; To divide by 9.694, multiply by 65536/9.694 = 6760
			mov		R10,R8
			mov		#6760,R9
			call	#aUMStar
			sub		#CALTEMP+273,R10
;			rra		R10						; Temp offset now fits in a byte
			mov.b	R10,&mainTempCal		; Flash write temperature offset calibration value
			
#endif		/* #if CALIBRATE */


doneCalibrate


; Erase info flash including segment A. Assumes MCLK=1.00 MHz
startErase
			mov		#$1000,R12			; Start of info-flash
eraseInfo   MOV     #FWKEY,&FCTL3       ; Clear LOCK, don't toggle LOCKA
			MOV     #FWKEY+ERASE,&FCTL1 ; Enable single segment erase (doesn't seem to "stick")
            rra     @R12				; Dummy write: erase segment
			add		#64,R12				; Next segment
			cmp		#$10C0,R12
			jnz		eraseInfo			; Loop until at start of segment A
			CLRLOCKA					; Clear segment A lock (so we can erase and write it as well)
			MOV     #FWKEY+ERASE,&FCTL1 ; Enable single segment erase
            rra     @R12				; Dummy write: erase segment A

            MOV		#FWKEY+WRT,&FCTL1	; Enable write (can leave enabled; only write block that can't be)
            clr		R12       			; $1000 is start of info flash
            mov     #for1000,R9			; Start of code to write there
pifLoop		mov.w   @R9+,$1000(R12)		; Program word
            incd	R12
            cmp     #256,R12			; Test index
            jnz     pifLoop				; Repeat until done
			

            MOV     #FWKEY,&FCTL1		; Done. Clear WRT
            MOV     #FWKEY+LOCK+LOCKA,&FCTL3   ; Set LOCKs
			SETLOCKA					; Ensure segment A is locked
			;
			; Check that the flash programming worked
			;
			call	#compareImage		; Compare the for1000 image with what's at 1000
			jnz		failCompare
			
			tst		rERR
			jnz		errorFlash
			;
			; Compares successfully. Point reset vector to new code.
			; NOTE: this will erase all other interrupt vectors, and the last 512 bytes (quarter) of main-flash!
			;
			bis.b	#LED,&P1OUT			; Turn on LED briefly (BSL will turn if off) to indicate success
			MOV     #FWKEY,&FCTL3       ; Clear LOCK, don't toggle LOCKA
			MOV     #FWKEY+ERASE,&FCTL1 ; Enable single segment erase
            rra.b	&$FFFF				; Dummy write: erase segment
            MOV		#FWKEY+WRT,&FCTL1	; Enable write
			mov		#$1000,&$FFFE		; Re-point reset vector
            MOV     #FWKEY+LOCK,&FCTL3  ; Set LOCK; no accidental flash programming

#if 0		; If we do a PUC using the watchdog timer, we'll never call dummyInterpretByte to clear the error LED
			; Now we want to start the new BSL code, but we want to force a PUC (Power Up Clear).
			; We do this by allowing the watchdog timer to force a reset
			;
            mov.w   #WDTPW+WDTCNTCL,&WDTCTL    ; Reenable (and clear) the Watchdog Timer
pucWait		bis		#CPUOFF,SR			; Just sleep
			jmp		pucWait				; till the watchdog timer fires
#else
			bic.b	#WDTIFG,&IFG1		
			br		#$1000				; Start the new BSL
#endif

failCompare mov		#3,rERR
errorFlash	mov		rERR,R11
			add		R11,R11
errFlashLp	xor.b	#LED,&P1OUT			; The best we can do is freeze and flash LED
delay		dec		R12
			jnz		delay
count		dec		R11
			jnz		errFlashLp
			;
			; Pause between rErr flashes
pause		mov		#5,R11
pauseL		dec		R12
			jnz		pauseL
			dec		R11
			jnz		pauseL
			jmp		errorFlash
			
#if 0
;
; Voltage and temperature measurement. Enter with R8 = channel number in most significant nibble (bits 15-12).
; Result is in R8 as a 12.2 bit fixed-point number of millivolts
;
voltMeasure:
;
; Initialise the ADC10 system
;
; SREF_1 = 4 volt mode (internal 1.5 V reference); ADC10SHT_3 = 64 ADC10CLKs (~ 13 uS sample time)
; MSC = continuous sampling; REFON = turn on internal reference; ADC10ON = power up the ADC system
; REFOUT = turn on reference buffer; REFBURST = turn on buffer only when needed
#if SLOWSAMP
		mov			#SREF_1+ADC10SHT_2+MSC+REFON+ADC10ON,&ADC10CTL0
#else
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON,&ADC10CTL0
#endif
; INCH_7 = ADC7 (VDIV); SHS_0 = software start; ADC10SSEL_0 = ADC10OSC; CONSEQ_2 = repeat-single-channel
		; Note that R8 has the channel number already in the right position
#if SLOWSAMP
		bis			#SHS_0+ADC10SSEL_2+CONSEQ_2,R8
#else
		bis			#SHS_0+ADC10SSEL_0+CONSEQ_2,R8
#endif
		mov			R8,&ADC10CTL1
		mov.b		#(1<<7)+(1<<3),&ADC10AE0; Enable P1.7and P1.3 as analogue inputs
		mov.b		#NumSamples,&ADC10DTC1	; Typ. 4 or 16 conversions
		mov			#sampleBuf,&ADC10SA		; Set start address
		bis			#ENC+ADC10SC,&ADC10CTL0	; Start conversion
convert	bit			#ADC10IFG,&ADC10CTL0	; Done conversion?
		jz			convert					; No, busy wait
		bic			#ADC10ON+ENC+ADC10SC,&ADC10CTL0	; Turn off the ADC
		;
		; Sum the samples
		;
		mov			#sampleBuf,R11
		mov			#0,R8			; Initialise sum
addSamp	add			@R11+,R8		; Add a sample
		cmp			#sampleBuf+2*NumSamples,R11
		jnz			addSamp
		ret
#else
#include "../common/measure.s43"
#endif

;
; Unsigned divide: R10:R9 / R8 -> R9, remainder to R10
;
aUMSlashMOD:				 ; Divide with quotient and remainder
		cmp     R8,R10   ; Overflow?
		jc      oflo     ; Jump to error exit if divide by zero or overflow.
		mov     #16,R11  ; Do 16 times

ummlp	rla     R9       ; Shift quotient left and simul. shift dividend lo
		rlc     R10      ;   into dividend hi
		jc      umm2     ; If carry OR
		cmp     R8,R10
		jlo     umm1     ;   no carry AND remainder-so-far >= divisor
umm2	sub     R8,R10   ;     Subtract divisor from remainder-so-far
		bis     #1,R9    ;     Set low bit of quotient-so-far
						 ; Endif
umm1	dec     R11      ; Decrement loop counter
		jnz     ummlp    ; Loop until zero
		ret
		
oflo	mov		#-1,R10
		mov		#-1,R9
		ret

; UM* R8 * R9 -> R10:R9 (R10 most significant)
; All values and arithmetic are unsigned.
; Algorithm described in http://cs.hiram.edu/~walkerel/cs252/multiply.ppt

aUMStar:
		; Starts with 16 bit multiplicand in R8, multiplier in R9 and
		; ends with 32 bit product in R10 (hi) and R9 (lo).
		clr		R10			; Clear hi word of product so far
		mov		#16,R11		; Do 16 times

mullp	bit		#1,R9		; Test low bit of multiplier
		jz		mulz		; If it's a 1
		add		R8, R10		;   add multiplicand to product hi word; Endif
mulz	rrc		R10			; Shift product hi word (incl. carry) right
		rrc		R9			; into product lo and simul. shift multiplier right
		dec		R11			; Decrement loop counter
		jnz		mullp		; Loop until zero

		ret

;
; Compare the 256 bytes at for1000 with what's at $1000. Returns with Z set if OK, Z clear if not
compareImage:
			clr		R12
cmpLoop		cmp		$1000(R12),for1000(R12)
			jnz		justRet
			incd	R12
			cmp		#256,R12
			jnz		cmpLoop
justRet		ret


; ----------------------------------------------------------------------------
; The bootstrap loader (BSL)
;
; This will be relocated to info-flash which starts at $1000.

; Bits in i/o port 1
; Prefer that RXD is bit 0-3, so that RXD can be constant-generated
RXD			EQU		1<<2			; Receive data on P1.2 (bit number >3 costs 3 words)
; Prefer TXDm is bit 2 at most, so that TXDp is at most 8 and can be constant-generated
TXDm		EQU		1<<0			; Normally 1<<n is n < 4 for compactness (costs 1 word if not)
TXDp		EQU		1<<1			; Code requires TXD+ bit somewhere to left of TXD- bit
BYPASS		EQU		1<<5			; Bypass transistor on pin P1.5
LED			EQU		1<<6			; LED on bit 6

#define		Rstate	R15				// Register holding the state of the password checking FSM
#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading


for1000:	; This will be relocated to info-flash at $1000.

			; The next 3 instructions are all byte immediate instructions,
			; where the immediate operand does not come from a constant generator,
			; so the high byte of the immediate operand word is unused.
			; To save space, we use these high bytes for various calibration values.
			; Some of these are filled in by the BSL writer.
			
;			mov.b	main1MHzCalB,&BCSCTL1	; Set range for 0.54 to 1.06 MHz
			dw		$40F2			; Opcode for mov.b #src,&dst
main1MHzCalB ds		1				; 1 MHz MCLK frequency cal value (byte 1 of 2) always written by BSL writer
mainID		ds		1				; Cell/BMU identifier byte; first cell is 0; only written by interpreter i cmd
			dw		BCSCTL1
			
;			mov.b	main1MHzCalD,&DCOCTL ; Set DCO step + modulation for 1.00 MHz
			dw		$40F2			; Opcode for mov.b #src,&dst
main1MHzCalD ds		1				; Second 1 MHz MCLK cal value; always written by BSL writer
mainVoltCalL ds		1				; Voltage scale calibration lo byte; may be written by BSL writer
			dw		DCOCTL
			
;			bis.b	#TXDp+TXDm+BYPASS+LED,&P1DIR ; Set TXDs, BYPASS and LED as outputs
			dw		$D0F2			; Opcode for bis.b #src,&dst
			db		TXDp+TXDm+BYPASS+LED
mainVoltCalH ds		1				; Voltage scale calibration hi byte; may be written by BSL writer
			dw		P1DIR
			
			mov.b	#TXDp,&P1OUT	; Set TXD state to idle, bypass and LED off
			mov		#$280,SP
main:		; This label is partly for the debugger, but is also the start of the main loop.

			; Initialise the interpreter (or BSL-writer), if possible
			clr.b	R8				; A null to pass to interpretByte (if allowed) to initialise the main-flash code
			call	#testNoInterp-for1000+$1000	; Address adjusted for BSL's relocation to info-flash
mainInitRetAddr:	; Used by BSL-writer and interpreter to tell if the byte in R8 should be echoed or not	
			; Password-checking finite-state-machine (FSM)
			; After decrementing Rstate below, 2 = waiting for ^B, 1 = waiting for ^A,
			; 0 = waiting for ^D and erase if received, any negative value = program, no interpret
			;
resetFSM:	mov		#3,Rstate		; Initialise FSM: waiting for ^B
FSMloop:	call	#ReadByte-for1000+$1000	; Address adjusted for BSL's relocation to info-flash

			dec		Rstate
			jn		progByte		; If state is negative, program, don't interpret

			; Check for a continuing password match
            cmp.b	infoPWtable(Rstate),R8	; Address adjusted for BSL's relocation to info-flash
			jne		resetFSM
			tst		Rstate
			jnz		FSMloop

			; Erase main flash memory
			; Master will need to delay at least 33 ms before sending first byte to program.
			;
			dint					; Main-flash has probably turned on interrupts; can't have them now
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
            mov		#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
            mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

            mov		#$F800+2,R12	; Start of main flash +2. The +2 to start saves a 2-word compare to stop
			; Could save a reg by using Rstate also as the programming address counter
			;  but we'd be forced to send the data in reverse order.
			; This would not save any space (compare-against-F800 to stop versus initialise-to-F800 to start).

            mov		#FWKEY+MERAS,&FCTL1 ; Enable bulk segment erase
            rra		@R12			; Dummy write: erase segments
			
			; Immediately replace reset vector to this boot loader
            mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled; only write-block that can't be)
            mov		#$1000,&$FFFE	; Write the reset vector to point to the start of info-flash (start of BSL)
            clr.b	Rcksum			; Initialise the checksum to 0
			; Assume a bad checksum, clear on good checksum. Also prevents interpreting till the end of flash programming			
            bis.b	#WDTIFG,&IFG1
			jmp		FSMloop			; Read first byte to program

			; Program (flash write) byte in R8
			;
progByte    mov.b	R8,-2(R12)		; Program it
            xor.b	R8,Rcksum		; Include in check-XOR
            inc		R12
            jnz		FSMloop			; Repeat until R12 wraps to zero

            mov		#FWKEY,&FCTL1	; Done. Clear WRT
            mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
            tst.b	Rcksum			; Check the checksum
            jnz		resetFSM		; If bad checksum, leave the no interpret flag set
			
            bic.b	#WDTIFG,&IFG1	; Good checksum, reset no interpret flag
            jmp		main			; Back to looking for ^B, but first send a null to interpretByte
			
			; end FSM code

; ReadByte ( regs: -- R8 R9 R10 R11 R13 )
; Reads a byte from serial input to R8. Trashes R9 R10 R11 R13.
; Also echoes the byte to serial output (by falling through to WriteByte)
;
ReadByte:
			mov.w   #WDTPW+WDTHOLD,&WDTCTL  ; Stop Watchdog Timer
waitStartR  						; (Number of cycles)
            bit.b   #RXD,&P1IN		; (4) Start bit?
            jnz     waitStartR		; (2) Loop while not 0 (start bit)
			; The above loop takes 6 cycles so on average we will have missed the start bit by
									; (3) cycles
            mov.w   #WDTPW+WDTCNTCL,&WDTCTL ; (5) Clear and restart Watchdog Timer

			; Put these necessary moves here to put time between first sample of start bit
			; and the glitch check, in case the glitch is wide
            mov     #8,R10			; (1) Bit count
			
;           mov.b   #41,R11			; (2) Loop count for waitMid delay loop
			dw		$407B			; Opcode for mov.b #src,R11 (LS-nibble is reg num)
			db		41				; Immediate src operand
mainTempCal	ds		1				; Temperature offset calibration; may be written by BSL writer
			
checkstart  bit.b   #RXD,&P1IN		; (4) Test the serial line
            jnz     ReadByte		; (2) Glitch: ignore
			; Pad out the average delay between starting edge of start bit
			; and middle sample of first bit below to ~ 1.5 bittimes = 156 cycles.
			; 32 + 3*41 = 155 cycles
waitMid     dec     R11				; (1) Delay loop
            jnz     waitMid			; (2) Note: Clearing of R11 by this loop is assumed below
			;
			; Second part of noise immunity: sample line 3 times and take majority vote
			;
			; RX_bit loop is 1 + 8*3 + 4 + 3*24 + 3 = 104 cycles long (1MHz/9600baud)
RX_Bit      mov     #3-1,R13		; (1) Sample count (3 samples) but #2 uses one less instruction word
RX_sample   bit.b   #RXD,&P1IN		; (4) Sampled bit to carry
            addc    #0,R11			; (1) Add into R11 count
TwentyNine	; This location is used as a source of the constant 29 (first byte of "dec r13" opcode)
			; for the purpose of a space-saving trick in WriteByte below.
            dec     R13				; (1) Decrement sample counter
            jc      RX_sample		; (2) #2 is one less, so jump on carry (not borrow) rather than zero

            cmp     #2,R11			; (1) Carry set (borrow clear) if R11 >= 2
            rrc.b   R8				; (1) Store received (inverted) bit

;			mov.b   #24,R11			; (2) Pad RX_bit loop out to 104 cycles
			dw		$407B			; Opcode for mov.b #src,R11 (LS-nibble is reg num)
			db		24				; Immediate src operand
mainLinkCal	ds		1				; Link voltage offset calibration data; may be written by BSL writer

waitNextR   dec     R11				; (1) Delay loop
            jnz     waitNextR		; (2) Note: Clearing of R11 by this loop is assumed in WriteByte below
            dec     R10				; (1) All bits RXed?
            jnz     RX_Bit			; (2) Sample next bit
			
			; Normally there would be a 1 bit delay here so we return in the middle of the stop bit, so
			; calling ReadByte soon after returning doesn't mistake a zero in the MSB as a start bit.
			; But it's not needed, since we always echo before waiting for the next byte
			
testNoInterp
			bit.b	#WDTIFG,&IFG1	; Test the no interpret bit (due to watchdog or checksum error)
			jnz		WriteByte		; Jump around call, if set
			br		#interpretByte	; tail-call interpretByte in main flash
									; It must preserve at least R8, Rstate(=R15)
			
; WriteByte ( R8 R11 -- R9 R10 R11 )
; Write the low byte of R8 to serial output. R11 must be clear on entry.
; Trashes R9 R10 R11. Preserves R8.
;
WriteByte:
            mov		R8,R9			; Allow R8 to be preserved for password compare
			
;			mov.b	#10,R10			; 8 data + 1 start and 1 stop
			dw		$407A			; Opcode for mov.b #src,R10 (LS-nibble is reg num)
			db		10				; Immediate src operand
main4MHzCal	ds		1				; Compressed 4 MHz DCO range and frequency calibration byte

            rla		R9				; Add a start  bit
            bis		#1<<9,R9		; Add a stop bit
		
write_next	; write_next loop is 14 + 3*29 + 3 = 104 cycles long (1MHz/9600baud)
									; (Number of cycles)
            rrc		R9				; (1) Next bit to C.
									;     R11 must be guaranteed clear in advance
            subc.b	#TXDp,R11		; (1) 1111(1)(0)00b if C, 1111(0)(1)11b if NC
            xor.b	&P1OUT,R11		; (3) Determine if TXD bits need toggling
#if LEDWITHTX
			; The below will actually turn the LED on for every bit sent. It's not how I meant it to be.
			; But it works well enough.
	; Spare high byte in immediate argument below, could be used for more calibration data
			and.b	#TXDp+TXDm+LED,R11 ; (2) Ensure only TXD and LED bits can be toggled below
#else
            and.b	#TXDp+TXDm,R11	; (alt 2) Ensure only TXD bits can be toggled below
#endif
            xor.b	R11,&P1OUT		; (4) Toggle as needed, to send bit
            ; We need to pad this loop with an extra cycle, so it takes 104 cycles
			; which corresponds to 9600 baud with a 1 MHz clock.
			; But we can't afford to waste space on a NOP.
			; So we waste a cycle below by loading the constant 29 from elsewhere
			; in the code, instead of as an immediate operand. Pretty tricky huh?
			; Note that it's a PC-relative operand (no "&") so it will still work after
			; relocation to info-flash.
			; mov.b		  #29,R11
			mov.b	TwentyNine,R11	; (3) Set the delay counter to 29
write_dly   dec		R11				; (1)
            jnz		write_dly		; (2)
            dec		R10				; (1)
            jnz		write_next		; (2)
			ret

endFor1000:

lengthForInfo EQU	endFor1000-for1000	; Must be <= 256-1-3 = 252 = $FC

			ORG     for1000+$FC
			; Could save space by making the password a simple function of Rstate instead of storing it
mainPWtable	db		4,1,2			; The password backwards: ^D ^A ^B
mainDataVers db		DATAVERS		; Data Version byte (cannot move)

; The end of the bootstrap loader (BSL)
; -----------------------------------------------------------------------------


			ORG		$FD00			; Short test program for processor Frequency Derivation. Handy when lose the frequency calibration values.
											; Note: Don't put at $FE00 or later; gets erased by the code to rewrite the restart vector
			mov		#$280,SP
			mov.w   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer

            mov.b	#0,&P1OUT   	; Set TXD outputs the same, bypass and LED off
            bis.b	#TXDp+TXDm+BYPASS+LED,&P1DIR ; Set TXDs, LED and BYPASS as outputs
#if	MHz4
			mov.b	info4MHzCal,R8			; Get compressed 4MHz calibration
			rla		R8						; Uncompress
			bis		#$8A00,R8				; OR in assumed MSBs
			swpb	R8						; Get MSB (might be important to write first)
			mov.b	R8,&BCSCTL1				; Write MSB
			swpb	R8
			mov.b	R8,&DCOCTL				; and LSB
#else
            mov.b	&info1MHzCalB,&BCSCTL1 ; Set range for 0.54 to 1.06 MHz
            mov.b	&info1MHzCalD,&DCOCTL  ; Set DCO step + modulation for 1.00 MHz
#endif

			call	#flash20

;
; Fastest possible toggle: 7 cycles, or 1000/14 = 71.4 kHz @ 1 MHz, or 2000/14 = 142.9 kHz @ 2 MHz
; or 4000/14 = 285.7 kHz @ 4 MHz
			mov.w   #WDTPW+WDTHOLD,&WDTCTL  ; Stop Watchdog Timer
fastFlash
			xor.b	#LED+TXDp+TXDm,&P1OUT	; Toggle the LED and both transmit outputs at the same time
											; This won't upset the next BMU, if in-situ, and the frequency
											; can be tested from above the board
;			mov		#30000,R12				; Longer delay (slower flash)
;delay		dec		R12
;			jnz		delay
			jmp		fastFlash

flash20		mov		#20,R11
first		xor.b	#LED,&P1OUT
			mov		#20000,R12			; Longer delay (slow flash)
delay1      mov.w   #WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart Watchdog Timer
			dec		R12					; 7 cycle loop
			jnz		delay1
			dec		R11
			jnz		first
			ret

            END
