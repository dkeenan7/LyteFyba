; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve the Bootstrap Loader and calibration data.
			COL		150				; Nice wide listings
; This is a Bootstrap-loader writer (BSL-writer) for an MSP430F2012 microcontroller.
;
; It was developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; This BSL-writer should be the first program written to the 2kB of main-flash
; on the MSP430F2012.
; This must be done using a flash programmer connected to the chip's JTAG port.
; The BSL-writer contains a copy of a bootstrap loader (BSL).
; It writes this BSL to the 256 bytes of info-flash, while preserving some of the
; digitally controlled oscillator (DCO) calibration bytes that are stored there
; by the chip manufacturer.
; It may also be configured to perform voltage and temperature calibrations
; and store this calibration data in info-flash as well.
; It then passes control to the BSL.

; The BSL consists of a software UART providing RS422-style serial communications,
; and a password-recognising state-machine.
; The state-machine normally passes incoming serial data to a command interpreter
; in main-flash.
; But when the password is recognised, the state-machine instead writes incoming serial data
; to main-flash. The password is Ctrl-C, Ctrl-B Ctrl-A, Ctrl-@.
; This allows it to overwrite the BSL-writer with the initial command interpreter, sent
; via the serial input.
; And because the BSL transmits all data received on its serial input, to its serial output,
; a cascaded series of these MSP boards can all be updated simultaneously.
; You only need to send a new version of the command interpreter to the first board
; in the chain.
;
; But what if you want to update the BSL itself?
; In that case, instead of sending a new interpreter, you send this BSL-writer
; carrying the new version of the BSL.
; This time you send the BSL-writer via the serial input not the JTAG port.
; That way you will update the BSLs of all the MSP boards in the chain simultaneously.
;
; The existing BSL will dutifully load the BSL-writer into main flash,
; completely unaware that it has just loaded the instrument of its own demise.
; When the old BSL calls the BSL-writer, thinking it is initialising a new interpreter,
; the BSL-writer will write the new BSL to info-flash and pass control to it.
; Then the interpreter must be sent again, to replace the BSL-writer.
; The BSL-writer still preserves the calibration data, which may now include
; voltage and temperature calibration data in addition to the DCO calibration data
; from the manufacturer.
;
; The BSL code is made to fit in the tiny 256 bytes of info-flash because
; this segment can be protected when the rest of the flash is erased,
; and all other flash segments are 512 bytes and contiguous with each other,
; but not with info-flash.
;
; For this reason, the BSL code is highly hand-optimised for space and
; uses some tricks that may make it hard to follow and hard to modify.
;
; The following is true of this BSL-writer, and the BSL itself
;	They use no interrupts, since the interrupt vectors will be reprogrammed.
;	They use no timer; too many 6-byte instructions!
; The BSL serial input code does not check for false start bits or do majority voting on data bits.

; Conditional assembly parameters which may be changed for special purposes

PCBVERSION  EQU		57				; Before ver 57 there was no Activity LED or Piezo. Different pinouts
CALIBRATE	EQU		0				; Set to 1 to perform volts and temperature calibration
									;	(all BMUs) in addition to BSL-programming
CALONLYONE	EQU		0				; Set to 1 to calibrate volts and temp on only 1 BMU
									;	(NOTE: IDs must be set)
									; CALIBRATE and CALONLYONE are mutually exclusive
CALTHIS		EQU		4				; The cell with this ID is used when CALONLYONE is on
CALVOLTS	EQU		3600			; Put the exact test voltage (in millivolts) here
CALTEMP		EQU		19				; Ambient temperature in degrees Celsius
DEBUG		EQU		0				; 1 for debug, e.g. copy voltage reading to $FFF0
RESETIDS	EQU		0				; 1 to generate new IDs starting from byte read serially
FORCEFCAL	EQU		0				; 1 to force 8 MHz calibration frequency
FREQCAL		EQU		$8D8B			; Value to force 8 MHz frequency calibration to
FREQ4TO8	EQU		$3B				; Subtract from low byte of 4 MHz DCO cal to estimate 8 MHz cal
ADCBUF		EQU		0				; 0 for no ADC sample buffer; 1 for buffer


; ADC channel numbers
CellVChan	EQU		$7				; ADC channel number for cell voltage
TempChan	EQU		$A				; ADC channel number for temperature
#if PCBVERSION < 57
LinkVChan	EQU		$3				; ADC channel number for link voltage
#else
LinkVChan	EQU		$6				; ADC channel number for link voltage
#endif
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)

; To get n more bits of resolution, add up 4^n samples and shift the result right by n bits.
; i.e. By adding up 4^n samples you get 2n more bits in the result,
; but half of them are noise and should be thrown away,
; leaving us with n bits of additional information.

; Address imported from the interpreter (monitor or debugger)

interpretByte EQU	$F800			; Where to call the main flash code

; Locations in info-flash, of routines and calibration data
; These addresses must be manually exported to the interpreter and monitor.
; Assemble this file with listing-generation enabled, then look at the listing file
; to determine the absolute addresses to put into the interpreter.

infoInitRetAddr	EQU		mainInitRetAddr-for1000+$1000	; Return address when interpretByte
														; is called for initialisation
infoReadByte	EQU		ReadByte	-for1000+$1000		; Where to call ReadByte
infoWriteByte	EQU		WriteByte	-for1000+$1000		; Where to call WriteByte
infoBSLErase	EQU		mainBSLErase-for1000+$1000		; Where to jump in to erase main flash

infoVoltCal		EQU		mainVoltCal -for1000+$1000		; Address of voltage scale calibration word
infoTempCal		EQU		mainTempCal	-for1000+$1000		; Address of temperature offset calibration byte
infoLinkCal		EQU		mainLinkCal	-for1000+$1000		; Address of link voltage offset cal byte
info8MHzCalD	EQU		main8MHzCalD-for1000+$1000		; Address of 8 MHz DCO frequency calibration
info8MHzCalB	EQU		main8MHzCalB-for1000+$1000		; Address of 8 MHz DCO range calibration
infoID			EQU		mainID		-for1000+$1000		; Address of BMU ID byte
infoDataVers	EQU		mainDataVers-for1000+$1000		; Address of Data Version byte
DATAVERS		EQU		6						; This is version 6 of the BMU info-flash data structure

; Locations in info-flash, of calibration data in previous versions of the BSL
; to allow us to update them to the current version without losing their calibration data.

; Version 5 (has $05 at infoDataVers ($10FF))
inf5InitRetAddr	EQU		$1022		; Return address when interpretByte
									; is called for initialisation
inf5ID			EQU		$10F2		; Address of BMU ID byte
inf5Spare		EQU		$10F3		; Address of BMU ID byte
inf51MHzCalD	EQU		$10F4		; Address of 1 MHz DCO frequency calibration
inf51MHzCalB	EQU		$10F5		; Address of 1 MHz DCO range calibration
inf54MHzCalD	EQU		$10F6		; Address of 4 MHz DCO frequency calibration
inf54MHzCalB	EQU		$10F7		; Address of 4 MHz DCO range calibration
inf5VoltCal		EQU		$10F8		; Address of voltage scale calibration word
inf5TempCal		EQU		$10FA		; Address of temperature offset calibration byte
inf5LinkCal		EQU		$10FB		; Address of link voltage offset calibration byte
inf5PWtable		EQU		$10FC		; Address of BSL password in reverse-order
inf5DataVers	EQU		$10FF		; Address of Data Version byte

; New chip (has $FFFF at $10C4)
infNVoltCal		EQU		$10E0		; Address of 1.5 V internal ref scale calibration
infNTemp30Cal	EQU		$10E2		; Address of 1.5 V internal ref 30°C temp reading calibration
infN8MHzCalD	EQU		$10FC		; Address of 8 MHz DCO frequency calibration
infN8MHzCalB	EQU		$10FD		; Address of 8 MHz DCO range calibration

; Interpreter Register Usage
;	Registers 0 thru 3 are dedicated machine registers (PC SP SR CG).
#define 	Rip		R5				// Virtual machine instruction pointer
#define 	Rlit	R6				// Holds partial literals
#define 	Rw		R8				// Working register - temporary - anyone can use

			LSTOUT-
#include "msp430.h"
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
			LSTOUT+

; Error register. 0 means no error
#define		rERR	r4

; The LOCKA bit in FCTL3 was made a *toggle*, for backwards compatibility.
; Use these macros to safely clear and set it.
CLRLOCKA	macro
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			_IF		_NZ					; Currently locked?
				MOV		#FWKEY+LOCKA,&FCTL3 ; Yes, unlock
			_ENDIF
			endm

SETLOCKA	macro
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			_IF		_Z					; Currently unlocked?
				MOV		#FWKEY+LOCKA,&FCTL3 ; Yes, lock
			_ENDIF
			endm


			ORG		$200			; Start of RAM
#if ADCBUF
sampleBuf	ds		NumSamples*2	; Room for 4 or 16, 10-bit samples
#endif


; BSL-writer code in main-flash.
; This code copies any existing calibration data from info-flash to the image of the new BSL
; in main-flash, then erases info-flash and copies the new BSL there from its main-flash image.
			ORG		$F800
;
; We need a dummy interpret-byte here; the BSL will call this when
; any bytes are received by the serial port, including "password" bytes.
; The BSL will also call this with a null that was not received by the serial port
; but is intended to initialise the interpreter or BSL-writer.
; It will do this on any reset and after successfully bootstrap-loading
; a new interpreter or BSL-writer.
dummyInterpretByte:
			cmp.b	#DATAVERS,&infoDataVers
			_IF		_EQ
				cmp		#infoInitRetAddr,0(SP)	; Is the call merely for initialisation?
			_ELSE
				cmp		#inf5InitRetAddr,0(SP)	; Is the call merely for initialisation?
			_ENDIF
			jeq		anInit					; Yes, don't echo the byte
#if RESETIDS
			cmp		#waitingIDAddr,0(SP)	; Is the call from the waitingID call to ReadByte?
			jnz		noWaitID				; If not, echo as usual
			ret								; Yes, so return to ReadByte's caller (BSL below),
											;	without calling WriteByte (don't echo wrong ID)
noWaitID
#endif
			call	#WriteByte				; No, not initialise call, echo the byte, as the BSL has not
#if PCBVERSION < 57
			bic.b	#LED,&P1OUT				; Turn off the error LED
#else
			bis.b	#ACTLED,&P1OUT			; Turn off the (inverted) activity LED
#endif
			ret								; Return to the BSL

anInit:		cmp		#$FFFF,&main8MHzCalD	; Have we already run once?
			jeq		main					; No, start the BSLwriter (e.g. after downloading)
			ret								; Yes, don't infinitely loop and don't erase and write the
											; info-flash again just because the power cycled or something
;
; Start of the actual BSL-writer
;
main:										; For debugger
BSLwriter:	mov		#$280,SP
StopWDT		mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer

			; Initialise MCLK (4 MHz)
			mov.b	#DIVM_1,&BCSCTL2				; MCLK = DCOCLK/2
			
			; Temporary fix for vers 5 data
	; !!! Needs to handle the new-chip case as well. And the case of an unknown version. !!!
	#if FORCEFCAL
			mov.b	#FREQCAL >> 8,&BCSCTL1			; Set 8 MHz DCOCLK value
			mov.b	#FREQCAL & $FF,&DCOCTL
	#else
			cmp.b	#5,&infoDataVers
			_IF		_EQ
				mov.b	#$8D,&BCSCTL1				; Set RSELx = 13 for 8 MHz range
				mov.b	&inf54MHzCalD,R8			; Load low byte of vers5 4MHz calibration
				sub.b	#FREQ4TO8,R8				; Try to estimate the 8MHz low byte
				mov.b	R8,&DCOCTL					; Set DCOx and MODx
			_ELSE
				mov.b	&info8MHzCalB,&BCSCTL1		; Works for new chip or vers 6 data
				mov.b	&info8MHzCalD,&DCOCTL		;  but not other data versions (use FORCEFCAL)
			_ENDIF
	#endif

#if PCBVERSION < 57
			; Set P1.4 (the Vref+ pin) as an output as well as the LED. This will put 0V at the
			; bottom of the link voltage divider, so we can test with paralleled boards,
			; and not have > Vcc on any analogue input (trust me, you get meaningless conversions)
			mov.b	#TXDp,&P1OUT				; Turn off LED and bypass; set TXDp
			mov.b	#LED+(1<<4)+TXDp+TXDm,&P1DIR ; Set LED, P1.4, and TX bits to output
#else
			mov.b	#ACTLED+TXDp,&P1OUT			; Turn off (inverted) ActLED and set TXDp
			mov.b	#ACTLED+(1<<4)+TXDp+TXDm,&P1DIR ; Set ActLED, P1.4, and TX bits to output
			mov.b	#0,&P2SEL 					; Set BYPASS and ERRLED to not be crystal osc pins
			mov.b	#0,&P2OUT					; Set BYPASS and ERRLED off
			mov.b	#$FF,&P2DIR 				; Set BYPASS and ERRLED as outputs
#endif
			clr		rERR						; Clear error register

; Prepare to flash-program over some $FFs in the BSL image in main flash
; Assumes ACCVIE = NMIIE = OFIE = 0.
; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz
			MOV		#FWKEY+FSSEL_1+FN0*(12-1),&FCTL2 ; For 4 MHz MCLK
			MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write-block cant be)
			
;
; If RESETIDS is set, read the ID here.
; It just doesn't seem to work out to use the delay between BMUs to determine the correct ID, so
; we simply read the ID from the serial port, and echo the next ID downstream.
; As a sanity check, expect an "I" first; this ensures that the CPU speed is about right
#if RESETIDS
			call	#ReadByte				; This byte is echoed
			cmp		#'I',R8					; The sanity check for serial speed
			jeq		gotI					; Branch if correct
			mov		#2,rERR
			jmp		errorFlash				; Flash error LED twice
gotI
			call	#ReadByte				; Read the byte into R8, don't echo it, trashes R9 R10 R11
											; Not echoed because of logic in dummyInterpretByte
waitingIDAddr								; This address will be on the stack in dummyInterpretByte
			mov		R8,R12					; Save our ID
			inc		R8
			call	#WriteByte				; Send downstream BMU's ID
#if PCBVERSION < 57
			bic.b	#LED,&P1OUT				; Clear LED set by WriteByte
#else
			bis.b	#ACTLED,&P1OUT			; Turn off (inverted) Activity LED turned on by WriteByte
#endif
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (ReadByte has re-set)
			mov.b	R12,&mainID				; Flash write our ID
#endif // RESETIDS

;
; If we find $FFFF (erased flash) at $10C4 (near start of info-flash protected segment A),
; then assume it's a new chip.
			cmp		#$FFFF,&$10C4	; Don't look at $1000 in case JTAG debugger is set to erase it
			jeq		newChip			;	before downloading
			
; It's not a new chip so check the data version number at the end of info-flash.
			cmp.b	#DATAVERS,&infoDataVers
			jeq		currVersBSL
			jge		unknownVersBSL
			cmp.b	#5,&infoDataVers
			jeq		vers5BSL
;			cmp.b	#4,&infoDataVers
;			jeq		vers4BSL
			jl		unknownVersBSL


newChip
; A new chip. We want to preserve some of the existing DCO and ADC10 calibration data

			mov.w	&infNVoltCal,&mainVoltCal	; Copy ADC10 voltage scale calibration data

			mov.w	&infNTemp30Cal,R8			; Get 10 bit 30°C result as multiplier in R8
			rla		R8							; Shift it 4 bits left
			rla		R8
			rla		R8
			rla		R8
			mov.w	&mainVoltCal,R9				; Get voltage calibration word as multiplicand in R9
			call	#UMStar						; Gives unsigned product in R10 (hi word) & R9 (lo word)
			mov		R10,R8
			mov		#6760,R9					; To divide by 9.694 counts/°C, multiply by 65536/9.694 = 6760
			call	#UMStar
			inc		R10							; For correct rounding add one and
			rra		R10							;   shift product hi word right one bit
			sub		#30+273,R10					; Temp offset should now fit in a byte
			mov.b	R10,&mainTempCal			; Flash write temperature offset calibration value

			mov.b	#0,&mainLinkCal				; Set link offset cal to zero
			mov.b	&infN8MHzCalB,&main8MHzCalB	; Copy DCO 8 MHz calibration data
			mov.b	&infN8MHzCalD,&main8MHzCalD
			jmp		donePrep
			
			
unknownVersBSL
; Version number is higher or lower than this BSL-writer knows about,
; so we program it anyway (as if current version) but alert the user afterwards
			mov		#4,rERR
			

currVersBSL
#if !RESETIDS
			mov.b	&infoID,&mainID				; We preserve the IDs unless RESETIDs is on
#endif
#if !CALIBRATE
#if CALONLYONE
			cmp.b	#CALTHIS,&mainID			; Calibrate only one... is this the one?
			jeq		noCopyCalNew
#endif
			mov.w	&infoVoltCal,&mainVoltCal	; Copy calibration data, since not recalibrating
			mov.b	&infoTempCal,&mainTempCal
			mov.b	&infoLinkCal,&mainLinkCal
#endif
noCopyCalNew
#if	FORCEFCAL
			mov.b	#FREQCAL >> 8,&main8MHzCalB
			mov.b	#FREQCAL & $FF,&main8MHzCalD
#else
			mov.b	&info8MHzCalB,&main8MHzCalB	; Copy 8 MHz calibration
			mov.b	&info8MHzCalD,&main8MHzCalD
#endif
			jmp		donePrep


vers5BSL
#if !RESETIDS
			mov.b	&inf5ID,&mainID				; We preserve the IDs unless RESETIDs is on
#endif
#if !CALIBRATE
#if CALONLYONE
			cmp.b	#CALTHIS,&mainID
			jeq		noCopyCalOld5
#endif
			mov.w	&inf5VoltCal,&mainVoltCal	; Copy calibration data, since not recalibrating
			mov.b	&inf5TempCal,&mainTempCal
			mov.b	&inf5LinkCal,&mainLinkCal
#endif
noCopyCalOld5
#if	FORCEFCAL
			mov.b	#FREQCAL >> 8,&main8MHzCalB
			mov.b	#FREQCAL & $FF,&main8MHzCalD
#else
			mov.b	#$8D,&main8MHzCalB			; Set RSELx = 13 for 8 MHz range
			mov.b	&inf54MHzCalD,R8			; Load low byte of vers5 4MHz calibration
			sub.b	#FREQ4TO8,R8				; Try to estimate the 8MHz low byte
			mov.b	R8,&main8MHzCalD			; Set DCOx and MODx
#endif
			;jmp		donePrep


			
donePrep

#if CALONLYONE
			cmp.b	#CALTHIS,&mainID		; When CALONLYONE is set,
			jne		doneCalibrate			;	mainID is already programmed at this point
#endif

#if CALIBRATE | CALONLYONE
			mov		#CellVChan<<12,R8		; ADC channel for scaled cell voltage input
			call	#measure
#if DEBUG
			mov		R8,&$FFF0				; Copy voltage reading to flash
#endif

; The calibration scale factor will be the expected value divided by the reading.
; The expected value is an unsigned 12 bit integer of millivolts and
; the reading is an unsigned 12.2 bit fixed-point number of millivolts.
; We want the calibration scale factor to be represented as an unsigned 1.15 fixed-point number
; i.e. a number with 1 integer bit and 15 fractional bits.
; So we shift the expected value 17 places left before the division.
CalVoltDividend	SET	CALVOLTS<<17	
			mov		#LWRD CalVoltDividend,R9	; Dividend lo word into R9
			mov		#HWRD CalVoltDividend,R10	; Dividend hi word into R10
			mov		R8,R11						; The divisor is the voltage reading in R8
			rra		R11							; Add half the divisor to the dividend for rounding
			add		R11,R9
			adc		R10
			call	#UMSlashMOD				; Gives quotient in R9, remainder in R10
			
			mov.w	R9,&mainVoltCal			; Flash write calibration value

;
; Temperature offset calibration
; M = 4096/1.5 * (.00355 T + typ0.986)
;	= 9.694*T + typ2692
; M/9.694	= T + typ277.7
; Per the MSP430F2012 datasheet, typ277.7 aims at 273, so the reading is proportional
; to the absolute temperature, with an offset of +- 100 mV.
			; We use offsetByte = (M/9.694 - T) >> 1
; So we use offsetByte = (M/9.694 - T) - 273
; and T = M/9.694 - 273 - offsetByte
;
			mov		#TempChan<<12,R8			; ADC channel for temperature sensor
			call	#measure
			
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor
; in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
			mov.w	&mainVoltCal,R9				; Get voltage calibration word as multiplicand in R9
												; Multiplier is sum-of-samples, already in R8
			call	#UMStar						; Gives unsigned product in R10 (hi word) & R9 (lo word)

; To divide by 9.694, multiply by 65536/9.694 = 6760
			mov		R10,R8
			mov		#6760,R9
			call	#UMStar
			inc		R10							; For correct rounding add one and
			rra		R10							;   shift product hi word right one bit
			sub		#CALTEMP+273,R10			; Temp offset should now fit in a byte
			mov.b	R10,&mainTempCal			; Flash write temperature offset calibration value
			
#endif		/* #if CALIBRATE */


doneCalibrate
			; If the 8MHz cal value is still $FFFF, change it to something else
			; because that's how we tell if we've already done our job
			cmp		#$FFFF,&main8MHzCalD
			_IF		_EQ
				mov		#$AD0B,&main8MHzCalD	; To suggest "Oh bad" when seen in debugger			_ENDIF
			_ENDIF
			
; Erase info flash including segment A.
startErase
			mov		#$1000,R12				; Start of info-flash
eraseInfo	MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase (doesn't seem to "stick")
			rra		@R12					; Dummy write: erase segment
			add		#64,R12					; Next segment
			cmp		#$10C0,R12
			jnz		eraseInfo				; Loop until at start of segment A
			CLRLOCKA						; Clear segment A lock (so we can erase and write it also)
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase
			rra		@R12					; Dummy write: erase segment A

			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave on; only write block that can't)
			clr		R12						; $1000 is start of info flash
			mov		#for1000,R9				; Start of code to write there
pifLoop		mov.w	@R9+,$1000(R12)			; Program word
			incd	R12
			cmp		#256,R12				; Test index
			jnz		pifLoop					; Repeat until done
			

			MOV		#FWKEY,&FCTL1			; Done. Clear WRT
			MOV		#FWKEY+LOCK+LOCKA,&FCTL3 ; Set LOCKs
			SETLOCKA						; Ensure segment A is locked
			;
			; Check that the flash programming worked
			;
			call	#compareImage			; Compare the for1000 image with what's at 1000
			jnz		failCompare
			
			tst		rERR
			jnz		errorFlash
			;
			; Compares successfully. Point the reset vector at the new BSL.
			; NOTE: this will erase all other interrupt vectors, and the last 512 bytes (quarter) of
			; main-flash!
			;
#if PCBVERSION < 57
			bis.b	#LED,&P1OUT				; Turn on LED briefly (BSL will revert) to indicate success
#else
			bic.b	#ACTLED,&P1OUT			; Turn on ActLED briefly to show success (BSL will revert)
#endif
			MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase
			rra.b	&$FFFF					; Dummy write: erase segment
			MOV		#FWKEY+WRT,&FCTL1		; Enable write
			mov		#$1000,&$FFFE			; Re-point reset vector
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming

			bic.b	#WDTIFG,&IFG1			; Clear the watchdog timer interrupt flag
			br		#$1000					; Start the new BSL


failCompare mov		#3,rERR
errorFlash: ; !!! needs cleanup after removing 1 MHz option. -- DCK
; We could end up here after the DCO calibration has been set to $FFFF. so the processor is
;	running very fast
			mov.b	#$8D,&BCSCTL1			; "Average" 8 MHz DCO calibration
			mov.b	#$81,&DCOCTL			;	value so we can read the flashes

			mov		rERR,R11
			add		R11,R11					; Double (two transitions for one "flash")
				rla		R11
				rla		R11						; And quadruple for 4 MHz MCLK

			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (ReadByte may have reset)
			; ??? Should R12 be cleared here? -- DCK
errFlashLp
#if PCBVERSION < 57
			xor.b	#LED,&P1OUT				; The best we can do is freeze and flash LED
#else
			xor.b	#ERRLED,&P2OUT			; The best we can do is freeze and flash ERRLED
#endif
delay		dec		R12
			jnz		delay
count		dec		R11

				bit		#3,R11
				jnz		delay					; Extra delays for 4 MHz
				tst		R11
			jnz		errFlashLp
			;
			; Pause between rErr flashes
pause			mov		#20,R11
pauseL		dec		R12
			jnz		pauseL
			dec		R11
			jnz		pauseL
			jmp		errorFlash


; Some definitions so the common code will work
;#define ID	infoID
;waitTxCmpl	ret						; Empty routine: transmit is always complete
;TX_ByteCk	xor.b	R8,&TXCksum		; Alternative entry which accumulates checksum
;TX_Byte		clr		R11				; Needed for BSL's WriteByte
;			jmp		WriteByte

#define		VoltCal		infoVoltCal		// Needed for measure code
#define		TempCal		infoTempCal
#define		LinkCal		infoLinkCal


#include "../common/measure.s43"			// ADC Measurement
#include "../common/math.s43"				// Multiply and divide
//#include "../common/comMacros.h"			// Macros for obscure instruction sequences

;
; Compare the 256 bytes at for1000 with what's at $1000. Returns with Z set if OK, Z clear if not
compareImage:
			clr		R12
cmpLoop		cmp		$1000(R12),for1000(R12)
			jnz		justRet
			incd	R12
			cmp		#256,R12
			jnz		cmpLoop
justRet		ret


; ----------------------------------------------------------------------------
; The bootstrap loader (BSL)
;
; This will be relocated to info-flash which starts at $1000.
#include "../common/bsl.s43"


freespace		EQU		$FD00-$
#define BCD(x)			( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent	EQU		BCD( (100*freespace)/2048)




;
; Short test program for processor Frequency Derivation. Handy when we lose the frequency calibration
; values.
; Note: Don't put at $FE00 or later; gets erased by the code to rewrite the restart vector
			ORG		$FD00
			mov		#$280,SP
			dint							; Disable interrupts
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop watchdog timer

#if PCBVERSION < 57
			mov.b	#0,&P1OUT				; Set TXD outputs the same, bypass and LED off
			bis.b	#TXDp+TXDm+BYPASS+LED,&P1DIR ; Set TXDs, LED and BYPASS as outputs
#else
			mov.b	#ACTLED,&P1OUT			; Set TXD outputs same, bypass and (inverted) ACTLED off
			bis.b	#TXDp+TXDm+ACTLED,&P1DIR ; Set TXDs and ACTLED as outputs
			; On reset the BYPASS pin is set as a crystal oscillator pin XIN
			; and the ERRLED pin is set as a crystal oscillator pin XOUT.
			; This is safe, as the bypass MOSFET has a pulldown on its gate.
#endif
			mov.b	#DIVM_1,&BCSCTL2		; Set for MCLK = DCOCLK/2
			mov.b	&info8MHzCalB,&BCSCTL1	; Set for 8 MHz DCOCLK
			mov.b	&info8MHzCalD,&DCOCTL

			call	#flash20

;
; Fastest possible toggle: 7 cycles, or 1000/14 = 71.4 kHz @ 1 MHz, or 2000/14 = 142.9 kHz @ 2 MHz
; or 4000/14 = 285.7 kHz @ 4 MHz or 285.3 kHz @ (9600 * 416) Hz
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer
fastFlash
#if PCBVERSION < 57
			xor.b	#LED+TXDp+TXDm,&P1OUT	; Toggle the LED and both transmit outputs at the same time
#else
			xor.b	#ACTLED+TXDp+TXDm,&P1OUT ; Toggle the ACTLED and both transmit outputs at the same time
#endif
											; This won't upset the next BMU, if in-situ, and the
											; frequency can be tested from above the board
;			mov		#30000,R12				; Longer delay (slower flash)
;delay		dec		R12
;			jnz		delay
			jmp		fastFlash

flash20		mov		#20,R11
first		
#if PCBVERSION < 57
			xor.b	#LED,&P1OUT
#else
			xor.b	#ACTLED,&P1OUT
#endif
			mov		#20000,R12				; Longer delay (slow flash)
delay1		mov.w	#WDTPW+WDTCNTCL,&WDTCTL	; Clear and restart Watchdog Timer
			dec		R12						; 7 cycle loop
			jnz		delay1
			dec		R11
			jnz		first
			ret

; The linker puts a checksum of the used code memory in the first available unused space,
; when asked for one.
; To keep our BSL (bootstrap loader) happy we need a simple 1-byte XOR checksum.
; To obtain this we set the IAR Embedded Workbench IDE Project/Options/Linker/Checksum options to:
; Fill unused code memory
; 	Fill pattern: 0xFF
;	Generate checksum
;		Size: 1 byte, Alignment: 1
;		CRC Polynomial: 0x101
; 		Complement: As is
;		Bit order: MSB first, Initial value: 0xE4
; The initial value of 0xE4 is required because the reset vector of $F81C at $FFFE is not transmitted
; and so the BSL does not include it in its checksum, but the linker does.
; If the reset vector changes, this initial value will need to be changed to keep it as
; the XOR of its two bytes.

; And we set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	BSLWriter.bin
;	Output format: raw-binary


			ORG		$FFFE			; The reset vector
;			dw		$1000			; If this BSL-writer is bootstrap-loaded
									; the reset vector will remain pointing to the BSL
									; and it will be called via interpretByte.
			dw		BSLwriter		; If this BSL-writer is JTAGged
									; the reset vector will point to it directly.

			END
