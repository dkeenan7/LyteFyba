; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve the Bootstrap Loader and calibration data.
			LSTOUT-
#include "msp430.h"
#include "ControlFlowMacros.h"
			LSTOUT+
			COL		132
; This is a reverse-polish command interpreter for an MSP430F2012 microcontroller.
;
; It was developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; This interpreter is normally loaded into the 2kB of main-flash on the MSP430F2012.
; using our serial bootstrap-loader (BSL). Its "interpretByte" routine is called from
; the BSL.
;
; See Interpreter.txt for more explanation.

; Conditional assembly flags
#define		TEST		1		; 1 for testing with BMU cell-inputs in parallel
#define		DOINITIALCMD 0		; 1 to execute an initial command on power up
#define		INITIALCMD "9u\\"	; Initial command to execute
#define		CHECKSUM	0		; 1 to require a checksum immediately before end of line/packet
#define		OKPROMPT	0		; 1 to respond ' ok<cr>' after every line/packet is processed

; Addresses manually imported from the BSL-writer. Version 4. Keep up to date!
InitRetAddr	EQU		$1020		; Return address when interpretByte is called for initialisation
ReadByte	EQU		$108A		; Calling-address to receive byte in R8
WriteByte	EQU		$10D2		; Calling-address to transmit byte in R8
ID			EQU		$1003		; Address of this Cell's/BMU's identification byte
VoltCalL	EQU		$1009		; Address of Voltage scale calibration lo byte
VoltCalH	EQU		$100F		; Address of Voltage scale calibration hi byte
TempCal		EQU		$10A1		; Address of Temperature offset calibration byte
LinkCal		EQU		$10BF		; Address of Link Voltage offset calibration byte
; 4MHzCal		EQU		$10D7		; Not used by interpreter, but handy to look up here when doing next data version in BSL-writer

; ADC channel numbers
CellVChan	EQU		$7			; ADC channel number for cell voltage
TempChan	EQU		$A			; ADC channel number for temperature
LinkVChan	EQU		$3			; ADC channel number for link voltage
NumSamples	EQU		16			; Number of ADC over-samples (typ. 4 or 16)
; To get n more bits of resolution, add up 4^n samples and shift the result right by n bits.
; i.e. By adding up 4^n samples you get 2n more bits in the result,
; but half of them are noise and should be thrown away,
; leaving us with n bits of additional information.

; Bits in i/o port 1
LED			EQU		1 << 6		; Bit 6 out is red error LED; 1 = on
BYP			EQU		1 << 5		; Bit 5 out is bypass MOSFET and resistors; 1 = on
RXD			EQU		1 << 2		; Bit 2 in is RXD; 1 = mark
TXDp        EQU     1 << 1      ; Bit 1 out is non-inverted TXD
TXDm        EQU     1 << 0		; Bit 0 out is inverted TXD

;-------------------------------------------------------------------------------
; Flash programming macros

; The LOCKA bit in FCTL3 is a *toggle*, for reasons unknown to me. Use this macro to set; could write a 1 to reset later.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm

;------------------------------------------------------------------------------
; VARIABLEs

        ORG $200    	; Start of RAM
		
VP      DS		2   	; Free Variable space Pointer

CP		DS		2   	; Free Code space Pointer

ToIN	DS		2		; Pointer to current character being stored or parsed in text input buffer
		
CHKSUM  DS		1		; Packet xor checksum

hexFlag	DS		1		; 1 = hex mode (default)

bCheckForBad DS	1		; 1 = check \ command for \B (badness). Only set if aUtonomous command
						; received and we are the last cell

currBadness DS	1		; Current badness (0 = no badness, 7 = highest badness)

		EVEN	$FF		; Make it an even address (0x20A)
bypassVolts	DS	2		; Non-zero = use this value as the bypass voltage

sampleBuf DS	2*NumSamples	; ADC sample buffer; 4 or 16 samples

TIB		EQU     $22C	; Start of Text Input Buffer (Forth terminology), grows up

RSP0	EQU		$260	; Bottom of Interpreter return stack, grows down

DSP0	EQU		$280	; Bottom of combined Interpreter data stack and machine stack, grows down
						; End of RAM

;-------------------------------------------------------------------------------

; Start of code
		ORG     $F800			; Start of main flash
		jmp		interpretByte	; The BootStrap Loader calls here with received bytes

;-------------------------------------------------------------------------------
; Include Forth cross-compilation macros and their runtime-support code,
; the core Forth words for stack manipulation, logic and arithmetic,
; and the bytecode (Forth token) interpreter

#include "ForthXCompileMacros.s43"
#include "ForthCoreWords.s43"
#include "BytecodeInterpreter.s43"

;-------------------------------------------------------------------------------
; The outer (serial packet) interpreter

; Called by the serial-receiver/bootstrap-loader in info-flash.
; Accumulates bytes into an input buffer until
; a carriage return (end of packet) is received, whereupon it checks
; the preceding checksum and, if correct, calls the inner interpreter to interpret the buffer.
; Otherwise it will reset the buffer, ready for the next packet.
				EVEN				; Word-align for following code
				; Encoded badness table. The badness information is transmitted in one byte,
				; with no checksum correction. To counter this, badness is encoded, so that only
				; eight of the 128 possible raw badness codes ($80 - $FF) are valid. Other codes
				; are treated as a corrupted attempt to send badness information; current badness
				; for this BMU is sent instead.
				; The table is indexed by raw badness value (i.e. the least significant 3 bits of
				; the encoded badness byte).
badnessTable	DB		$80			; $80 is least badness
				DB		$91,$A2,$B3,$C4,$D5,$E6
				DB		$F7			; $F7 is the worst badness
main:
interpretByte:
		; We want the long delay on any incoming byte: on an initialising null so all BMUs start slow
		; (and BMU 0 is the first to start master processing); on an ordinary byte so we can type without
		; frequent echo, and on badness, so that an upstream master can take over
		call	#longTimerDelay		; Set long delay
		cmp		#InitRetAddr,0(SP)	; If the call is not merely for initialisation
		_IF		_NE
			tst.b	R8					; Test for badness command ($80-$F7)
			_IF		_L					; If negative (i.e. badness)
				push	R8					; Save incoming badness
				call	#aTick				; Do our own tick processing first (updates our badness)
				pop		R8
				mov.b	R8,R9				; Copy incoming badness
				and		#7,R9				; Consider only raw badness bits
				cmp.b	R8,badnessTable(R9); Is it valid? (Tested after 2 intervening instructions)
				mov.b	&currBadness,R9		; Current badness
				mov.b	badnessTable(R9),R9	; Present encoded badness
				jne		sendMyBadness		; NO! So just send my badness instead
				cmp.b	R8,R9				; Compare incoming badness to ours
				_IF		_C					; If incoming is less bad than us,
sendMyBadness		mov		R9,R8				; then we are worse; send our badness
					; Note that the above does not preserve R8. However, strict preservation
					; is no longer necessary, and since password and non-password bytes can't
					; be interchanged, it is safe
				_ENDIF
			_ENDIF
			call	#doWriteByte		; echo the byte here, as the BSL has not
		_ENDIF						; Endif
		bic.b	#LED,&P1OUT			; We set the LED in WriteByte, and clear it here.
		tst.b	R8					; Is R8
		_IF		_L					;	 a badness?
			tst.b	&bCheckForBad	; Are we checking
			_IF		_NZ				;	for badness (because we're the last BMU)?
				push	Rtos
				mov		R8,Rtos
				sub		#$80,Rtos		; Zero if badness is zero
				call	#m_alarm		; Set or clear the alarm based on Rtos
				pop		Rtos
			_ENDIF
			; Don't continue on and interpret this badness as a literal
			ret						; Just return instead
		_ENDIF

        ; Received byte is passed in R8, which must be preserved
		PUSH R8
        ; Determine if initialisation is required
		; Test below is commented out, as the flags are still set by the test above
;		tst.b	R8				; Use incoming char being null to trigger initialisation
		_IF _Z              	; If null
			MOV		#RSP0,Rrsp  	; Initialise interpreter return stack pointer
			MOV		#CP0,&CP		; Initialise the code pointer
			MOV		#TIB,&ToIN  	; Initialise packet buffer pointer
			clr.b	&CHKSUM     	; Clear the packet checksum
			mov.b	#-1,&hexFlag	; Set the hexadecimal input (verses decimal) flag
			clr.b	&bCheckForBad	; Clear the "checking for badness" flag
			clr.w	&bypassVolts	; Clear the variable bypass voltage value/flag
			clr		&currBadness	; Clear current badness

			; Initialise the timer
			; DIVS_3 = divide MCLK by 8 for SMCK
			mov.b		#DIVS_3, &BCSCTL2
			; TASSEL_2 = SMCK clock source; ID_3 = divide SMCK by 8; MC_1 = up mode
			; TACLR = clear clock count
			; TAIE = Timer A Interrupt Enable, BUT NOTE that this just enables things we don't want, like
			;	the timer overflow interrupt
			mov			#TASSEL_2 + ID_3 + MC_1 + TACLR, &TACTL
			; CCIE = Capture/Compare Interrupt Enable
			mov			#CCIE,&TACCTL0 ; Enable interrupts based on TACCR0
			eint					; Enable interrupts
			; Other initialisation goes here

#if DOINITIALCMD
			mov		#initCmd,Rw
			call	#evaluate
			mov		#1,R8			; Prevent infinite loop; ^A is a fairly safe do-nothing char
#endif
		_ENDIF					; Endif (init required)


#if 1	; Outer interpreter code choice: 0 for bytecode, 1 for machine code.

		MOV &ToIN,R9
		_CASE
		
        _OFb #$0D,R8			; Carriage return = end of packet
#if CHECKSUM
			TST.B &CHKSUM
			_IF _Z				; If good checksum
				DEC R9			;	Prepare to overwrite the checksum with an EXIT bytecode
				CMP #TIB,R9 	;	Handle case of empty packet with no checksum
				_IF _LO
					MOV #TIB,R9
				_ENDIF
#endif
				MOV.B	#EXIT,0(R9) ; Overwrite the checksum or carriage return with an EXIT bytecode
				MOV		#TIB,Rw 	; Interpret the packet as bytecode
				CALL	#evaluate
#if CHECKSUM
			_ENDIF				; Endif (good checksum)
#endif
			MOV #TIB,&ToIN  	; Initialise packet buffer pointer
			CLR.B &CHKSUM     	; Clear the packet checksum
#if OKPROMPT
			mov.b		#' ',R8
			call	#doWriteByte
			mov.b		#'o',R8
			call	#doWriteByte
			mov.b		#'k',R8
			call	#doWriteByte
			mov.b		#$0D,R8
			call	#doWriteByte
#endif
		_ENDOF					; End Of carriage return
		
        _OFb #$08,R8			; Backspace editing
			DEC R9				; Decrement the pointer, but
			CMP #TIB,R9 		; don't go back past start of packet
			_IF _LO
				MOV #TIB,R9
			_ENDIF
			MOV	R9,&ToIN
		_ENDOF					; End Of backspace
		
		; Default case, if not CR or BS
			MOV.B R8,0(R9)		;   Write the byte to the buffer
			INC &ToIN       	; 	Increment the pointer
			; May need to check for buffer overflow one day.
			; It may run into the interpreter return stack.
			; They grow towards each other.
			XOR.B R8,&CHKSUM	;   Accumulate the checksum		

		_ENDCASE					; End Case char

        POP R8
        RET
		
		
#else	; Outer interpreter in bytecode


		push	Rtos
		mov		R8,Rtos			; Push the received character
		mov		#_ACCEPT,Rw		; Call the headerless bytecode for ACCEPT
		call	#evaluate
        POP R8
        RET
		
; ACCEPT	( char -- )	; Accept a character into the line buffer.
; Implements backspace editing and calls the inner interpreter
; to interpret the line when a valid checksum and a carriage return are received.
_ACCEPT
		xLIT2	TIB				; Get the address of the start of the buffer
		DB		Space			; Separate the literals
		xLIT2	ToIN			; Get the address of the buffer pointer
		DB		ROT				; Get the character back on top
		
        xCASE					; Case char ( TIB ToIN char )
		
		xLIT	$0D				; Of carriage return
		xOF
			DB		TwoDUP		; ( TIB ToIN TIB ToIN )
			DB		Fetch		; Get the pointer ( TIB ToIN TIB ToIN@ )
			DB		TwoSWAP		; ( TIB ToIN@ TIB ToIN )
			DB		Store		; Reset the pointer ( TIB ToIN@ )
#if CHECKSUM
			xLIT2	CHKSUM
			DB		CFetch, ZeroEquals
			xIF					; If good checksum
				DB		OneMinus	; ( TIB ToIN@-1 )
				DB		OVER, MAX	; Handle empty packet no checksum( TIB Max(TIB, ToIN@-1) )
#endif
				xLIT2	EXIT		; Overwrite the checksum or carriage return
				DB		SWAP, CStore ;  with an EXIT bytecode ( TIB )
				DB		EVALUATE	; Interpret the input buffer
#if CHECKSUM
			xENDIF				; Endif (good checksum)
#endif
			xLIT	0     		; Clear the packet checksum
			DB		Space
			xLIT2	CHKSUM		; ( 0 CKSUM )
			DB		CStore
#if OKPROMPT
			xDotQuote	' ok\r'
#endif
		xENDOF					; End Of carriage return
		
		xLIT	$08				; Of backspace
		xOF
			DB		TUCK, Fetch, OneMinus ; Decrement buffer pointer ( ToIN TIB ToIN@-1 )
			DB		MAX			; Don't go back past start of TIB ( ToIN Max(ToIN@-1,TIB) )
			DB		SWAP, Store	; Update the pointer
		xENDOF					; End Of backspace
		
		; Default case (if not CR or BS)
			DB		TUCK, OVER, Fetch ; ( TIB char ToIN char ToIN@ )
			DB		CStore 		; Write the byte to the buffer ( TIB char ToIN )
			xLIT	1			; ( TIB char ToIN 1 )
			DB		SWAP, PlusStore ; Increment the pointer ( char )
			; May need to check for buffer overflow one day.
			; It may run into the interpreter return stack.
			; They grow towards each other.
			xLIT2	CHKSUM		; ( TIB char CKSUM )
			DB		TUCK, CFetch ; Get the checksum so far ( char CKSUM char CKSUM@ )
			DB		XORR		; ( TIB CKSUM CKSUM@^char )
			DB		SWAP, CStore ; Update the checksum ( TIB )
		
		xENDCASE				; End Case char (Drops TIB in default case)
		DB		EXIT
		
		
#endif	; Outer interpreter code choice


#if DOINITIALCMD
; The intitial command (bytecode) to execute at power up
initCmd	db		INITIALCMD
#endif

;-------------------------------------------------------------------------------
; BMU-specific bytecode definitions
; e.g. VOLTS TEMP SER-NO BYPASS etc.
;-------------------------------------------------------------------------------


; SetID ( -- ) 	; Set our ID according to where we are in the serial comms chain
;
; We wait up to 1.5 byte times for the start of a byte from our upstream neighbour.
; If no byte is received, we adopt an ID of zero and immediately send it downstream
; so others know not to use it, and we write it to info-flash.
;
; If a byte _is_ received, it is taken to be an ID that is already in use and
; we tentatively set our ID to one more than it.
;
; The structure of the serial code in info-flash is such that any byte read is also
; immediately sent downstream. This ensures that the others downstream keep reading and waiting.
;
; We continue waiting for bytes and echoing them downstream and incrementing our tentative ID
; until no byte is received within 1.5 byte times.
; We then adopt the tentative ID as our own, immediately send it downstream
; so others know not to use it, and we write it to info-flash.
;
; To change existing IDs, you need to bootstrap-load the BSL-writer to erase the IDs,
; then bootstrap-load this interpreter again before issuing this SetID command.
;
; The total time for N cells to set up IDs is about 1.5 * N byte times, or around 350 ms
; for 228 cells at 9600 baud.

		xCODE		'i',SetID,_SetID
		bis.b		#LED,&P1OUT			; Set the error LED
		clr.b		R8					; Tentative ID starts at 0
nextID
		mov			#170,R9				; For 1.5 byte times
		; chkStrt loop is 4+2+1+2 = 9 cycles
chkStrt	bit.b		#RXD,&P1IN			; Check for start bit
		jz			gotStart			; Found start bit
		dec			R9
		jnz			chkStrt
										; Timeout with no received byte
		jmp			timout				; Exit the nextID loop
		
gotStart
		; Because we have already detected the start bit ourselves, the start-bit glitch-check and
		; the sampling of the first data bit, in ReadByte, will be delayed by
		; an extra 16 cycles (15% of a bit time) from the detection of the start bit.
		bis.b		#WDTIFG,&IFG1		; Temporarily set the watchdog flag so
					  					;	ReadByte doesn't recursively call back to interpretByte
		call		#ReadByte			; Read the byte into R8 and echo it, trashes R9 R10 R11 R13
		bic.b		#WDTIFG,&IFG1		; Restore the flag
		inc.b		R8					; Add one to the byte, to obtain a new tentative ID
		jmp			nextID				; Go back and wait again

timout		
		;
		; Timeout with no received byte. ID is now definite. Send it immediately so others dont use it
		;
		call		#doWriteByte		; Call WriteByte in info-flash (via a thunk that clears R11 first)
										; WriteByte sends byte in R8, preserves R8, trashes R9 R10 R11
		;
		; Now flash-program this ID
		mov			#ID,R9
		call		#aFlashCStore
		jmp		doneId					; Finished

doneId	next


;
; cellVolt ( -- )
; Transmit the cell voltage measurement in millivolts (0 to 4095 mV)
;
		xColon		'v',cellVolt,_cellVolt
		xLIT		'V'				; Units are volts
		db			Space
		xLIT		CellVChan<<12	; ADC channel for cell voltage divider
		db			llVolt
		xLIT		4				; Print 4 digits
		db			prettyPrint
		db			EXIT

;
; Cell temperature measurement (cellID --)
; Measurement is in degrees C
;
		xColon		't',cellTemp,_cellTemp
		xLIT		'C'				; Don't use degree symbol (0xF8, Terminal font only); it's treated as a badness
		db			Space
		xLIT		TempChan<<12	; ADC channel for temperature sensor
		db			llVolt

;
; Scale it back to degrees Celsius. Typically, T = (V-Voff)/.00355 where Voff = 0.986
; But the measurement M is 4096* V/1.5 = 2731*V.
; So T = (M/2731 - Koff1)*281.7 = M/9.694 - Koff2
; To divide by 9.694, multiply by 65536/9.694 = 6760, and keep the top half

		xLIT		6760
		db			UMStar
		; Most significant half is on top of stack; nip the lower half off
		db			NIP
		; Temperature offset is now offset by 273
		xLIT		273
		db			Minus
		xLIT		TempCal			; Temp offset calibration
		db			CFetch
;		db			TwoStar			; Double
		db			CToS			; Sign extend
		db			Minus
		xLIT		3				; 3 digits
		db			prettyPrint
		db			EXIT


;
; Link voltage measurement (cellID --)
; Measurement is in mV
; Circuit has 2:1 voltage divider with Vref at the bottom.
; So meaure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
; Reading = 2048 + (Vin/2)(4096/1.5)
; R = 2048 + Vin * 1365.3 (Vin in volts)
; R = 2048 + Vin * 1.3653 (Vin in mV)
; Vin = (R - 2048)/1.3653 mV
; To divide by 1.3653, multiply by 65536/1.3653 = 48001 and keep the top half

		xColon		'n',linkVolt,_linkVolt
		xLIT		'm'				; Units are millivolts
		DB			Space
		xLIT		LinkCal			; Link offset calibration
		db			CFetch
		xLIT		$80				; $80 is a special value representing "calibration failure"
		DB			Equals
		xIF							; If link calibration value is $80
			xLIT		0			; then use value 0
		xELSE
			xLIT		LinkVChan<<12	; Shifted ADC channel for link voltage divider
			db			llVolt
			xLIT		2048
			db			Minus
			xLIT		LinkCal			; Link offset calibration
			db			CFetch
			db			CToS			; Sign extend
			db			Minus
			db			DUP
			db			ZeroLess
			xIF
				db			NEGATE
				xLIT		48001
				db			UMStar
				db			NEGATE
			xELSE
				xLIT		48001
				db			UMStar
			xENDIF
			; Most significant half is on top of stack; nip the lower half off
			db			NIP
		xENDIF
		xLIT		4				; Print 4 digits... would 3 be enough?
		db			prettyPrint
		db			EXIT


;
; Pretty print n as a comment packet with m digits and follow with ch (ch n m--)
;
		xColon	'p',prettyPrint,_prettyPrint
		db			MS1
		xLIT		'\\'
		db			EMIT
		db			MS1				; Delay
		xLIT		ID
		db			CFetch
		xLIT		3				; 3 digits
		db			emitDec			; Emit cell number
		xLIT		':'
		db			EMIT			; Emit ':'
		db			MS1
		db			emitDec			; Emit result
		db			EMIT			; Emit "units" (V or degree symbol, etc)
		db			MS1
		xLIT		$D				; Carriage return
		db			EMIT
		db			EXIT


;
; Low level voltage measurement (channel -- measurement)
; Channel has channel number shifted left 12 bits (e.g. $7000 for cell voltage)
; Channel 7 is currently cell voltage; 10 is temperature sensor
; Measurement is in millivolts (0 to 4095 mV)
;
		xCODE		'o',llVolt,_llVolt
		mov			Rtos,R8
		call		#asm_llvolt				; Measure and use calibration
		mov			R10,Rtos				; Result to TOS
		next

asm_llvolt:									; Assembler (including interrupt) callable: R8 has channel << 12
		call		#measure				; Defined in ../common/measure.s43
;
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
		mov.b		&VoltCalL,R9			; Get voltage calibration lo byte
		mov.b		&VoltCalH,R10			; Get voltage calibration hi byte
		swpb		R10						; Assemble the two bytes into a word
		bis			R10,R9					; as multiplicand in R9
											; Multiplier is sum-of-samples, already in R8
		call		#aUMStar				; Gives unsigned product in R10 (hi word) and R9 (lo word)
											; Note: calls assembler code that ends in ret
		inc			R10						; For correct rounding
		rra			R10						; Shift product hi word right one bit

		ret					; Finished

#include "../common/measure.s43"			; Declare the measure routine

;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		; This is actually longer in bytecode
		xCODE		's',Select,_Select
		cmp.b		&ID,Rtos			; Correct ID?
		pop			Rtos				; Pop the argument
		jz			_NEXT				; If so, just continue interpreting rest of packet
		RPOP		Rip					; Pop to the bytecode that called this
		RET								; Return to the outer interpreter (i.e. ignore rest of packet)

#if 0
;
; For debugging only: output R12 in hex
; NOT USED AT PRESENT
hxOut	mov			R12,R8
		rrc			R8
		rrc			R8
		rrc			R8
		rrc			R8
		call		#nibOut
		mov			R12,R8
nibOut	and			#$F,R8
		; Tricky 5 word replacement for the 7 words of instructions commented-out below
		clrc				; Because dadd is always done with carry on MSP430
		dadd.b #$90,R8		; Causes no carry for 0-9, carry for A to F
		dadd.b #$40,R8		; Now any carry gets added, giving $30-$39, $41-$46 (i.e. '0'-'9','A'-'F')
;		add			#'0',R8
;		cmp			#'9'+1,R8
;		jl			noAdd
;		add			#'A'-'9'-1,R8
;noAdd:
		; Fall through to doWriteByte and return
#endif

; doWriteByte ( regs: R8 -- R9 R10 R11 ) ; Transmits byte in R8, preserves R8, trashes R9 R10 R11
; Call this instead of calling WriteByte directly
doWriteByte:
		clr			R11					; R11 is required to be cleared for the ...
		br			#WriteByte			; ... WriteByte function in the bootstrap loader (BSL)


; UM* ( u1 u2 -- ud )
; Multiply u1 by u2, giving the unsigned double product ud.
; All values and arithmetic are unsigned.
		xCODE		'X'-64,UMStar,_UMStar	; Ctrl-X
		mov		Rtos,R8
		Pop		R9
		call	#aUMStar		; Do the work in assembler-callable assembler
		push	R9
		mov		R10,Rtos
		next

; Algorithm described in http://cs.hiram.edu/~walkerel/cs252/multiply.ppt

;_UMStar						; Assembler-callable assembler
		; Starts with 16 bit multiplicand in R8, multiplier in R9 and
		; ends with 32 bit product in R10 (hi) and R9 (lo).
aUMStar:
		clr		R10			; Clear hi word of product so far
		mov		#16,R11		; Do 16 times

mullp	bit		#1,R9		; Test low bit of multiplier
		jz		mulz		; If it's a 1
		add		R8, R10		;   add multiplicand to product hi word; Endif
mulz	rrc		R10			; Shift product hi word (incl. carry) right
		rrc		R9			; into product lo and simul. shift multiplier right
		dec		R11			; Decrement loop counter
		jnz		mullp		; Loop until zero
		ret

; UM/MOD ( ud u1 -- u2 u3 )
; Divide ud by u1, giving the remainder u2 and the quotient u3.
; All values and arithmetic are unsigned. An ambiguous condition exists
; if u1 is zero or if the quotient lies outside the range of a single
; unsigned integer.
; In this case we return $FFFF for both quotient and remainder.
; Algorithm is from eForth by Bill Muench.
; It is essentially the reverse of the multiplication algorithm above.

;_UMSlashMOD             ; (was) Headerless code (no bytecode assigned)
		xCODE	'_'-64,UMSlashMOD,_UMSlashMOD	; Ctrl-_ (downward pointing triangle)
		mov     Rtos,R8  ; u1     unsigned divisor
		pop     R10      ; ud hi  unsigned dividend hi word
		pop     R9       ; ud lo  unsigned dividend lo word
		cmp     R8,R10   ; Overflow?
		jc      oflo     ; Jump to error exit if divide by zero or overflow.
		mov     #16,R11  ; Do 16 times

ummlp	rla     R9       ; Shift quotient left and simul. shift dividend lo
		rlc     R10      ;   into dividend hi
		jc      umm2     ; If carry OR
		cmp     R8,R10
		jlo     umm1     ;   no carry AND remainder-so-far >= divisor
umm2	sub     R8,R10   ;     Subtract divisor from remainder-so-far
		bis     #1,R9    ;     Set low bit of quotient-so-far
                         ; Endif
umm1	dec     R11      ; Decrement loop counter
		jnz     ummlp    ; Loop until zero

		push    R10      ; u2  unsigned remainder
		mov     R9,Rtos  ; u3  unsigned quotient
		next

oflo	PUSH    #-1
		PUSH    #-1
		next


; * ( n1|u1 n2|u2 -- n3|u3 )
; Multiply n1|u1 by n2|u2 giving the single product n3|u3.
; i.e. same routine works for signed or unsigned.

		xColon '*',Star,_Star
;		xLIT2 	_UMStar			; Do the multiplication
;		DB   	EXECUTECODE
		db	 	UMStar
		DB   	DROP			; Throw away the high word of the result
		DB   	EXIT

; U/ ( u1 u2 -- u3 )
; Divide u1 by u2, giving the single unsigned quotient u3.
; Returns $FFFF if u2 is zero.

		xColon  '/',Slash,_Slash
		xLIT 	0				; Pad the dividend to a double word
		DB   	SWAP
;		xLIT2 	_UMSlashMOD		; Do the division
;		DB   	EXECUTECODE
		db		UMSlashMOD
		DB		NIP				; Throw away the remainder
		DB		EXIT

;
; emitDec  ( n count -- ) ; Emit an integer n as count decimal digits

		xColon	'm',emitDec,_emitDec
		db		ToR					; n on data stack, count on return stack
		db		DUP
		db		ZeroLess
		xIF								; If n is negative
			xLIT	'-'
			db		EMIT					; Emit leading minus sign
			db		MS1
			db		NEGATE
		xENDIF
		
		db		RFetch					; Copy count from return stack
		db		OneMinus				; count-1
		xLIT	0
		xQDO
			xLIT	0
			db		Space
			xLIT	10
			db		UMSlashMOD
			; Now we have rem1 ... remn-1 quotient=current-number
		xLOOP
		; Now we have the quotient on TOS and remainder under; no need for another divide by 10
		db		RFrom		; Get count from return stack
		xLIT	0
		xQDO
			xLIT	'0'
			db		Plus
			db		EMIT		
			db		MS1			; Delay 1 transmit byte time
		xLOOP
		db		EXIT
		
		
; . ( n -- ) ; Print the signed number on top of stack (currently only in decimal)
		xColon		'.',Dot,_Dot
		xLIT		5			; Always show 5 digits, for now
		DB			emitDec
		DB			EXIT
		


;
; Delay for n milliseconds (n --)
;
		xCODE	'z',MS,_MS
MSloop1	mov		#331,R8		; 1 ms delay, less a few overheads
MSloop2	dec		R8
		jnz		MSloop2
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL		; Clear and restart Watchdog Timer
		dec		Rtos
		jnz		MSloop1
		pop		Rtos
		next
		
		xCODE	'H'-64,MS1,_MS1		; 1.04 ms delay; commonly needed (--) Not from keyboard
		mov		#345,R8
MS1loop2 dec	R8
		jnz		MS1loop2
		next

#if 0
;
; Clear watchdog timer. DO WE NEED THIS?
; We do if we remove the watchdog clear on every bytecode
; that's slowing down the inner interpreter
;
		xCODE	'w',clearWatchDog,_clearWatchDog
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL		; Clear and restart Watchdog Timer
		next
#endif

;
; aUtonomous operation; cell 0 (or any after a comms break) send tick commands to others;
; last cell operates warning LED/buzzer
; For 'u' command, top of stack has number of cells (num_cells --)
; 'd' (Discharge) command is the same, but sets bypass voltage to a value from the second operand
; (num_cells thresh --) thresh is in millivolts
; 'd' can be used for top, mid, or bottom balancing at various voltages
; Since 'd' relies on a value in RAM, most charging should use 'u' instead
;
		xColon	'u',auton,_auton
		xLIT	0
		db		Space
		; Fall through to 'd' command; 'u' is like "num_cells 0 d"

		xColon	'd',Discharge,_Discharge
		xLIT2	bypassVolts
		db		Store			; Set or clear bypassVolts based on u or d commmand

		db		DUP				; Num_cells parameter (or 0 to turn off badness sending)
		xIF
			xLIT	CCIE			; Non zero parameter: set the interrupt enable bit
		xELSE
			xLIT	0				; Zero parameter (0u); reset the interrupt enable bit
		xENDIF
		db		Space
		xLIT	TACCTL0			; TACCR0 control port
		db		Store			; Store CCIE or zero to the control port

		db		OneMinus		; Parameter (number of cells) -1
		xLIT	ID
		db		CFetch
		db		Equals
		; If last cell, need alarm processing
		xLIT2	bCheckForBad
		db		CStore
		db		resetTimer		; Start the timer with the long, ID dependent time
		db		EXIT			; Then do nothing (apart from waiting for more commands)

#if 0
;
; Quiet - is the RS232 input quiet?  ( -- flag )
; Returns -1 for quiet, 0 for byte being sent
;
			xCODE	'q',quiet,_quiet
			push	Rtos
			mov.b	&P1IN,Rtos
			and.b	#RXD,Rtos		; Clears carry if was zero
			subc	Rtos,Rtos		; -1 if was 0, 0 otherwise
			inv		Rtos			; -1 if was 1 (= quiet)
			next
#endif

;
; FlashC! ( char c-addr -- ) ; DANGER: flash byte-write command
;
			EVEN
			xCODE	'M'-64,FlashCStore,_FlashCStore
			mov		Rtos,R9
			pop		R8
			call	#aFlashCStore
			pop		Rtos
			next

;
; Set or reset alarm ( flag -- )
;
			xCODE	'g',alarm,_alarm
			call	#m_alarm			; Machine code does the work
			pop		Rtos				; Remove argument
aNext		next

;
; Reset badness timer ( -- )
;
			xCODE	'r',resetTimer,_resetTimer
			call	#longTimerDelay
			next

; Regular tick.
; Turn on the bypass resistors if the cell is over 3.55 V
; Set badness if over or under volts
#if 0				; This needs to be called from an interrupt routine, so best to have it in assembler
		xColon		'k',Tick,_Tick
		xLIT		CellVChan<<12	; ADC channel for cell voltage divider
		db			llVolt
		db			DUP
		xLIT2		bypassVolts
		db			Fetch
		db			DUP
		db			ZeroEquals
		xIF							; If bypassVoltage is zero
			db			DROP			; then drop the duplicated zero
			xLIT		3600			; Put fixed bypass voltage to TOS
		xENDIF
		db			UGreater		; 1 if greater, 0 otherwise
		db			bypass			; Bypass if cell voltage > 3.65 V (or > bypassVoltage if 'd' command is active)
		db			DUP
		; Overvoltage badness: for every 50 mV over 3.60 V, we add one level of badness, to a maximum of 7 for > 3.95 V
		xLIT		3650-49
		db			Minus			; Measurement - 3.65 V + 0.49 V
		xLIT		0
		db			MAX				; Minimum of 0
		xLIT		50
		db			Slash			; Divide by 50 mV
		; Undervoltage badness: for every 100 mv below 2.5 V, we add one level of badness, to a maximum of 7 for < 1.9 V
		db			SWAP			; Original measurement on top
		xLIT		2500+99
		db			SWAP
		db			Minus			; 2.5 V - measurement + 0.99 V
		xLIT		0
		db			MAX				; Minimum of 0
		xLIT		100
		db			Slash			; Difference / 100
		db			MAX				; Get the max of overvolts and undervolts
		xLIT		7
		db			MIN				; Maximum of 7 for either
		db			DUP				; For error LED below
		xLIT2		currBadness		; Address of current badness
		db			CStore			; Store it
		db			errorLed		; Turn on error LED if any badness
		
		db			EXIT
#else
		; Assembler version of the above
		xCODE		'k',Tick,_Tick
		call		#aTick			; Call the pure assembler Tick code
		next

aTick:	mov			#CellVChan<<12,R8
		call		#asm_llvolt		; Cell voltage measurement to R10 (in millivolts)
		mov			R10,R8
		mov			&bypassVolts,R9	; Do we have a special bypass limit?
		tst			R9
		_IF			_Z				; If not,
			mov			#3600,R9		; then use 3.600 V
		_ENDIF
		cmp			R8,R9
		subc		R10,R10			; Set R10 to -1 if carry was 0, i.e. cell voltage not less than threshold
		xor.b		&P1OUT,R10		; R10 has all the bits that are different
		and.b		#BYP,R10		; Leave only BYP bit standing
		xor.b		R10,&P1OUT		; Toggle if necessary
		
		inv			R9				; 2's complement and subtract one
		; The "and subtract one" above means badness actually starts at 3651 mV (3651 - 3601 = 50 -> bad)
		add			R8,R9			; R9 has cell voltage - bypass threshold
		_IF			_NC				; If this generated a carry (result negative)
			clr			R9				; then use 0
		_ENDIF
		mov			#1312,R10		; 65536/50 = 1312
		call		#mulR10R9		; Mult by 1312 = divide by 50, result in R10
		mov			R10,R11			; Save the overvolts badness
		mov			#2500+99,R9
		sub			R8,R9			; R9 = 2500 - cell voltage + 99
		_IF			_NC				; If result was negative (borrow = no carry)
			clr			R9				; then use 0
		_ENDIF
		mov			#655,R10		; 65536/100 = 655
		call		#mulR10R9		; Multiply by 655 = divide by 100
		; R10 has undervolts badness
		cmp			R10,R11
		_IF			_NC				; If R10 >= R11
			mov			R10,R11			; then copy worst (R10) to R11
		_ENDIF
		cmp			#7+1,R11		; Want maximum badness of 7
		_IF			_C				; If R11 >= 7
			mov			#7,R11			; record maximum badness of 7
		_ENDIF
		mov.b		R11,&currBadness ; Store current badness

		; Set error LED if >= 2 badness
		cmp			#2,R11			; Clears carry if badness was < 2
		subc		R10,R10			; Set R10 to -1 if carry was 0, badness was < 2
		inv			R10				; Set to -1 if badness was >= 2
		xor.b		&P1OUT,R10		; R10 has all the bits that are different
		and.b		#LED,R10		; Leave only BYP bit standing
		xor.b		R10,&P1OUT		; Toggle if necessary

		ret




mulR10R9:		; Short assembler routine to multiply R10 by R9, result to R10:R9,
					; preserving other registers
		push		R8
		push		R11
		mov			R10,R8
		call		#aUMStar			; Call aUMStar and return
		pop			R11
		pop			R8
		ret

#endif

;
; Turn on or off the error LED (bool -- )
;
#if	1
		xColon	'l',errorLed,_errorLed
		xLIT	LED
		DB		Space
		xLIT	P1OUT
		DB		CBITStore
		DB		EXIT
		
#else
		xCODE	'l',errorLed,_errorLed
		and		Rtos,Rtos		; Clears carry if was zero
		subc	Rtos,Rtos		; -1 if was 0, 0 otherwise
		inv		Rtos			; 0 if was 0, -1 otherwise
		xor.b	&P1OUT,Rtos		; Rtos has all the bits that are different
		and.b	#LED,Rtos		; Leave only LED bit standing
		xor.b	Rtos,&P1OUT		; Toggle if necessary
		pop		Rtos			; Remove operand
		next
#endif

;
; Turn on or off bypass resistors (bool -- )
;
#if 1
		xColon	'y',bypass,_bypass
		xLIT	BYP
		DB		Space
		xLIT	P1OUT
		DB		CBITStore
		DB		EXIT
		
#else
		xCODE	'y',bypass,_bypass
		and		Rtos,Rtos		; Clears carry if was 0
		subc	Rtos,Rtos		; -1 if was 0, 0 otherwise
		inv		Rtos			; 0 if was 0, -1 otherwise
		xor.b	&P1OUT,Rtos		; Rtos has all the bits that are different
		and.b	#BYP,Rtos		; Leave only BYP bit standing
		xor.b	Rtos,&P1OUT		; Toggle if necessary
		pop		Rtos			; Remove operand
		next
#endif

;
; Emit the calibration value: TEMPORARY
;
#if 0
		xColon	'c',calval,_calval
		xLIT	'C'
		db		Space
		xLIT	VoltCal
		db		CFetch
		xLIT	3
		db		prettyPrint
		db		EXIT
#endif


		EVEN
; NOTE: pure machine code (ends in RET instruction)
; Do the work of setting or clearing the alarm (based on Rtos)
m_alarm:		
		tst.b	Rtos
		jnz		setAlarm
		bis.b	#TXDp,&P1OUT		; Unset alarm
		bic.b	#TXDm,&P1OUT
		ret
setAlarm bis.b	#TXDm,&P1OUT		; Set alarm!
		bic.b	#TXDp,&P1OUT
		ret


;
; Link voltage offset caliBration (--)
; Assumes zero link voltage due to zero link current
;
		xColon	'b',calLink,_calLink
		xLIT2	LinkVChan<<12
		DB		llVolt
		xLIT	2048				; Zero volts for link voltage is a 2048 reading
		DB		Minus				; So subtract from result
		DB		DUP
		xLIT	$80
		xLIT	$FF81				; -$7F
		DB		WITHIN
		xIF							; If result (under TOS) is < -$7F or >= $80
			DB		DROP				; then discard the result
			xLIT	$80					; and replace with $80
			DB		Space				; Next bytecode is an xLIT
		xENDIF
		xLIT2	LinkCal
		DB		FlashCStore			; Write the calibration value
		DB		EXIT


			
aFlashCStore:
			; Assembly language flash writer
			; Byte  in R8, address in R9. Trashes R10
			;
			; Check if it is possible to flash-program this ID
			;
			mov.b		R8,R10				; Need to check for 1 bits in new ID
			bic.b		@R9,R10			    ;	that are already 0s in the existing byte
			tst.b		R10					; Set Z flag if result is 0; bic doesn't
			jnz			cantFlsh			; Impossible flash-write; can't do it
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3
			MOV 	#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV 	#FWKEY,&FCTL3       	; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write block that can't be)
			CLRLOCKA
			mov.b	R8,0(R9)				; Flash-write it
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming
			SETLOCKA
			MOV		#FWKEY,&FCTL1			; Disable flash write
			bic.b	#LED,&P1OUT				; Clear the error LED: done!
			ret
cantFlsh	bis.b	#LED,&P1OUT				; Set the error LED to indicate failure
			ret
			

; Test of string-output-compiling macro xDotQuote (Forth ." )
			xColon	'a',helloWorld,_helloWorld
			xDotQuote	'Hi\r'
			DB 		EXIT

			EVEN
int_ccr0	; Interrupt service routine for TACCR0
			; Its jobs are to set the time for the next interrupt, do tick processing, and transmit the current badness.
			push	R8						; We trash R8
			push	R9						; WriteByte trashes R9-R11
			push	R10
			push	R11

			mov		#1000000>>6,&TACCR0		; Set period to 1 second

			; Call tick processing
			call	#aTick					; Call the pure assembler version

			mov.b	&currBadness,R8			; The current badness
			mov.b	badnessTable(R8),R8		; Encode it
			call	#doWriteByte			; Clear R11 and call WriteByte
			bic.b	#LED,&P1OUT				; We set the LED in WriteByte, and clear it here.

			pop		R11
			pop		R10
			pop		R9
			pop		R8
areti		reti

; Set the TACCR0 timer period to 3 seconds plus an extra ~ 4ms per ID, or ID << 6
; NOTE: this variation seems to be insufficient to prevent multiple masters initially
; Trashes R9
; Probably doesn't need to be a subroutine any more
longTimerDelay:
;			clr		&TAR				; Clear the counter: THIS DOESN'T SEEM TO WORK!
			bis		#TACLR,&TACTL		; Clear the counter
			mov.b	&ID,R9
			swpb	R9					; Effectively shift left 8 bits
			rra		R9
			rra		R9					; then 2 right
			add		#3000000>>6,R9		; Add 3 seconds
			mov		R9,&TACCR0			; Interrupt again with that period
			ret
			
CP0			; Used to set the initial value of CP (Code Pointer).
SPACE		EQU		_OPCODETBL-$	; This is the space left in mainflash

			ORG		_OPCODETBL
			; The following makes sure we detect when we've overflowed the main flash
			dw		$FFFF			; Table entry for bytecode 0: unused

			ORG		0xFFF0			; Timer A interrupt vectors
			DW		areti			; All other timer A interrupts
			DW		int_ccr0		; TACCR0 interrupt vector (the one we use)
	
			ORG		0xFFFE			; Reset power-on vector
			DW		0x1000			; Start of BSL
	
			END
