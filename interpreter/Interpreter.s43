			LSTOUT-
#include "msp430.h"
#include "ControlFlowMacros.h"
			LSTOUT+
			COL		132
; This is a reverse-polish command interpreter for an MSP430F2012 microcontroller.
;
; It was developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; This interpreter is normally loaded into the 2kB of main-flash on the MSP430F2012.
; using our serial bootstrap-loader (BSL). Its "interpretByte" routine is called from
; the BSL.
;
; See Interpreter.txt for more explanation.

; Conditional assembly flags
#define		TEST		1		; 1 for testing with BMU cell-inputs in parallel
#define		SLOWSAMP	1		; 1 for slower samples (29 uS vs 15.4 uS), with the
								; longer sample time (16 uS vs 13 uS) for more stability
#define		DOINITIALCMD 0		; 1 to execute an initial command on power up
#define		INITIALCMD "9u\\"	; Initial command to execute
#define		CHECKSUM	0		; 1 to require a checksum immediately before end of line/packet
#define		OKPROMPT	0		; 1 to respond ' ok<cr>' after every line/packet is processed

; Addresses manually imported from the BSL-writer. Version 4. Keep up to date!
InitRetAddr	EQU		$1020		; Return address when interpretByte is called for initialisation
ReadByte	EQU		$108A		; Calling-address to receive byte in R8
WriteByte	EQU		$10D2		; Calling-address to transmit byte in R8
ID			EQU		$1003		; Address of this Cell's/BMU's identification byte
VoltCalL	EQU		$1009		; Address of Voltage scale calibration lo byte
VoltCalH	EQU		$100F		; Address of Voltage scale calibration hi byte
TempCal		EQU		$10A1		; Address of Temperature offset calibration byte
LinkCal		EQU		$10BF		; Address of Link Voltage offset calibration byte
; 4MHzCal		EQU		$10D7		; Not used by interpreter, but handy to look up here when doing next data version in BSL-writer

; ADC channel numbers
CellVChan	EQU		$7			; ADC channel number for cell voltage
TempChan	EQU		$A			; ADC channel number for temperature
LinkVChan	EQU		$3			; ADC channel number for link voltage
NumSamples	EQU		16			; Number of ADC over-samples (typ. 4 or 16)
; To get n more bits of resolution, add up 4^n samples and shift the result right by n bits.
; i.e. By adding up 4^n samples you get 2n more bits in the result,
; but half of them are noise and should be thrown away,
; leaving us with n bits of additional information.

; Bits in i/o port 1
LED			EQU		1 << 6		; Bit 6 out is red error LED; 1 = on
BYP			EQU		1 << 5		; Bit 5 out is bypass MOSFET and resistors; 1 = on
RXD			EQU		1 << 2		; Bit 2 in is RXD; 1 = mark
TXDp        EQU     1 << 1      ; Bit 1 out is non-inverted TXD
TXDm        EQU     1 << 0		; Bit 0 out is inverted TXD

;-------------------------------------------------------------------------------
; Flash programming macros

; The LOCKA bit in FCTL3 is a *toggle*, for reasons unknown to me. Use this macro to set; could write a 1 to reset later.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm

;------------------------------------------------------------------------------
; VARIABLEs

        ORG $200    	; Start of RAM
		
VP      DS		2   	; Free Variable space Pointer

CP		DS		2   	; Free Code space Pointer

ToIN	DS		2		; Pointer to current character being stored or parsed in text input buffer
		
CHKSUM  DS		1		; Packet xor checksum

hexFlag	DS		1		; 1 = hex mode (default)

bCheckForBad DS	1		; 1 = check \ command for \B (badness). Only set if aUtonomous command
						; received and we are the last cell

currBadness DS	1		; Current badness (0 = no badness, 7 = highest badness)

		EVEN	$FF		; Make it an even address (0x20A)
bypassVolts	DS	2		; Non-zero = use this value as the bypass voltage

sampleBuf DS	2*NumSamples	; ADC sample buffer; 4 or 16 samples

TIB		EQU     $22C	; Start of Text Input Buffer (Forth terminology), grows up

RSP0	EQU		$260	; Bottom of Interpreter return stack, grows down

DSP0	EQU		$280	; Bottom of combined Interpreter data stack and machine stack, grows down
						; End of RAM

;-------------------------------------------------------------------------------

; Start of code
		ORG     $F800			; Start of main flash
		jmp		interpretByte	; The BootStrap Loader calls here with received bytes

;-------------------------------------------------------------------------------
; Include Forth cross-compilation macros and their runtime-support code,
; the core Forth words for stack manipulation, logic and arithmetic,
; and the bytecode (Forth token) interpreter

#include "ForthXCompileMacros.s43"
#include "ForthCoreWords.s43"
#include "BytecodeInterpreter.s43"

;-------------------------------------------------------------------------------
; The outer (serial packet) interpreter

; Called by the serial-receiver/bootstrap-loader in info-flash.
; Accumulates bytes into an input buffer until
; a carriage return (end of packet) is received, whereupon it checks
; the preceding checksum and, if correct, calls the inner interpreter to interpret the buffer.
; Otherwise it will reset the buffer, ready for the next packet.
				EVEN				; Word-align for following code
				; Encoded badness table. The badness information is transmitted in one byte,
				; with no checksum correction. To counter this, badness is encoded, so that only
				; eight of the 128 possible raw badness codes ($80 - $FF) are valid. Other codes
				; are treated as a corrupted attempt to send badness information; current badness
				; for this BMU is sent instead.
				; The table is indexed by raw badness value (i.e. the least significant 3 bits of
				; the encoded badness byte).
badnessTable	DB		$80			; $80 is least badness
				DB		$91,$A2,$B3,$C4,$D5,$E6
				DB		$F7			; $F7 is the worst badness
main:
interpretByte:
		cmp		#InitRetAddr,0(SP)	; If the call is not merely for initialisation
		_IF		_NE
			tst.b	R8					; Test for badness command ($80-$F7)
			_IF		_L					; If negative
				mov.b	R8,R9				; Copy
				and		#7,R9				; Consider only raw badness bits
				cmp.b	R8,badnessTable(R9); Is it valid? (Tested after 2 intervening instructions)
				mov.b	&currBadness,R9		; Current badness
				mov.b	badnessTable(R9),R9	; Present encoded badness
				jne		sendMyBadness		; NO! So just send my badness instead
				cmp.b	R8,R9				; Compare incoming badness to ours
				_IF		_C					; If incoming is less bad than us,
sendMyBadness		mov		R9,R8				; then we are worse; send our badness
					; Note that the above does not preserve R8. However, strict preservation
					; is no longer necessary, and since password and non-password bytes can't
					; be interchanged, it is safe
				_ENDIF
			_ENDIF
			call	#doWriteByte		; echo the byte here, as the BSL has not
		_ENDIF						; Endif
		bic.b	#LED,&P1OUT			; FOR NOW, we set the LED in WriteByte, and clear it here.
		tst.b	R8					; Is R8
		_IF		_L					;	 a badness?
			tst.b	&bCheckForBad	; Are we checking
			_IF		_NZ				;	for badness (because we're the last BMU)?
				push	Rtos
				mov		R8,Rtos
				sub		#$80,Rtos		; Zero if badness is zero
				call	#m_alarm		; Set or clear the alarm based on Rtos
			_ENDIF
			ret							; Yes, don't interpret as a literal
		_ENDIF

        ; Received byte is passed in R8, which must be preserved
		PUSH R8
        ; Determine if initialisation is required
		; Test below is commented out, as the flags are still set by the test above
;		tst.b	R8				; Use incoming char being null to trigger initialisation
		_IF _Z              	; If null
			MOV		#RSP0,Rrsp  	; Initialise interpreter return stack pointer
			MOV		#CP0,&CP		; Initialise the code pointer
			MOV		#TIB,&ToIN  	; Initialise packet buffer pointer
			CLR		&CHKSUM     	; Clear the packet checksum
			mov.b	#-1,&hexFlag	; Set the hexadecimal input (verses decimal) flag
			clr.b	&bCheckForBad	; Clear the "checking for badness" flag
			clr.w	&bypassVolts	; Clear the variable bypass voltage value/flag
			clr		&currBadness	; Clear current badness
									; Other initialisation goes here
;			BIS		#1<<14,SR   	; Set "initialised" flag (bit 14 of status reg)
#if DOINITIALCMD
			mov		#initCmd,Rw
			call	#evaluate
			mov		#1,R8			; Prevent infinite loop; ^A is a fairly safe do-nothing char
#endif
		_ENDIF					; Endif (init required)
		
		
		MOV &ToIN,R9
        CMP #$0D,R8
;		_IF _HS						; Ignore if less
			_IF _NE					; If not carriage return
				MOV.B R8,0(R9)		;   Write the byte to the buffer
				INC &ToIN       	; 	Increment the pointer
				; May need to check for buffer overflow one day.
				; It may run into the interpreter return stack.
				; They grow towards each other.
				XOR.B R8,&CHKSUM	;   Accumulate the checksum		
			_ELSE					; Else (carriage return)
#if CHECKSUM
		    	TST.B &CHKSUM
				_IF _Z				;   If good checksum
			    	DEC R9			;     Overwrite the checksum with a RETT bytecode
					CMP #TIB,R9 	;     Handle case of empty packet with no checksum
					_IF _LO
						MOV #TIB,R9
					_ENDIF
#endif
					MOV.B	#EXIT,0(R9) ; Overwrite the checksum or carriage return with an EXIT bytecode
					MOV		#TIB,Rw 	; Interpret the packet as bytecode
					CALL	#evaluate
#if OKPROMPT
					mov.b		#' ',R8
					call	#doWriteByte
					mov.b		#'o',R8
					call	#doWriteByte
					mov.b		#'k',R8
					call	#doWriteByte
					mov.b		#$0D,R8
					call	#doWriteByte
#endif
#if CHECKSUM
				_ENDIF				;   Endif (good checksum)
#endif
				MOV #TIB,&ToIN  	;   Initialise packet buffer pointer
				CLR &CHKSUM     	;   Clear the packet checksum
			_ENDIF					; Endif (equals carriage return )
;		_ENDIF						; Endif (higher or same as carriage return)

        POP R8
        RET
		
#if DOINITIALCMD
; The intitial command (bytecode) to execute at power up
initCmd	db		INITIALCMD
#endif

;-------------------------------------------------------------------------------
; BMU-specific bytecode definitions
; e.g. VOLTS TEMP SER-NO BYPASS etc.
;-------------------------------------------------------------------------------


; SetID ( -- ) 	; Set our ID according to where we are in the serial comms chain
;
; We wait up to 1.5 byte times for the start of a byte from our upstream neighbour.
; If no byte is received, we adopt an ID of zero and immediately send it downstream
; so others know not to use it, and we write it to info-flash.
;
; If a byte _is_ received, it is taken to be an ID that is already in use and
; we tentatively set our ID to one more than it.
;
; The structure of the serial code in info-flash is such that any byte read is also
; immediately sent downstream. This ensures that the others downstream keep reading and waiting.
;
; We continue waiting for bytes and echoing them downstream and incrementing our tentative ID
; until no byte is received within 1.5 byte times.
; We then adopt the tentative ID as our own, immediately send it downstream
; so others know not to use it, and we write it to info-flash.
;
; To change existing IDs, you need to bootstrap-load the BSL-writer to erase the IDs,
; then bootstrap-load this interpreter again before issuing this SetID command.
;
; The total time for N cells to set up IDs is about 1.5 * N byte times, or around 350 ms
; for 228 cells at 9600 baud.

		xCODE		'i',SetID,_SetID
		bis.b		#LED,&P1OUT			; Set the error LED
		clr.b		R8					; Tentative ID starts at 0
nextID
		mov			#170,R9				; For 1.5 byte times
		; chkStrt loop is 4+2+1+2 = 9 cycles
chkStrt	bit.b		#RXD,&P1IN			; Check for start bit
		jz			gotStart			; Found start bit
		dec			R9
		jnz			chkStrt
										; Timeout with no received byte
		jmp			timout				; Exit the nextID loop
		
gotStart
		; Because we have already detected the start bit ourselves, the start-bit glitch-check and
		; the sampling of the first data bit, in ReadByte, will be delayed by
		; an extra 16 cycles (15% of a bit time) from the detection of the start bit.
		bis.b		#WDTIFG,&IFG1		; Temporarily set the watchdog flag so
					  					;	ReadByte doesn't recursively call back to interpretByte
		call		#ReadByte			; Read the byte into R8 and echo it, trashes R9 R10 R11 R13
		bic.b		#WDTIFG,&IFG1		; Restore the flag
		inc.b		R8					; Add one to the byte, to obtain a new tentative ID
		jmp			nextID				; Go back and wait again

timout		
		;
		; Timeout with no received byte. ID is now definite. Send it immediately so others dont use it
		;
		call		#doWriteByte		; Call WriteByte in info-flash (via a thunk that clears R11 first)
										; WriteByte sends byte in R8, preserves R8, trashes R9 R10 R11
		;
		; Now flash-program this ID
		mov			#ID,R9
		call		#aFlashCStore
		jmp		doneId					; Finished

doneId	next


;
; cellVolt ( -- )
; Transmit the cell voltage measurement in millivolts (0 to 4095 mV)
;
		xColon		'v',cellVolt,_cellVolt
		xLIT		'V'				; Units are volts
		db			Space
		xLIT		CellVChan<<12	; ADC channel for cell voltage divider
		db			llVolt
		xLIT		4				; Print 4 digits
		db			prettyPrint
		db			EXIT
		
;
; Cell temperature measurement (cellID --)
; Measurement is in degrees C
;
		xColon		't',cellTemp,_cellTemp
		xLIT		0xF8			; Degree symbol (Terminal font only)
		db			Space
		xLIT		TempChan<<12	; ADC channel for temperature sensor
		db			llVolt

;
; Scale it back to degrees Celsius. Typically, T = (V-Voff)/.00355 where Voff = 0.986
; But the measurement M is 4096* V/1.5 = 2731*V.
; So T = (M/2731 - Koff1)*281.7 = M/9.694 - Koff2
; To divide by 9.694, multiply by 65536/9.694 = 6760, and keep the top half

		xLIT		6760
		db			UMStar
		; Most significant half is on top of stack; nip the lower half off
		db			NIP
		; Temperature offset is now offset by 273
		xLIT		273
		db			Minus
		xLIT		TempCal			; Temp offset calibration
		db			CFetch
;		db			TwoStar			; Double
		db			CToS			; Sign extend
		db			Minus
		xLIT		3				; 3 digits
		db			prettyPrint
		db			EXIT


;
; Link voltage measurement (cellID --)
; Measurement is in mV
; Circuit has 2:1 voltage divider with Vref at the bottom.
; So meaure M = 1.5 - (1.5 - Vin)/2 = 0.75 + Vin/2.
; Reading = 2048 + (Vin/2)(4096/1.5)
; R = 2048 + Vin * 1365.3 (Vin in volts)
; R = 2048 + Vin * 1.3653 (Vin in mV)
; Vin = (R - 2048)/1.3653 mV
; To divide by 1.3653, multiply by 65536/1.3653 = 48001 and keep the top half

		xColon		'n',linkVolt,_linkVolt
		xLIT		'm'				; Units are millivolts
		DB			Space
		xLIT		LinkCal			; Link offset calibration
		db			CFetch
		xLIT		$80				; $80 is a special value representing "calibration failure"
		DB			Equals
		xIF							; If link calibration value is $80
			xLIT		0			; then use value 0
		xELSE
			xLIT		LinkVChan<<12	; Shifted ADC channel for link voltage divider
			db			llVolt
			xLIT		2048
			db			Minus
			xLIT		LinkCal			; Link offset calibration
			db			CFetch
			db			CToS			; Sign extend
			db			Minus
			db			DUP
			db			ZeroLess
			xIF
				db			NEGATE
				xLIT		48001
				db			UMStar
				db			NEGATE
			xELSE
				xLIT		48001
				db			UMStar
			xENDIF
			; Most significant half is on top of stack; nip the lower half off
			db			NIP
		xENDIF
		xLIT		4				; Print 4 digits... would 3 be enough?
		db			prettyPrint
		db			EXIT


;
; Pretty print n as a comment packet with m digits and follow with ch (ch n m--)
;
		xColon	'p',prettyPrint,_prettyPrint
		db			MS1
		xLIT		'\\'
		db			EMIT
		db			MS1				; Delay
		xLIT		ID
		db			CFetch
		xLIT		3				; 3 digits
		db			emitDec			; Emit cell number
		xLIT		':'
		db			EMIT			; Emit ':'
		db			MS1
		db			emitDec			; Emit result
		db			EMIT			; Emit "units" (V or degree symbol, etc)
		db			MS1
		xLIT		$D				; Carriage return
		db			EMIT
		db			EXIT
		
		


;
; Low level voltage measurement (channel -- measurement)
; Channel has channel number shifted left 12 bits (e.g. $7000 for cell voltage)
; Channel 7 is currently cell voltage; 10 is temperature sensor
; Measurement is in millivolts (0 to 4095 mV)
;
		xCODE		'o',llVolt,_llVolt
#if 0
;
; Initialise the ADC10 system
;
; SREF_1 = 4 volt mode; ; REFBURST = save power by turning off buffer when not sampling
; ADC10SHT_3 = 64 ADC10CLKs (~ 13 uS sample time with ADCCLK) or ADC10SHT_2 = 16 clocks (16 uS with MCLK)
; MSC = continuous sampling; REFON = turn on internal reference; ADC10ON = power up the ADC system
#if TEST
		; When testing with BMUs in parallel, we want P1.4 to be digital output 0V so that even with the
		; link input = 3.6 V, P1.3 won't exceed Vcc and therefore won't upset the ADC10 readings
#if SLOWSAMP
		mov			#SREF_1+ADC10SHT_2+MSC+REFON+ADC10ON,&ADC10CTL0
#else
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON,&ADC10CTL0
#endif
		cmp			#LinkVChan,Rtos				; ADC channel for link voltage
		jnz			noRefOut
		bis.b		#1<<4,&ADC10AE0				;  then make P1.4 analogue, and
		bis			#REFOUT,&ADC10CTL0			;  set REFOUT
		jmp			p1_4_input
noRefOut
		mov.b		#(1<<7)+(1<<3),&ADC10AE0; Enable P1.7 and P1.3 as analogue inputs, i.e.
											; make P1.4 digital
		bis.b		#1<<4,&P1DIR			; Make P1.4 an output, so when testing with paralleled BMUs,
p1_4_input									; we don't see > Vcc on P1.3 (LinkV)
#else
		; On cells, we want P1.4 to be set as an analog I/O pin (ADC10AE.4=1) and we set REFOUT in ADC10CTL0
		; so that it always outputs Vref on P1.4. That way, even with regen putting negative voltages on the
		; link input, P1.3 doesn't go below analogue ground (would invalidate readings)
#if SLOWSAMP
		mov			#SREF_1+ADC10SHT_2+MSC+REFON+ADC10ON+REFOUT,&ADC10CTL0
#else
		mov			#SREF_1+ADC10SHT_3+MSC+REFON+ADC10ON+REFOUT,&ADC10CTL0
#endif
		mov.b		#(1<<7)+(1<<3)+(1<<4),&ADC10AE0	; Enable P1.7, P1.3  and P1.4 as analogue
#endif

; INCH_7 = ADC7 (VDIV); SHS_0 = software start; ADC10SSEL_0 = ADC10OSC or _2 = MCLK;
; CONSEQ_2 = repeat-single-channel
		; Note that Rtos has the channel number already in the right position
		mov			Rtos,R8
		swpb		R8						; Move channel number to top halfword
#if SLOWSAMP
		bis			#SHS_0+ADC10SSEL_2+CONSEQ_2,R8
#else
		bis			#SHS_0+ADC10SSEL_0+CONSEQ_2,R8
#endif
		mov			R8,&ADC10CTL1
		mov.b		#NumSamples,&ADC10DTC1	; 16 conversions
		mov			#sampleBuf,&ADC10SA		; Set start address
		bis			#ENC+ADC10SC,&ADC10CTL0	; Start conversion
convert	bit			#ADC10IFG,&ADC10CTL0	; Done conversion?
		jz			convert					; No, busy wait
		bic			#ADC10ON+ENC+ADC10SC,&ADC10CTL0	; Turn off the ADC
;
; Sum the samples
;
		mov			#sampleBuf,R9
		mov			#0,R8					; Initialise the sum
addSamp	add			@R9+,R8					; Add a sample
		cmp			#sampleBuf+2*NumSamples,R9
		jnz			addSamp
;
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
		mov.b		&VoltCalL,R9			; Get voltage calibration lo byte
		mov.b		&VoltCalH,R10			; Get voltage calibration hi byte
		swpb		R10						; Assemble the two bytes into a word
		bis			R10,R9					; as multiplicand in R9
											; Multiplier is sum-of-samples, already in R8
		call		#aUMStar				; Gives unsigned product in R10 (hi word) and R9 (lo word)
											; Note: calls assembler code that ends in ret
		inc			R10						; For correct rounding
		rra			R10						; Shift product hi word right one bit
		mov			R10,Rtos				; Result
#else
		mov			Rtos,R8
		call		#measure				; Defined in ../common/measure.s43
;
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
		mov.b		&VoltCalL,R9			; Get voltage calibration lo byte
		mov.b		&VoltCalH,R10			; Get voltage calibration hi byte
		swpb		R10						; Assemble the two bytes into a word
		bis			R10,R9					; as multiplicand in R9
											; Multiplier is sum-of-samples, already in R8
		call		#aUMStar				; Gives unsigned product in R10 (hi word) and R9 (lo word)
											; Note: calls assembler code that ends in ret
		inc			R10						; For correct rounding
		rra			R10						; Shift product hi word right one bit
		mov			R10,Rtos
#endif

		next					; Finished

#include "../common/measure.s43"			; Declare the measure routine

;
; Select ( id -- ) ; Ignore to end of line if ID on TOS is not our ID
;
		; This is actually longer in bytecode
		xCODE		's',Select,_Select
		cmp.b		&ID,Rtos			; Correct ID?
		pop			Rtos				; Pop the argument
		jz			_NEXT				; If so, just continue interpreting rest of packet
		RPOP		Rip					; Pop to the bytecode that called this
		RET								; Return to the outer interpreter (i.e. ignore rest of packet)

#if 0			; Because the below would decrease the number of JMP _NEXTs that will reach
;
; For debugging only: output R12 in hex
; NOT USED AT PRESENT
hxOut	mov			R12,R8
		rrc			R8
		rrc			R8
		rrc			R8
		rrc			R8
		call		#nibOut
		mov			R12,R8
nibOut	and			#$F,R8
		; Tricky 5 word replacement for the 7 words of instructions commented-out below
		clrc				; Because dadd is always done with carry on MSP430
		dadd.b #$90,R8		; Causes no carry for 0-9, carry for A to F
		dadd.b #$40,R8		; Now any carry gets added, giving $30-$39, $41-$46 (i.e. '0'-'9','A'-'F')
;		add			#'0',R8
;		cmp			#'9'+1,R8
;		jl			noAdd
;		add			#'A'-'9'-1,R8
;noAdd:
		; Fall through to doWriteByte and return
#endif

; doWriteByte ( regs: R8 -- R9 R10 R11 ) ; Transmits byte in R8, preserves R8, trashes R9 R10 R11
; Call this instead of calling WriteByte directly
doWriteByte:
		clr			R11					; R11 is required to be cleared for the ...
		br			#WriteByte			; ... WriteByte function in the bootstrap loader (BSL)


; UM* ( u1 u2 -- ud )
; Multiply u1 by u2, giving the unsigned double product ud.
; All values and arithmetic are unsigned.
		xCODE		'X'-64,UMStar,_UMStar	; Ctrl-X
		mov		Rtos,R8
		Pop		R9
		call	#aUMStar		; Do the work in assembler-callable assembler
		push	R9
		mov		R10,Rtos
		next

; Algorithm described in http://cs.hiram.edu/~walkerel/cs252/multiply.ppt

;_UMStar						; Assembler-callable assembler
		; Starts with 16 bit multiplicand in R8, multiplier in R9 and
		; ends with 32 bit product in R10 (hi) and R9 (lo).
aUMStar:
		clr		R10			; Clear hi word of product so far
		mov		#16,R11		; Do 16 times

mullp	bit		#1,R9		; Test low bit of multiplier
		jz		mulz		; If it's a 1
		add		R8, R10		;   add multiplicand to product hi word; Endif
mulz	rrc		R10			; Shift product hi word (incl. carry) right
		rrc		R9			; into product lo and simul. shift multiplier right
		dec		R11			; Decrement loop counter
		jnz		mullp		; Loop until zero
		ret

; UM/MOD ( ud u1 -- u2 u3 )
; Divide ud by u1, giving the remainder u2 and the quotient u3.
; All values and arithmetic are unsigned. An ambiguous condition exists
; if u1 is zero or if the quotient lies outside the range of a single
; unsigned integer.
; In this case we return $FFFF for both quotient and remainder.
; Algorithm is from eForth by Bill Muench.
; It is essentially the reverse of the multiplication algorithm above.

;_UMSlashMOD             ; (was) Headerless code (no bytecode assigned)
		xCODE	'_'-64,UMSlashMOD,_UMSlashMOD	; Ctrl-_ (downward pointing triangle)
		mov     Rtos,R8  ; u1     unsigned divisor
		pop     R10      ; ud hi  unsigned dividend hi word
		pop     R9       ; ud lo  unsigned dividend lo word
		cmp     R8,R10   ; Overflow?
		jc      oflo     ; Jump to error exit if divide by zero or overflow.
		mov     #16,R11  ; Do 16 times

ummlp	rla     R9       ; Shift quotient left and simul. shift dividend lo
		rlc     R10      ;   into dividend hi
		jc      umm2     ; If carry OR
		cmp     R8,R10
		jlo     umm1     ;   no carry AND remainder-so-far >= divisor
umm2	sub     R8,R10   ;     Subtract divisor from remainder-so-far
		bis     #1,R9    ;     Set low bit of quotient-so-far
                         ; Endif
umm1	dec     R11      ; Decrement loop counter
		jnz     ummlp    ; Loop until zero

		push    R10      ; u2  unsigned remainder
		mov     R9,Rtos  ; u3  unsigned quotient
		next

oflo	PUSH    #-1
		PUSH    #-1
		next


; * ( n1|u1 n2|u2 -- n3|u3 )
; Multiply n1|u1 by n2|u2 giving the single product n3|u3.
; i.e. same routine works for signed or unsigned.

		xColon '*',Star,_Star
;		xLIT _UMStar    ; Do the multiplication
;		DB   CALLM
		db	 UMStar
		DB   DROP       ; Throw away the high word of the result
		DB   EXIT

; U/ ( u1 u2 -- u3 )
; Divide u1 by u2, giving the single unsigned quotient u3.
; Returns $FFFF if u2 is zero.

		xColon  '/',Slash,_Slash
		DB   ToR           ; Move divisor to return stack temporarily
		xLIT 0             ; Pad the dividend to a double word
		DB   RFrom         ; Bring divisor back from return stack
;		xLIT _UMSlashMOD   ; Do the division
;		DB   CALLM
		db	UMSlashMOD
		DB   NIP           ; Throw away the remainder
		DB   EXIT

;
; emitDec  ( n count -- ) ; Emit an integer n as count decimal digits

		xColon	'm',emitDec,_emitDec
		db		ToR					; n on data stack, count on return stack
		db		DUP
		db		ZeroLess
		xIF								; If n is negative
			xLIT	'-'
			db		EMIT					; Emit leading minus sign
			db		MS1
			db		NEGATE
		xENDIF
		
		db		RFetch					; Copy count from return stack
		db		OneMinus				; count-1
		xLIT	0
		xQDO
			xLIT	0
			db		Space
			xLIT	10
			db		UMSlashMOD
			; Now we have rem1 ... remn-1 quotient=current-number
		xLOOP
		; Now we have the quotient on TOS and remainder under; no need for another divide by 10
		db		RFrom		; Get count from return stack
		xLIT	0
		xQDO
			xLIT	'0'
			db		Plus
			db		EMIT		
			db		MS1			; Delay 1 transmit byte time
		xLOOP
		db		EXIT
		
		
; . ( n -- ) ; Print the signed number on top of stack (currently only in decimal)
		xColon		'.',Dot,_Dot
		xLIT		5			; Always show 5 digits, for now
		DB			emitDec
		DB			EXIT
		

; Regular tick.
; Turn on the bypass resistors if the cell is over 3.55 V
; Send badness message if over or under volts
		xColon		'k',Tick,_Tick
		xLIT		CellVChan<<12	; ADC channel for cell voltage divider
		db			llVolt
		db			DUP
		xLIT2		bypassVolts
		db			Fetch
		db			DUP
		db			ZeroEquals
		xIF							; If bypassVoltage is zero
			db			DROP			; then drop the duplicated zero
			xLIT		3600			; Put fixed bypass voltage to TOS
		xENDIF
		db			UGreater		; 1 if greater, 0 otherwise
		db			bypass			; Bypass if cell voltage > 3.65 V (or > bypassVoltage if 'd' command is active)
		db			DUP
		; Overvoltage badness: for every 50 mV over 3.60 V, we add one level of badness, to a maximum of 7 for > 3.95 V
		xLIT		3650-49
		db			Minus			; Measurement - 3.65 V + 0.49 V
		xLIT		0
		db			MAX				; Minimum of 0
		xLIT		50
		db			Slash			; Divide by 50 mV
		; Undervoltage badness: for every 100 mv below 2.5 V, we add one level of badness, to a maximum of 7 for < 1.9 V
		db			SWAP			; Original measurement on top
		xLIT		2500+99
		db			SWAP
		db			Minus			; 2.5 V - measurement + 0.99 V
		xLIT		0
		db			MAX				; Minimum of 0
		xLIT		100
		db			Slash			; Difference / 100
		db			MAX				; Get the max of overvolts and undervolts
		xLIT		7
		db			MIN				; Maximum of 7 for either
		db			DUP				; For error LED below
		xLIT2		currBadness		; Address of current badness
		db			CStore			; Store it
		db			errorLed		; Turn on error LED if any badness
		
		db			EXIT

;
; Delay for n milliseconds (n --)
;
		xCODE	'z',MS,_MS
MSloop1	mov		#331,R8		; 1 ms delay, less a few overheads
MSloop2	dec		R8
		jnz		MSloop2
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL		; Clear and restart Watchdog Timer
		dec		Rtos
		jnz		MSloop1
		pop		Rtos
		next
		
		xCODE	'H'-64,MS1,_MS1		; 1.04 ms delay; commonly needed (--) Not from keyboard
		mov		#345,R8
MS1loop2 dec	R8
		jnz		MS1loop2
		next

;
; Clear watchdog timer. DO WE NEED THIS?
; We do if we remove the watchdog clear on every bytecode
; that's slowing down the inner interpreter
;
		xCODE	'w',clearWatchDog,_clearWatchDog
		mov.w	#WDTPW+WDTCNTCL,&WDTCTL		; Clear and restart Watchdog Timer
		next
		

;
; Turn on or off the error LED (bool -- )
;
#if	1
		xColon	'l',errorLed,_errorLed
		xLIT	LED
		DB		Space
		xLIT	P1OUT
		DB		ROT
		xIF
			DB		CBITSET
		xELSE
			DB		CBITCLR
		xENDIF
		DB		EXIT
		
#else
		xCODE	'l',errorLed,_errorLed
		and		Rtos,Rtos		; Clears carry if was zero
		subc	Rtos,Rtos		; -1 if was 0, 0 otherwise
		inv		Rtos			; 0 if was 0, -1 otherwise
		xor.b	&P1OUT,Rtos		; Rtos has all the bits that are different
		and.b	#LED,Rtos		; Leave only LED bit standing
		xor.b	Rtos,&P1OUT		; Toggle if necessary
		pop		Rtos			; Remove operand
		next
#endif

;
; Turn on or off bypass resistors (bool -- )
;
#if 1
		xColon	'y',bypass,_bypass
		xLIT	BYP
		DB		Space
		xLIT	P1OUT
		DB		ROT
		xIF
			DB		CBITSET
		xELSE
			DB		CBITCLR
		xENDIF
		DB		EXIT
		
#else
		xCODE	'y',bypass,_bypass
		and		Rtos,Rtos		; Clears carry if was 0
		subc	Rtos,Rtos		; -1 if was 0, 0 otherwise
		inv		Rtos			; 0 if was 0, -1 otherwise
		xor.b	&P1OUT,Rtos		; Rtos has all the bits that are different
		and.b	#BYP,Rtos		; Leave only BYP bit standing
		xor.b	Rtos,&P1OUT		; Toggle if necessary
		pop		Rtos			; Remove operand
		next
#endif

;
; Emit the calibration value: TEMPORARY
;
#if 0
		xColon	'c',calval,_calval
		xLIT	'C'
		db		Space
		xLIT	VoltCal
		db		CFetch
		xLIT	3
		db		prettyPrint
		db		EXIT
#endif

;
; aUtonomous operation; cell 0 sends tick commands to others; last cell operates warning LED/buzzer
; For 'u' command, top of stack has number of cells (num_cells --)
; 'd' (Discharge) command is the same, but sets bypass voltage to a value from the second operand
; (num_cells thresh --) thresh is in millivolts
; 'd' can be used for top, mid, or bottom balancing at various voltages
; Since 'd' relies on a value in RAM, most charging should use 'u' instead
;

		xColon	'u',auton,_auton
		xLIT	0
		db		Space
		; Fall through to 'd' command; 'u' is like "num_cells 0 d"

		xColon	'd',Discharge,_Discharge
		xLIT2	bypassVolts
		db		Store		; Set or clear bypassVolts based on u or d commmand
		xLIT	ID
		db		CFetch
		db		ZeroEquals
		xIF
			;
			; Cell 0 is special: send ticK command every 2 seconds
			;
			db		DROP		; Ignore the number of cells
			xLIT	2			; Allow time for
			db		MS			;   downstream neighbour to echo CR
			xBEGIN				; Start of indefinite loop
				xLIT	'k'
				db		EMIT
				db		MS1
#if CHECKSUM
				xLIT	'k'
				db		EMIT
				db		MS1
#endif
				xLIT	$D			; emit 'k [k] carriage return'
				db		EMIT
		#if 1
				xLIT	0
				db		errorLed	; Turn off the LED due to the emits
		#endif						;   (may come back on due to \B from Tick below)
				db		Tick		; Do tick processing ourselves!
				xLIT	3800		; ~ 1 second total loop time
				DB		Space
				xLIT	0
				xQDO				; Start of counted loop
					db		quiet		; Is the RS232 quiet?
					db		ZeroEquals	; Not
					xIF
						DB		UNLOOP, EXIT	; Exit routine if RS232 is not quiet
					xENDIF ; End: if not quiet
				xLOOP	; Decrement and jump if not negative, back to xQDO
			xAGAIN	; Keep looping to xBEGIN			
		xENDIF	; End: if ID is zero
		db		OneMinus	; Number of cells -1
		xLIT	ID
		db		CFetch
		db		Equals
		; If last cell, need special processing of \ command to check for 'B' (Badness)
		xLIT2	bCheckForBad
		db		CStore
		db		EXIT		; Then do nothing (apart from waiting for more commands)
		
;
; Quiet - is the RS232 input quiet?  ( -- flag )
; Returns -1 for quiet, 0 for byte being sent
;
		xCODE	'q',quiet,_quiet
		push	Rtos
		mov.b	&P1IN,Rtos
		and.b	#RXD,Rtos		; Clears carry if was zero
		subc	Rtos,Rtos		; -1 if was 0, 0 otherwise
		inv		Rtos			; -1 if was 1 (= quiet)
		next

;
; Set or reset alarm ( flag -- )
;
		xCODE	'g',alarm,_alarm
		call	#m_alarm			; Machine code does the work
		pop		Rtos				; Remove argument
		next

; NOTE: pure machine code (ends in RET instruction)
; Do the work of setting or clearing the alarm (based on Rtos)
m_alarm:		
		tst.b	Rtos
		jnz		setAlarm
		bis.b	#TXDp,&P1OUT		; Unset alarm
		bic.b	#TXDm,&P1OUT
		ret
setAlarm bis.b	#TXDm,&P1OUT		; Set alarm!
		bic.b	#TXDp,&P1OUT
		ret


;
; Link voltage offset caliBration (--)
; Assumes zero link voltage due to zero link current
;
		xColon	'b',calLink,_calLink
		xLIT2	LinkVChan<<12
		DB		llVolt
		xLIT	2048				; Zero volts for link voltage is a 2048 reading
		DB		Minus				; So subtract from result
		DB		DUP
		xLIT	$80
		xLIT	$FF81				; -$7F
		DB		WITHIN
		xIF							; If result (under TOS) is < -$7F or >= $80
			DB		DROP				; then discard the result
			xLIT	$80					; and replace with $80
			DB		Space				; Next bytecode is an xLIT
		xENDIF
		xLIT2	LinkCal
		DB		FlashCStore			; Write the calibration value
		DB		EXIT


;
; FlashC! ( char c-addr -- ) ; DANGER: flash byte-write command
;
			xCODE	'M'-64,FlashCStore,_FlashCStore
			mov		Rtos,R9
			pop		R8
			call	#aFlashCStore
			pop		Rtos
			BR		#_NEXT					; FIXME!
			
aFlashCStore:
			; Assembly language flash writer
			; Byte  in R8, address in R9. Trashes R10
			;
			; Check if it is possible to flash-program this ID
			;
			mov.b		R8,R10				; Need to check for 1 bits in new ID
			bic.b		@R9,R10			    ;	that are already 0s in the existing byte
			tst.b		R10					; Set Z flag if result is 0; bic doesn't
			jnz			cantFlsh			; Impossible flash-write; can't do it
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3
			MOV 	#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV 	#FWKEY,&FCTL3       	; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write block that can't be)
			CLRLOCKA
			mov.b	R8,0(R9)				; Flash-write it
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming
			SETLOCKA
			MOV		#FWKEY,&FCTL1			; Disable flash write
			bic.b	#LED,&P1OUT				; Clear the error LED: done!
			ret
cantFlsh	bis.b	#LED,&P1OUT				; Set the error LED to indicate failure
			ret
			

; Test of string-output-compiling macro xDotQuote (Forth ." )
			xColon	'a',helloWorld,_helloWorld
			xDotQuote	'Hello World\r'
			DB 		EXIT
			
CP0			; Used to set the initial value of CP (Code Pointer).

; To Do:
; Implement backspace editing.
; All undefined bytecodes should act as literal separators if not digits.


		ORG		0xFFFE			; Reset power-on vector
		DW		0x1000			; Start of BSL

		END
