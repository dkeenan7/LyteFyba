;------------------------------------------------------------------------------
; CONSTANTs

xBL        MACRO    ; Blank
           xLIT     $20
           ENDM
           
xFALSE     MACRO
           xLIT     0
           ENDM
           
xTRUE      MACRO
           xLIT     -1
           ENDM

;-------------------------------------------------------------------------------
; Basic stack-machine bytecode definitions
; e.g. DUP SWAP DROP OVER + - AND OR XOR etc.


; hexMode ( bool -- ) ; Set the hexadecimal (vs decimal) input mode flag

		xCODE	'h',hexMode,_hexMode
		mov.b	Rtos,&hexFlag
		pop		Rtos
		next

; CLIT ( -- c ) ; Character literal. Treat the next bytecode as a literal character.

		xCODE	'\'',CLIT,_CLIT ; single-quote
		PUSH	Rtos
		MOV.B	@Rip+,Rtos
		next

; Space	( -- x )	; Push any literal-in-progress. Like ENTER key on RPN calculator.
        xColon  ' ',Space,_Space     ; Space. For separating literals
        DB EXIT

; DROP	( x -- )	; Discard top stack item.
		xCODE	'Y'-64,DROP,_DROP ; Ctrl-Y $19
		POP	Rtos
		next

; DUP 	( x -- x x )	; Duplicate the top stack item.
		xCODE	'Z'-64,DUP,_DUP ; Ctrl-Z $1A, right-arrow in the Terminal font
		PUSH	Rtos
		next

; ?DUP	( x -- x x | 0 ) ; Duplicate top of the stack if it is not zero.
;
;   : ?DUP	DUP IF DUP ENDIF ;
;
;		XColon	'?',QDUP,_QDUP
;		DB	DUP
;       xIF
;		  DB	DUP
;       xENDIF
;		DB	EXIT

		xCODE	'?',QDUP,_QDUP,0
		TST	Rtos
		JZ	QDUP1
		PUSH	Rtos
QDUP1:	next

; SWAP	( x1 x2 -- x2 x1 ) ; Exchange top two stack items.
		xCODE	'R'-64,SWAP,_SWAP ; Ctrl-R $12
        POP	Rw
		PUSH	Rtos
		MOV	Rw,Rtos
		next

; OVER	( x1 x2 -- x1 x2 x1 ) ; Copy second stack item to top of the stack.
		xCODE	'O'-64,OVER,_OVER ; Ctrl-O $0F
		MOV	SP,Rw
		PUSH	Rtos
		MOV	@Rw,Rtos
		next

;   ROT 	( x1 x2 x3 -- x2 x3 x1 )
;		Rotate the top three data stack items.
;
;   : ROT	>R SWAP R> SWAP ;
;
		xColon	'P'-64,ROT,_ROT ; Ctrl-P $10
		DB	ToR,SWAP,RFrom,SWAP,EXIT

;		xCODE	'P'-64,ROT,_ROT ; Ctrl-P $10
;		POP	Rw
;		POP	R10
;		PUSH	Rw
;		PUSH	Rtos
;		MOV	R10,Rtos
;		next

;   -ROT 	( x1 x2 x3 -- x3 x1 x2 )
;		Rotate the top three data stack items.
;
;   : -ROT	ROT ROT ;
;
		xColon	'Q'-64,MinusROT,_MinusROT ; Ctrl-Q $11
		DB	ROT,ROT,EXIT

;		xCODE	'Q'-64,MinusROT,_MinusROT ; Ctrl-Q $11
;		POP	Rw
;		POP	R10
;		PUSH	Rtos
;		PUSH	R10
;		MOV	Rw,Rtos
;		next

;   NIP 	( n1 n2 -- n2 )
;		Discard the second stack item.
;
;   : NIP	SWAP DROP ;
;
		xColon	'P',NIP,_NIP,
		DB	SWAP,DROP,EXIT

;		xCODE	'P',NIP,_NIP
;		INCD	SP
;		next

;   TUCK 	( n1 n2 -- n2 n1 n2)
;		Copy the top stack item to under the second-top item.
;
;   : TUCK	SWAP OVER ;
;
		xColon	'U',TUCK,_TUCK,
		DB	SWAP,OVER,EXIT

;		xCODE	'U',TUCK,_TUCK
;		POP     Rw
;               PUSH    Rtos
;               PUSH    Rw
;		next

;   2DUP	( x1 x2 -- x1 x2 x1 x2 )
;		Duplicate cell pair x1 x2.
;
		xColon	'N'-64,TwoDUP,_TwoDUP ; Ctrl-N $0E
		DB	OVER,OVER,EXIT
		
;		xCODE	'N'-64,TwoDUP,_TwoDUP ; Ctrl-N $0E
;		MOV	SP,Rw
;		PUSH	Rtos
;		PUSH	@Rw
;		next

;   2SWAP	( x1 x2 x3 x4 -- x3 x4 x1 x2 )
;		Exchange the top two cell pairs.
;
;   : 2SWAP	ROT >R ROT R> ;
;
		xColon	'S',TwoSWAP,_TwoSWAP
		DB	ROT,ToR,ROT,RFrom,EXIT

#if 0		; 'D' wanted as hex digit and 'd' for Discharge command
;   DEPTH	( -- +n )
;		Return the depth of the data stack.
;
;   : DEPTH	sp0 dsp@ - cell-size / ;

		xCODE	'D',DEPTH,_DEPTH
        PUSH    Rtos
		MOV     #$280,Rtos
        SUB     SP,Rtos
        RRA     Rtos
        next
#endif

;   !		( x a-addr -- )
;		Store x at a aligned address.

		xCODE	'!',Store,_Store
		POP		0(Rtos)
		POP		Rtos
		next

;   0<		( n -- flag )
;		Return true if n is negative.

		xCODE	'[',ZeroLess,_ZeroLess
		RLA		Rtos		;get sign into carry
		SUBC	Rtos,Rtos		;0 if carry set, -1 if carry clear
		INV		Rtos
		next

;   0=		( x -- flag )
;		Return true if x is zero.

		xCODE	'Z',ZeroEquals,_ZeroEquals
		AND		Rtos,Rtos		;sets carry if result nonzero
		SUBC	Rtos,Rtos		;0 if carry set, -1 if carry clear
		next
		
;   ABS 	( n -- u )
;		Return the absolute value of n.

		xColon	'F'-64,ABS,_ABS ; Ctrl-F $06, Spade card symbol in Terminal font
		db		DUP
		db		ZeroLess
		xIF						; If operand is <0
			db		NEGATE		;   then negate
		xENDIF
		db		EXIT

;		xCODE	'F'-64,ABS,_ABS ; Ctrl-F $06, Spade card symbol in Terminal font
;		tst		Rtos
;		jge		ABS1
;		inv		Rtos
;		inc		Rtos
;ABS1	next

;   U<		( u1 u2 -- flag )
;		Unsigned compare of top two items. True if u1 < u2.
;
;   : U<	2DUP XOR 0< IF NIP 0< EXIT THEN - 0< ;
;
;		xColon	'{',ULess,_ULess
;		DB	TwoDUP,XORR,ZeroLess
;		DB	ZJump,ULES1
;		DB	NIP,ZeroLess,EXIT
;ULES1		DB	Minus,ZeroLess,EXIT

		xCODE	'{',ULess,_ULess
		POP	Rw
		CMP	Rtos,Rw
		SUBC	Rtos,Rtos
		next
		
;	U>		(u1 u2 -- flag )
;		Unsigned compare of top two items. True if u1 > u2.

		xCODE	'}',UGreater,_UGreater
		POP	Rw
		CMP	Rw,Rtos		; Compare "the wrong way"
		SUBC	Rtos,Rtos
		next
		

;   <		( n1 n2 -- flag )
;		Returns true if n1 is less than n2.
		xCODE	'<',LessThan,_LessThan
		POP	Rw
		CMP	Rtos,Rw
LESS0:	JL	LESS1
		MOV	#0,Rtos
		next
LESS1:	MOV	#-1,Rtos
		next

;   >		( n1 n2 -- flag )
;		Returns true if n1 is greater than n2.
		xCODE	'>',GreaterThan,_GreaterThan
		POP		Rw
		CMP		Rw,Rtos	; Compare "the wrong way"
		JMP		LESS0

;   =		( x1 x2 -- flag )
;		Return true if top two are equal.
;
;   : = 	XOR 0= ;
;
;		xColon	'=',Equals,_Equals,0
;		DB	XORR,ZeroEquals,EXIT

		xCODE	'=',Equals,_Equals
		POP		Rw
		XOR		Rw,Rtos		;sets carry if result nonzero (not equal)
		SUBC	Rtos,Rtos	;-1 if not carry (borrow), 0 otherwise
		next
		
		xColon	'N',NotEquals,_NotEquals
		db		Equals,ZeroEquals,EXIT
		
;   WITHIN	( n|u n1|n1 nh|uh -- flag )
;		Return true if (n1|u1 <= n|u and n|u < n2|u2) or
;		(n1|u1 > n2|u2 and (n1|u1 <= n|u or n|u < n2|u2)).
;
;   : WITHIN	OVER - >R - R> U< ;

		xColon	'W',WITHIN,_WITHIN
		DB	OVER,Minus,ToR			;ul <= u < uh
		DB	Minus,RFrom,ULess,EXIT

;		xCODE	'W',WITHIN,_WITHIN
;		pop		Rw
;		sub		Rw,Rtos
;		pop		R9
;		sub		Rw,R9
;		cmp		Rtos,R9
;		subc	Rtos,Rtos		;-1 if no carry (borrow), 0 otherwise
;		next

;   2*		( x1 -- x2 )
;		Bit-shift left, filling the least significant bit with 0.

		xCODE	'L',TwoStar,_TwoStar
		RLA		Rtos
		next

;   2/		( x1 -- x2 )
;		Bit-shift right, leaving the most significant bit unchanged.

		xCODE	'%',TwoSlash,_TwoSlash
		RRA		Rtos
		next

;   >R		( x -- ) ( R: -- x )
;		Move top of the data stack item to the return stack.

		xCODE	'O',ToR,_ToR
		RPUSH	Rtos
		POP		Rtos
		next

;   R>		( -- x ) ( R: x -- )
;		Move x from the return stack to the data stack.

		xCODE	'R',RFrom,_RFrom
		PUSH	Rtos
		RPOP    Rtos
		next

;   R@		( -- x ) ( R: x -- x )
;		Copy top of return stack to the data stack.

		xCODE	'V'-64,RFetch,_RFetch ; Ctrl-V $16
		PUSH	Rtos
		MOV		@Rrsp,Rtos
		next

;   @		( a-addr -- x )
;		Push the contents at a-addr to the data stack.

		xCODE	'@',Fetch,_Fetch
		MOV		@Rtos,Rtos
		next

; + 	( x1 x2 -- x3 ) ; Addition.
		xCODE	'+',Plus,_Plus
		POP		Rw
		ADD		Rw,Rtos
		next

; - 	( x1 x2 -- x3 ) ; Subtraction.
		xCODE	'-',Minus,_Minus
		POP		Rw
		SUB		Rtos,Rw
		MOV		Rw,Rtos
		next

;   +!		( n|u a-addr -- )
;		Add n|u to the contents at a-addr.
;
;   : +!	SWAP OVER @ + SWAP ! ;
;
;		xColon	'S'-64,PlusStore,_PlusStore ; Ctrl-S $13
;		DB	SWAP,OVER,Fetch,Plus
;		DB	SWAP,Store,EXIT
		
		xCODE	'S'-64,PlusStore,_PlusStore ; Ctrl-S $13
		POP		Rw
		ADD		Rw,0(Rtos)
		POP		Rtos
		next

;   C+!		( n|u a-addr -- )
;		Add n|u to the contents at a-addr.
;
;   : C+!	SWAP OVER C@ + SWAP C! ;
;
;		xColon	'T'-64,CPlusStore,_CPlusStore ; Ctrl-T $14
;		DB	SWAP,OVER,CFetch,Plus
;		DB	SWAP,CStore,EXIT
		
		xCODE	'T'-64,CPlusStore,_CPlusStore ; Ctrl-T $14
		POP		Rw
		ADD.B	Rw,0(Rtos)
		POP		Rtos
		next

; AND 	( x1 x2 -- x3 ) ; Bitwise AND.
		xCODE	'&',ANDD,_ANDD
		POP		Rw
		AND		Rw,Rtos
		next

; OR 	( x1 x2 -- x3 ) ; Bitwise OR.
		xCODE	'|',ORR,_ORR
		POP		Rw
		BIS		Rw,Rtos
		next

; XOR 	( x1 x2 -- x3 ) ; Bitwise XOR.
		xCODE	'^',XORR,_XORR
		POP		Rw
		XOR		Rw,Rtos
		next
        
; INVERT ( x1 -- x2 ) ; Return one's complement of x1.
;
;   : INVERT	-1 XOR ;
;
;		xColon	'~',INVERT,_INVERT
;       xLIT    -1
;		DB	XORR,EXIT

		xCODE	'~',INVERT,_INVERT
		INV	Rtos
		next
		
; C>S	( c -- n ) ; Sign-extend a character to a signed word. 
;
		xCODE	'E'-64,CToS,_CToS
		sxt		Rtos
		next

        
; 1+	( n1|u1 -- n2|u2 ) ; Increment top of the stack item.
;
;   : 1+	1 + ;
;
;		xColon	';',OnePlus,_OnePlus ; semicolon character
;       xLIT    1
;		DB		Plus, EXIT

		xCODE	';',OnePlus,_OnePlus ; semicolon character
		inc	Rtos
		next
		

; 1-	( n1|u1 -- n2|u2 )
;		Decrease top of the stack item by 1.
;
;   : 1-	-1 + ;
;
;		xColon	'`',OneMinus,_OneMinus ; tock (back-quote) character
;		xLIT	-1
;		DB		Plus, EXIT

		xCODE	'`',OneMinus,_OneMinus ; tock (back-quote) character
		dec	Rtos
		next

;   ALIGNED	( addr -- a-addr )
;		Align address to the cell boundary.

		xCODE	'C'-64,ALIGNED,_ALIGNED		; Ctrl-C $03
		INC	Rtos
		BIC	#1,Rtos
		next

; NEGATE ( n1 -- n2 ) ; Return two's complement of n1.
;
;   : NEGATE	INVERT 1+ ;
;
;		xColon	'_',NEGATE,_NEGATE
;		DB	INVERT,OnePlus,EXIT
		
		xCODE	'_',NEGATE,_NEGATE
		INV	Rtos
		INC	Rtos
		next

; C!	( char c-addr -- ) ; Store char at c-addr.

		xCODE	'$',CStore,_CStore
		POP	Rw
		MOV.B	Rw,0(Rtos)
		POP	Rtos
		next

; C@	( c-addr -- char ) ; Fetch the character stored at c-addr.

		xCODE	'#',CFetch,_CFetch
		MOV.B	@Rtos,Rtos
		next
		
	
; CBITCLR ( bitmask c-addr -- )
; : CBITCLR		DUP C@ ROT INVERT AND SWAP C! ;

	xCODE 'K'-64,CBITCLR,_CBITCLR ; ( bitmask c-addr -- )
	pop	Rw
	bic.b	Rw,0(Rtos)
	pop	Rtos
	next
	
; CBITSET ( bitmask c-addr -- )
; : CBITSET		DUP C@ ROT OR SWAP C! ;

	xCODE 'L'-64,CBITSET,_CBITSET ; ( bitmask c-addr -- )
	pop	Rw
	bis.b	Rw,0(Rtos)
	pop	Rtos
	next
	
; CBITTOG ( bitmask c-addr -- )
; : CBITTOG 	DUP C@ ROT XOR SWAP C! ;
#if 0
	xCODE 'W'-64,CBITTOG,_CBITTOG ; ( bitmask c-addr -- )
	pop	Rw
	xor.b	Rw,0(Rtos)
	pop	Rtos
	next
#endif

; CBITTST is not worth having since it only saves a byte over C@ AND. 
; You'd have to use it more than 3 times in other code for it to save the space 
; of its definition. (More than 8 times if it's defined in assembler).

; CBITTST ( bitmask c-addr -- maskedbits )
; : CBITTST		C@ AND ;
#if 0
	xCODE 'G'-64,CBITTST,_CBITTST ; ( bitmask c-addr -- maskedbits )
	mov.b	@Rtos,Rtos
	pop	Rw
	and	Rw,Rtos
	next
#endif

; LSHIFT	( x1 u -- x2 ) ; logical left shift of u bits on x1, giving x2
;   : LSHIFT	0 ?DO 2* LOOP ENDIF ;
;
;		xColon	'(',LSHIFT,_LSHIFT
;		xLIT	0
;		xQDO
;			DB	TwoStar
;		xLOOP
;		DB	EXIT

	xCODE '(',LSHIFT,_LSHIFT
	mov	Rtos,Rw
	pop	Rtos
lsloop
	dec	Rw
	jnc	_NEXT	; jump if borrow, to _NEXT
	rla	Rtos
	jmp	lsloop
	
	
; RSHIFT	( x1 u -- x2 ) ; logical right shift of u bits on x1, giving x2
;   : RSHIFT	0 ?DO 2/ LOOP ENDIF ;
;
;		xColon	')',RSHIFT,_RSHIFT
;		xLIT	0
;		xQDO
;			DB	TwoSlash
;		xLOOP
;		DB	EXIT

	xCODE ')',RSHIFT,_RSHIFT
	mov	Rtos,Rw
	pop	Rtos
rsloop
	dec	Rw
	jnc	_NEXT	; jump if borrow, to _NEXT
	clrc
	rrc	Rtos
	jmp	rsloop

        
; EMIT	( c -- ) ; Send a character to the output device.

		xCODE	'M',EMIT,_EMIT
		mov.b	Rtos,R8				; WriteByte uses R8 as parameter
        POP     Rtos				; Pop first to save stack space
		CALL    #doWriteByte		; Call WriteByte in info-flash (via a thunk that clears R11 first)
		next
		
; TYPE	( c-addr u -- ) ; Send u characters to the output device from c-addr

		xColon	'T',TYPE,_TYPE
		xLIT	0
		xQDO
			DB		DUP, CFetch, EMIT, OnePlus
		xLOOP
		DB		EXIT
		
#if 0		; 'M' wanted for EMIT because 'E' wanted as hex digit        
;   MOVE	( addr1 addr2 u -- )
;		Copy u address units from addr1 to addr2 if u is greater
;		than zero. This word is CODE defined since no other Standard
;		words can handle address unit directly.

		xCODE	'M',MOVE,_MOVE
		POP	Rw
		POP	R10
		TST	Rtos
		JZ	MOVE2
		CMP	Rw,R10
		JC	MOVE1
		PUSH	SR
		DINT
MOVE3:	;	BIT	#BUSY,&FCTL3	;in case the destination is flash
		JNZ	MOVE3
		MOV.B	@R10+,0(Rw)
		INC	Rw
		DEC	Rtos
		JNZ	MOVE3
		POP	SR
MOVE2:		POP	Rtos
		next
		
MOVE1:		ADD	Rtos,Rw		;start at end and work backwards
		DEC	Rw
		ADD	Rtos,R10
		DEC	R10
		PUSH	SR
		DINT
MOVE4:	;	BIT	#BUSY,&FCTL3	;in case the destination is flash
		JNZ	MOVE4
		DEC	Rw
		DEC	R10
		MOV.B	@R10,0(Rw)
		DEC	Rtos
		JNZ	MOVE4
		POP	SR
		POP	Rtos
		next
#endif

;   S"Run        ( u -- c-addr u )
;		Run-time code for string literals
;
;   : S"Run      R> SWAP 2DUP + >R ; COMPILE-ONLY

		xColon	'\"',SQuoteRun,_SQuoteRun
		DB		RFrom, SWAP, TwoDUP, Plus, ToR, EXIT

                
;   HERE	( -- addr )
;		Return data space pointer.
;
;   : HERE	VP @ ;

		xColon	'H',HERE,_HERE
        xLIT2	VP
		DB		Fetch, EXIT


;   COMPILE,	( xt -- )
;		Compile the execution token on data stack into current
;		colon definition.
;
;   : COMPILE,	CP DUP 1 +! @ FlashC! ;
		xColon	',',COMPILEComma,_COMPILEComma
		xLIT2 	CP			; Get address of code pointer
        DB   	DUP
        xLIT	1
        DB		PlusStore	; Increment it
		DB		Fetch		; Fetch the pointer
		DB		FlashCStore	; Store the byte where it points
		DB		EXIT

