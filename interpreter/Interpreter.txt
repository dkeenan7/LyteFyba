      Coulomb & Weber's Digital BMU Command Interpreter
      -------------------------------------------------

The interpreter is a token (or bytecode) Forth that runs on an MSP430F2012 that has only 128 bytes of RAM and 2k bytes of flash.

We divide the RAM into 4 equal parts. 32 bytes of variables, 32 byte input buffer, 32 byte Forth return stack, 32 byte Forth data and machine stack.

There is a tiny extra 256 bytes of "information flash" that can remain unerased when the main 2k is erased, and so, with incredible feats of optimisation, Mike has written a 3-times-oversampling software UART and Bootstrap-loader (BSL) that live in this 256 bytes. This model of MSP430 doesn't come with a built-in BSL and in any case that requires hardware handshaking. Our BSL monitors incoming serial data looking for a password consisting of 3 control characters ^B^A^D which should never occur in normal traffic. When it receives them it erases the main flash and writes the next 2k-minus-2 bytes of data there. The minus 2 is for the reset vector which must remain pointing to the BSL. The BSL then receives a checksum and if it's good, goes back to passing serial data to the Forth interpreter (or whatever now lives in main flash).

There is no way we can fit a proper Forth outer interpreter, with compiler, into this 2k of main flash, so definitions are currently cross-compiled using an assembler on the host PC.

All Forth compiling words (immediate words) are implemented as assembler macros in the MSP430 Assembler. This includes all Forth control-flow words and literal-compiling words.

For the control-flow words, we implement a crude stack in the assembler, using assignments between numbered assembler variables, one per stack element. This stack is used to keep track of the source and destination addresses of nested control structures so that jump offsets can be back-filled when they are known, in the usual Forth manner.

Another version of these macros is used to do structured control-flow for ordinary assembly of machine code too. They can be used by people writing in any assembler, with no particular interest in Forth. The modifications required, are just for the specific format of the jump instructions for a given processor. So in the assembly-language source I have two sets of Forth-style structured control flow macros. One set "xIF, xWHILE" etc. for cross-compiling Forth (Colon definitions) and the other set "_IF, _WHILE" etc. for assembly language (CODE definitions). So despite being in assembly language, our source-code is somewhat Forth-like to read.

All non-immediate Forth words are encoded as a single ASCII character or "bytecode", usually with some mnemonic value. So I thought of calling this language "Wunth", short for "one-character Forth". :-) It can have a max of 128 Forth words, not counting the immediate (compiling) words which are implemented as assembler macros).

But rather than have to remember these "Wunth" characters, each is assigned to an assembler label which is as close to the Forth word as possible, e.g. TwoStar for 2*. However the mnemonic value of the bytecodes, as text, will be useful in debugging.

Wunth is based on Dr Wonyong Koh's hForth, an ANS Forth that I began porting to the MSP430 (from the Intel x86) many years ago. But now with a completely new inner-interpreter, which is token-threaded for code-compactness, in place of the original address-threaded inner-interpreter.

Since each word name is a single character, which is also its execution token, dictionary lookup and compilation is a no-op. There is no dictionary, only a token lookup table with 128 word-sized entries (one for each ASCII character). Each entry is the address of the word's definition, with the high bit set if it is a Colon definition or cleared if it is CODE.

Literals are encoded 7 bits at a time, in bytes with the high bit set. This is similar to the Transputer PFIX instructions, but is signed rather than having a separate NFIX instruction for negative values. Values in the range -64 to 63 are encoded in a single byte. -8192 to 8191 in max two bytes and all 16 bit values in max 3 bytes. The bytes are sent most-significant first, with the first byte determining the sign. If two literals need to be sent with no operation between them, there must be a "Space" bytecode (or other no-op) between them to terminate the first literal and cause it to be pushed to the stack. This literal-separating no-op serves the same function as an ENTER key on an RPN calculator. In Forth source any whitespace can separate literals and so I made the bytecode for "Space" be the space character.

Bytecode/Wunth will be sent from the host in packets with checksums (max 32 bytes) and will not be executed unless the checksum is good. The end-of-packet character is the carriage return. So this is like a really cut-down outer interpreter interpreting lines of Forth/Wunth.

To define new Forth words on the MSP430, we can already use the Bootstrap loader to rewrite the entire 2k of flash with a newly assembled kernel via the serial port. But in future we could send a bytecode-to-be-defined, as a literal number, followed by a postfix command analogous to the prefix command ":" (or "CODE") that stores "HERE" (the next flash address) into the appropriate slot in the bytecode lookup table. Then the code for the new definition can follow as a sequence of literals followed by "," (COMPILE-comma) commands that write them to successive flash locations. They could be machine-code or bytecode/Wunth.

Built-in Forth words, other than compiling words and literals, are assigned bytecodes/Wunth-names as follows:

Unary arithmetic and logic operators
Wunth Forth      Description           (Notes)
--------------------------------------------------------------------------
L     2*         Arithmetic (or logical) shift left one place (was \)
%     2/         Arithmetic shift right one place
^^    1+         Increment             (Ctrl-caret)
`     1-         Decrement             (grave or backquote)
^C    ALIGNED    Next even number      (heart symbol)
^F    ABS        Absolute value        (spade symbol)
~     INVERT     Bitwise negation      (tilde)
_     NEGATE     Unary minus           (underscore)
Z     0=  NOT    Logical negation      ("N" rotated 90^ for "NOT")
                 Equal-zero comparison ("Z" for "is Zero")
[     0<         Signed Less-than-zero comparison    (left square bracket)
]     0>         Signed Greater-than-zero comparison (right square bracket)
^E    C>S        sign Extend byte to word (doesn't display on Hyperterminal)
?     ?DUP       Duplicate if not zero

Binary arithmetic and logic operators
Wunth Forth      Description           (Notes)
---------------------------------------------------------------------------
*     *          Multiply (signed)
/     /          Divide (signed)
^X    UMStar     Unsigned 16x16=32 bit multiply (up arrow)
^_    UMSlashMOD Unsigned 32/16=16 bit divide   (down-pointing filled triangle)
+     +          Add
-     -          Subtract
Y     MAX        Signed maximum
;G     MIN        Signed minimum
(     LSHIFT     Logical shift left n places    (left paren)
)     RSHIFT     Logical shift right n places   (right paren)
&     AND        Bitwise AND           (also works as logical AND)
|     OR         Bitwise OR            (also works as logical OR)
^     XOR        Bitwise XOR
=     =          Equals comparison
N     <>         Not-equals comparison
<     <          Signed less-than comparison
>     >          Signed greater-than comparison
{     U<         Unsigned less-than comparison    (left curly brace)
}     U>         Unsigned greater-than comparison (right curly brace)
W     WITHIN     Range comparison

Stack manipulation operators
Wunth Forth      Description               Appearance in Terminal font
                 ( Data stack before -- after )( R: Return stack before -- after )
                 (top-of-stack to the right)
---------------------------------------------------------------------------
^Y    DROP       ( n1 -- )                Down arrow
^Z    DUP        ( n1 -- n1 n1 )          Right arrow
^R    SWAP       ( n2 n1 -- n1 n2 )       Up-down arrow
^O    OVER       ( n2 n1 -- n2 n1 n2 )    Sun (small circle with "rays")
^P    ROT        ( n3 n2 n1 -- n2 n1 n3 ) Right-pointing filled triangle
^Q    -ROT       ( n3 n2 n1 -- n1 n3 n2 ) Left-pointing filled triangle
P     NIP        ( n2 n1 -- n1 )
U     TUCK       ( n2 n1 -- n1 n2 n1 )
^N    2DUP       ( n2 n1 -- n2 n1 n2 n1 ) Two musical notes
S     2SWAP      ( n4 n3 n2 n1 -- n2 n1 n4 n3 )
O     >R         ( n1 -- )( R: -- n1 )
R     R>         ( -- n1 )( R: n1 -- )
^V    R@         ( -- n1 )( R: n1 -- n1 )  Low filled rectangle

Memory operators (The address argument is always top-of-stack)
Wunth Forth      Description                Appearance in Terminal font
---------------------------------------------------------------------------
@     @          Fetch word
!     !          Store word
#     C@         Fetch byte
$     C!         Store byte
^M    FlashC!    Flash-write the byte to the given address
^S    +!         Fetch word, add and store  Double exclamation mark
^T    C+!        Fetch byte, add and store  Pilcrow sign
^K    CBITCLR    Fetch byte, AND with inverted and store
^L    CBITSET    Fetch byte, OR and store
^G    CBIT!      Set or clear a bit depending on flag

Uppercase alphabetic operators
Wunth Forth      Description
---------------------------------------------------------------------------
A-F   Hex literals
;C     CMOVE      Byte block move (NOT implemented yet)
;D     DEPTH      Depth of data stack in words
;G     MIN        Minimum, arithmetic operator, see above
H     HERE       Address of next available flash location
I     I          Innermost DO .. LOOP counter
J     J          Second DO .. LOOP counter
K     ?KEY       Get a byte from serial input if available ( -- 0 | char -1 )
L     2*         Arithmetic (or logical) shift left one place (was \)
M     EMIT       Send a byte to serial output
;M     MOVE       Word block move
N     <>         Not-equals comparison, arithmetic operator, see above
O     >R         Stack manipulation, see above
P     NIP        Stack manipulation, see above
Q     ABORT      Clear both stacks and restart the outer interpreter (QUIT)
R     R>         Stack manipulation, see above
S     2SWAP      Stack manipulation, see above
T     TYPE       Send a string to serial output
U     TUCK       Stack manipulation, see above
V     EVALUATE   Interpret a string (of bytecodes)
W     WITHIN     Range comparison, arithmetic operator, see above
X     EXECUTE    Interpret the single bytecode on the top-of-stack
Y     MAX        Maximum, arithmetic operator, see above
Z     0=  NOT    Equals-zero comparison or Logical negation, see above

Miscellaneous others
Wunth Forth      Description                Appearance in Terminal font
---------------------------------------------------------------------------
space Space      Literal separator no-op (like ENTER key on RPN calculator)
return Return    End of bytecode packet  (carriage return)
\     EXIT   \   Return from a bytecode routine.   Comment to end of line.
.     .          Print a signed number                   (period)
^H    MS1        Delay for 1 byte transmit time (about 1.04 ms)
^U    DORun      Runtime word for start of DO...LOOP or DO...+LOOP
DEL   ?DOJump    Runtime word for start of ?DO...LOOP or ?DO...+LOOP
^[    LOOPJump   Runtime word for end of DO .. LOOP or ?DO .. LOOP
^J    +LOOPJump  Runtime word for end of DO .. +LOOP or ?DO .. +LOOP
^I    FORRun     Runtime word for start of FOR...NEXT loop
^G    NEXTJump   Runtime word for end of FOR...NEXT loop
^W    UNLOOP     Prepare for unstructured exit from counted loop (DO, ?DO, FOR)
"     doS" [S"]  Runtime word for start of string literal
^\    0Jump      Runtime word for conditional jump   (inverted not sign "L")
^]    Jump       Runtime word for unconditional jump (left-right arrow)
:     :          Begin a bytecode definition (define TOS bytecode)
,     COMPILE,   Compile the bytecode on top-of-stack to next flash location
;     ;          End a bytecode definition (compile an EXIT)

BMU operations
------------------------------------------------------------------------------
a     Low level voltage measurement (channel -- result)
b     aUtonomous (masterless) operation; cell 0 sends ticK commands
c     caliBrate link voltage; has to be done on cell top
d     autonomous Discharge or custom bypass voltage
e     Turn on/off error LED
g     Turn alarm on/off (think ^g)
h     Turn on/off hex mode (0 = decimal)
i     Ident setup
k     Regular check (tick) for badness
l     Link voltage
n     Emit n2 with n1 decimal places (n2 n1 --)
p     Pretty print tos as a comment packet
r     Reset badness timer
t     Temperature measurement
v     Cell voltage measurement
;w     Clear watchdog timer
y     Turn bypass resistors on/off
z     Sleep n millisconds


In ASCII order
Wunth  Forth      Description           (Notes)
                  ( Data stack before -- after )( R: Return stack before -- after )
                  top-of-stack to the right
---------------------------------------------------------------------------
^@ NUL
		  Outer interpreter: Initialise interpreter
^A SOH
		  Outer interpreter: Ignore as BSL password byte
^B STX
		  Outer interpreter: Ignore as BSL password byte
^C ETX ALIGNED    Next even number      (heart symbol)
^D EOT
		  Outer interpreter: Ignore as BSL password byte
^E ENQ C>S        sign Extend byte to word (doesn't display on Hyperterminal)

^F ACK ABS        Absolute value        (spade symbol)
^G BEL CBIT!      Set or clear a bit depending on flag
;^G BEL NEXTJump   Runtime word for end of FOR...NEXT loop
^H BS  MS1        Delay for 1 byte transmit time (about 1.04 ms)
		  Outer interpreter: Backspace edit
^I TAB FORRun     Runtime word for start of FOR...NEXT loop
^J LF  +LOOPJump  Runtime word for end of DO .. +LOOP or ?DO .. +LOOP
^K VT  CBITCLR    Fetch byte, AND with inverted and store
^L FF  CBITSET    Fetch byte, OR and store
^M CR  FlashC!    Flash-write the byte to the given address
		  Outer interpreter: End of bytecode packet
^N SO  2DUP       ( n2 n1 -- n2 n1 n2 n1 ) Two musical notes
^O SI  OVER       ( n2 n1 -- n2 n1 n2 )    Sun (small circle with "rays")
^P DLE ROT        ( n3 n2 n1 -- n2 n1 n3 ) Right-pointing filled triangle
^Q DC1 -ROT       ( n3 n2 n1 -- n1 n3 n2 ) Left-pointing filled triangle
^R DC2 SWAP       ( n2 n1 -- n1 n2 )       Up-down arrow
^S DC3 +!         Fetch word, add and store  Double exclamation mark
^T DC4 C+!        Fetch byte, add and store  Pilcrow sign
^U NAK DORun      Runtime word for start of DO...LOOP (section sign "S")
^V SYN R@         ( -- n1 )( R: n1 -- n1 )  Low filled rectangle
^W ETB UNLOOP     Prepare for EXIT from counted loop (DO, ?DO, FOR)
^X CAN UMStar     Unsigned 16x16=32 bit multiply (up arrow)
^Y EM  DROP       ( n1 -- )                Down arrow
^Z SUB DUP        ( n1 -- n1 n1 )          Right arrow
^[ ESC LOOPJump   Runtime word for end of DO .. LOOP or ?DO .. LOOP
^\ FS  0Jump      Runtime word for conditional jump   (inverted not sign "L")
^] GS  Jump       Runtime word for unconditional jump (left-right arrow)
^^ RS  1+         Increment                      (up-pointing filled triangle)
^_ US  UMSlashMOD Unsigned 32/16=16 bit divide   (down-pointing filled triangle)
space  space      Literal separator no-op (like ENTER key on RPN calculator)
!      !          Store word
"      doS" [S"]  Runtime word for start of string literal
#      C@         Fetch byte
$      C!         Store byte
%      2/         Arithmetic shift right one place
&      AND        Bitwise AND           (also works as logical AND)
'      CLIT       Character literal in following byte
(      LSHIFT     Logical shift left n places    (left paren)
)      RSHIFT     Logical shift right n places   (right paren)
*      *          Multiply (signed)
+      +          Add
,      COMPILE,   Compile the bytecode on top-of-stack to next flash location
-      -          Subtract
.      .          Print a signed number
/      /          Divide (signed)
0..9   Decimal and hex literals
:      :          Begin a bytecode definition (define TOS bytecode)
;      ;          End a bytecode definition (compile an EXIT)
<      <          Signed less-than comparison
=      =          Equals comparison
>      >          Signed greater-than comparison
?      ?DUP       Duplicate if not zero
@      @          Fetch word
A..F   Hex literals
;C      CMOVE      Byte block move (NOT implemented yet)
;D      DEPTH      Depth of data stack in words
;F      RET        Return from a bytecode routine called from machine code
G      MIN        Signed minimum
H      HEX        ( flag -- ) Turn on/off hex mode (0 = decimal)
;H      HERE       Address of next available flash location
I      I          Innermost DO .. LOOP counter
J      J          Second DO .. LOOP counter
K      ?KEY       Get a byte from serial input if available ( -- 0 | char -1 )
L      2*         Arithmetic (or logical) shift left one place (was \)
M      EMIT       Send a byte to serial output
;M      MOVE       Word block move
N      <>         Not-equals comparison
O      >R         ( n1 -- )( R: -- n1 )
P      NIP        ( n2 n1 -- n1 )
Q      ABORT      Clear both stacks and restart the outer interpreter (QUIT)
R      R>         ( -- n1 )( R: n1 -- )
S      2SWAP      ( n4 n3 n2 n1 -- n2 n1 n4 n3 )
T      TYPE       Send a string to serial output
U      TUCK       ( n2 n1 -- n1 n2 n1 )
V      EVALUATE   Interpret a string (of bytecodes)
W      WITHIN     Range comparison
X      EXECUTE    Interpret the single bytecode on the top-of-stack
Y      MAX        Signed maximum
Z      0=  NOT    Logical negation      ("N" rotated 90^ for "NOT")
                  Equal-zero comparison ("Z" for "is Zero")
[      0<         Signed Less-than-zero comparison
\      EXIT   \   Return from a bytecode routine.   Comment to end of line.
]      0>         Signed Greater-than-zero comparison (right square bracket)
^      XOR        Bitwise XOR
_      NEGATE     Unary minus           (underscore)
`      1-         Decrement             (grave or backquote)
a      Low level voltage measurement (channel -- result)
b      aUtonomous (masterless) operation; cell 0 sends ticK commands
c      Link voltage offset caliBration
d      autonomous Discharge or custom bypass voltage
e
f
g      Turn alarm on/off (think ^g)
h
i      Ident setup
j      (temporarily) Hello World (test of string output)
k      Regular check (tick) for badness
l      Turn on/off error LED
m      EMit n2 with n1 decimal places (n2 n1 --)
n      liNk voltage
o
p      Pretty print tos as a comment packet
q      is serial input Quiet?
r      Reset badness timer
s
t      Temperature measurement
u
v      Cell Voltage measurement
;w      Clear Watchdog timer
x
y      Turn bypass resistors on/off
z      Sleep n millisconds
{      U<         Unsigned less-than comparison    (left curly brace)
|      OR         Bitwise OR            (also works as logical OR)
}      U>         Unsigned greater-than comparison (right curly brace)
~      INVERT     Bitwise negation      (tilde)
^? DEL ?DOJump    Runtime word for start of ?DO .. LOOP


More info on specific Forth words can be found at:
http://www.taygeta.com/forth/dpansf.htm

All lowercase letters are application-specific bytecodes.

-- Dave (Weber) Keenan
