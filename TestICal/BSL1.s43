; ----------------------------------------------------------------------------
; The first bootstrap loader (BSL1)
;
; This file is included by TestICal.s43.
; This code will be relocated to info-flash which starts at $1000. This code is called on reset.

MClock		EQU		4000000			; MCLK (CPU clock) frequency in hertz (=DCOCLK/2)
BaudRate	EQU		9600			; Serial comms rate in bits per second
BitCycles	EQU		(MClock+BaudRate/2)/BaudRate	; CPU clock cycles per bit
BitCyc1_5	EQU		(MClock*3+BaudRate)/(BaudRate*2) ; CPU clock cycles per 1.5 bits
MckPerFTGck	EQU		(MClock+165000)/330000	; MCLK cycles per Flash Timing Generator cycle

; Port 1 bits
TXDm		EQU		1<<1			; Code requires TXDm bit somewhere to right of TXDp bit
RXD			EQU		1<<2			; Receive data on P1.2 (bit number >3 costs 2 words)
VREFp		EQU		1<<4			; Analog reference output. Sometimes changed to low digital output
TXDp		EQU		1<<5			; Prefer bit number <= 3 for code compactness (costs 2 word if not)
PIEZO		EQU		1<<0			; Piezo on P1.0
ACTLED		EQU		1<<3			; Actvity LED (blue) inverted on P1.3
; Port 2 bits
BYPASS		EQU		1<<6			; Bypass transistor on pin P2.6
ERRLED		EQU		1<<7			; Error LED (red) on P2.7

#define		Rstate	R15				// Register holding the state of the password checking FSM
#define		Rcksum	R14				// Register holding the 8-bit XOR checksum during bootstrap-loading


for1000:	; This will be relocated to info-flash at $1000.

			mov.b	#DIVM_1+DIVS_3,&BCSCTL2		; Set MCLK = DCOCLK/2, SMCLK = DCOCLK/8 (watchdog)
			mov.b	&info8MHzCalB,&BCSCTL1	; Set DCO range for 8 MHz
			mov.b	&info8MHzCalD,&DCOCTL	; Set DCO step + modulation for 8.00 MHz
			mov.b	#TXDm,&P1OUT	; Set TXDs to break state, (inverted) ACTLED on, Vref output off
			bis.b	#TXDp+TXDm+ACTLED+VREFp,&P1DIR ; Set TXDs, activity LED and VREFp as outputs
			mov		#$300,SP		; Initialise the stack pointer

			; On reset the BYPASS pin is set as a crystal oscillator pin XIN
			; and the ERRLED pin is set as a crystal oscillator pin XOUT.
			; This is safe, as the bypass MOSFET has a pulldown on its gate,
			; so the BSL can avoid consuming flash space with the following code.
;			mov.b	#0,&P2SEL 		; Set BYPASS and ERRLED to not be crystal osc pins
;			mov.b	#0,&P2OUT		; Set BYPASS and ERRLED off
;			mov.b	#$FF,&P2DIR 	; Set BYPASS and ERRLED as outputs

			; Send a 27 ms break
			mov.b	#$FF,R10		; Bit count 256 (terminates at -1)
			clr		R9				; Bit values (all zeros so it's a break)
			call	#WriteBreak-for1000+$1000 ; WriteByte without init part and w/o needing R11 clear
									; Address adjusted for BSL's relocation to info-flash

mainLoop:							; Start of the main BSL loop

			; Initialise the monitor or TestICal or other main-flash code, if allowed
			clr.b	R8				; A null to pass to interpretByte (if allowed)
									;	to initialise the main-flash code
			call	#testNoInterp-for1000+$1000	; Address adjusted for BSL's relocation to info-flash
mainInitRetAddr:	; Used by the monitor or TestICal or other main-flash code
					; to tell if the interpretByte call is for initialisation
					; and hence if the byte in R8 should be echoed

			; Password-checking finite-state-machine (FSM)
			; After decrementing Rstate below, 3 = waiting for 1st pwd char,
			; 2 = waiting for 2nd pwd char, 1 = waiting for 3rd pwd char,
			; 0 = waiting for last pwd char and erase if received,
			; any negative value = program, no interpret
			;
resetFSM:	mov		#4,Rstate		; Initialise FSM: waiting for first password character
FSMloop:	call	#ReadByte-for1000+$1000	; Address adjusted for BSL's relocation to info-flash

			dec		Rstate
			jn		progByte		; If state is negative, program, don't interpret

			; Check for a continuing password match $03 $02 $01 $00
			cmp.b	Rstate,R8		; Made expected password character equal to Rstate to save space
			jne		resetFSM
			tst		Rstate
			jnz		FSMloop

			; Erase last segment of main flash memory
			; Master will need to delay at least 16 ms before sending first byte to program.
			;
mainBSLErase:
			dint					; The main-flash program has probably turned on interrupts
									; Can't risk an interrupt while the vectors are erased
			mov.w	#WDTPW+WDTHOLD,&WDTCTL ; Stop Watchdog Timer
			mov		#FWKEY+FSSEL_1+FN0*(MckPerFTGck-1),&FCTL2 ; Divides MCLK by FN+1
			mov		#FWKEY,&FCTL3	; Clear LOCK, but keep segment A safe (no change)

			mov		#BSL2_START+2,R12	; Start of BSL2 image in main flash +2.
										; The +2 saves a 2-word compare at the end
			mov		#FWKEY+ERASE,&FCTL1 ; Enable single segment erase
			rra		@R12			; Dummy write: erase segment

			; Immediately replace reset vector to this boot loader
			mov		#FWKEY+WRT,&FCTL1 ; Enable write (can leave enabled; only write-block that can't be)
			mov		#$1000,&$FFFE	; Write reset vector to point to start of info-flash (start of BSL1)
			clr.b	Rcksum			; Initialise the checksum to 0

			; Assume a bad checksum, clear on good checksum.
			; Also prevents interpreting till the end of flash programming
			bis.b	#WDTIFG,&IFG1
			jmp		FSMloop			; Read first byte to program

			; Program (flash write) byte in R8
			;
progByte	mov.b	R8,-2(R12)		; Program it
			xor.b	R8,Rcksum		; Include in check-XOR
			inc		R12
			jnz		FSMloop			; Repeat until R12 wraps to zero

			mov		#FWKEY,&FCTL1	; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3 ; Set LOCK; don't change LOCKA
			tst.b	Rcksum			; Check the checksum
			jnz		resetFSM		; If bad checksum, leave the no interpret flag set

			mov.b	#RSTIFG,&IFG1	; Good checksum, reset no interpret flag,
									;	set RST so BSL2 will call interpretByte
			jmp		mainLoop		; Back to looking for password
									; but first make init call to BSL2

			; end FSM code

; ReadByte ( regs: -- R8 R9 R10 R11 )
; Reads a byte from serial input to R8. Trashes R9 R10 R11.
; Also echoes the byte to serial output (either by falling through to WriteByte, or calling
;	interpretByte)
;
ReadByte:
; We used to hold the watchdog timer here, and enable but clear the watchdog after the start bit was
; detected; this sped up the start bit detection by 5 cycles (11 now). This is the best way to
; do it, but we just don't have the space. Now that we run at 4 MHz, the extra overhead is only 1.2% of
; a bit time.
waitStartR							; (Number of cycles)
			; The loop below takes 11 cycles so on average we will have missed the start bit by 5.5,
									; call it (6) cycles
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear and enable Watchdog Timer
			bit.b	#RXD,&P1IN		; (4) Start bit?
			jnz		waitStartR		; (2) Loop while not 0 (start bit)

			; Pad out the average delay between starting edge of start bit
			; and sampling of first bit below to ~ 1.5 bittimes
			mov.b	#(BitCyc1_5-15+1)/3,R11 ; (2) Loop count for waitMid delay loop
waitMid		dec		R11				; (1) Delay loop
			jnz		waitMid			; (2) Note: Clearing R11 here may be assumed in WriteByte below

			mov		#8,R10			; (1) Bit count
RX_Bit		bit.b	#RXD,&P1IN		; (4) Sampled bit to carry
			rrc.b	R8				; (1) Store received bit

			mov.b	#(BitCycles-10+1)/3,R11 ; (2) Pad RX_bit loop out to one bit time
waitNextR	dec		R11				; (1) Delay loop
			jnz		waitNextR		; (2) Note: Clearing R11 here is assumed in WriteByte below
			dec		R10				; (1) All bits RXed?
			jnz		RX_Bit			; (2) Sample next bit

			; Normally there would be a 1 bit delay here so we return in the middle of the stop bit, so
			; calling ReadByte soon after returning doesn't mistake a zero in the MSB as a start bit.
			; But it's not needed, since we always send something before waiting for the next byte

testNoInterp:
			cmp.b	#8,&$FFFC ; &BSL2presence	; Test for presence of BSL2.
			jnz		WriteByte		; Jump around call, if non-zero
			; We are about to jump to interpretByte. In case the flash is corrupted by a
			; partial download, set the watchdog timer to the shortest interval, 64 cycles
			; InterpretByte should set it back to the longest interval, 32k cycles
			mov.w	#WDTPW+WDTCNTCL+WDTIS0+WDTIS1,&WDTCTL ; Clear and enable Watchdog Timer
			br		#BSL2_START		; tail-call BSL2 in last segment of main flash
									; It must preserve at least R8 and Rstate(=R15)
			; ret					; Effective ret due to tail-call above

; WriteByte ( R8 R11 -- R9 R10 R11 )
; Write the low byte of R8 to serial output. R11 must be clear on entry.
; Trashes R9 R10 R11. Preserves R8.
;
; WriteBreak ( R9 R10 -- R9 R10 R11 ) (an alternative entry point into WriteByte)
; Send a 27 ms break on the serial output. R9 must be zero and R10 must be $FF.
; Trashes R9 R10 R11.

WriteByte:
			mov		R8,R9			; Allow R8 to be preserved for password compare

			mov.b	#8,R10			; Loop counter, 1 start + 8 data (decrements to -1)
			rla		R9				; Add the start bit
			; Stop bit was bis#1<<9,R9, but it's done after the loop now
			; to allow sending a break

write_next							; (Number of cycles)
			rra		R9				; (1) Next bit to C.
			subc.b	#TXDp,R11		; (1) Bits 11(1)000(0)0 if C; 11(0)111(1)1 if NC
									; Note: R11 must be guaranteed clear in advance
			xor.b	&P1OUT,R11		; (3) Determine if TXD bits need toggling
			; The activity LED has a lower bit number than TXDp so the below will
			; turn off the (inverted) activity LED when a zero bit or start bit is sent,
			; and turn it on when a one bit or stop bit is sent.
			and.b	#TXDp+ACTLED+TXDm,R11 ; (2) Ensure only TXD and ACTLED bits can be toggled below
			xor.b	R11,&P1OUT		; (4) Toggle as needed, to send bit

WriteBreak:	mov.b	#(BitCycles-16+1)/3,R11 ; (2) Set the delay counter to pad out to one bit time
write_dly	dec		R11				; (1) Note: Clearing of R11 here is assumed by write_next above
			jnz		write_dly		; (2)

			dec		R10				; (1) Decrement the bit counter
			jc		write_next		; (2) Loop if not -1

			mov.b	#TXDp,&P1OUT	; Send a stop bit and leave the (inverted) ACTLED on
			; Harmless side-effect of turning off the Vref+ pin if it is still a digital output
			; To ensure the stop bit has sufficient duration we rely in the fact that
			; calls to WriteByte must be at least 2 byte-times apart
			; to allow any receiving BMU's BSL time to both read and echo the byte.
			ret

			; Any free info-flash space is between here and mainDataStart
freeSpaceBSL	EQU		$F8 - ($-for1000)		; Number of bytes spare in the BSL

			ORG		for1000+$F8
			; Calibration data
mainDataStart						; Used when copying between ram and info-flash
mainVoltCal		ds		2			; Voltage scale calibration word; may be written by BSL writer
mainTempCal		ds		1			; Temperature offset calibration; may be written by BSL writer
mainLinkCal		ds		1			; Link voltage offset calibration data; may be written by BSL writer
main8MHzCalD	ds		1			; 8 MHz DCO frequency calibration byte (same address as in new chip)
main8MHzCalB	ds		1			; 8 MHz DCO range calibration byte (same address as in new chip)
mainID			ds		1			; Cell/BMU identifier byte; first cell is 1; written by 'i' cmd
; Note that xxxDataEnd is one PAST the last calibration byte, i.e. the address of the start of what
;	comes after the calibration bytes
mainDataEnd							; Used when copying between ram and info-flash
mainDataVers db		DATAVERS		; Data Version byte (cannot move)

; The end of the bootstrap loader (BSL)
; -----------------------------------------------------------------------------

