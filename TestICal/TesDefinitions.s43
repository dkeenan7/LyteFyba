;
; Command character definitions for TestICal
;

#include "../common/comDefinitions.s43"			; Include the definitions common to monitor
												; and TestICal

;
; ADCScaled or R(a)wVoltage ( channel -- measurement )
; "channel" has channel number shifted left 12 bits.
; e.g. $7000 for cell voltage, $A000 for temperature, $3000 for link voltage.
; "measurement" is 12-bit (0 to 4095) with voltage scale calibration applied,
; which corresponds to millivolts in the case of cell voltage.
;
		xCODE		'a',ADCScaled,_ADCScaled
		mov			Rtos,R8
		call		#measAndScale			; Measure and use voltage scale calibration
		mov			R10,Rtos
		ret

; Some characters need to be translated into RAM adresses of calibration values
		ALIGN	1
calAddressTable
		DB		'v' , ramVoltCal  & $7F	| $80	; High bit set to indicate word quantity,
		DB		't' , ramTempCal  & $7F | $00	; clear for byte quantity
		DB		'l' , ramLinkCal  & $7F | $00
		DB		'f' , ram8MHzCalD & $7F	| $80
		DB		'i' , ramID       & $7F | $00
; Zero must not appear in the table as it is used to represent "unrecognised".
sizeCalAddressTable	EQU	$-calAddressTable

;
; TranslateToCalAddr ( ch -- addr )
;
TranslateToCalAddr:
		; Do the calibration address translations using the table above
		mov		#sizeCalAddressTable,R9 ; Initialise the loop counter and table index
		_BEGIN				; Begin loop
			mov.w	calAddressTable-2(R9),R10 ; Get two bytes from the table
			cmp.b	R10,Rtos	; Compare the address character with the low byte from the table
			_WHILE	_NE			; While no match [ _WHILE xx = _IF xx  _CS_SWAP ]
				decd	R9			; Decrement loop-counter/table-index by 2
		_UNTIL	_Z			; Until loop counter is zero
		clr		Rtos		; Finished loop with no match so set result to zero for "unrecognised"
			_ELSE				; Else there is a match so
				swpb	R10			; Get the high byte from the table
				mov.b	R10,Rtos	; Substitute it for the address character
			_ENDIF				; Endif match
		ret

;
; Calibrate ( n ch --- )
; Perform a calibration whose type is ch ('v for voltage etc) and value is n
;
			xCODE	'c',calibrate,_calibrate
			_CASE
			_OFb	#'v',Rtos			; 'v': cell Voltage
				mov		#CellVChan<<12,R8		; ADC channel for scaled cell voltage input
				call	#measure
; The calibration scale factor will be the expected value divided by the reading.
; The expected value is an unsigned 12 bit integer of millivolts and
; the reading is an unsigned 12.2 bit fixed-point number of millivolts.
; We want the calibration scale factor to be represented as an unsigned 1.15 fixed-point number
; i.e. a number with 1 integer bit and 15 fractional bits.
; So we shift the expected value 17 places left before the division.
				clr		R9							; 16 bits of zeroes
				mov		Rsec,R10
				rla		R10							; 17 zeroes; we have value << 17 in R10:R9
				mov		R8,R11						; The divisor is the voltage reading in R8
				rra		R11							; Add half the divisor to the dividend for rounding
				add		R11,R9
				adc		R10
				call	#UMSlashMod					; Gives quotient in R9, remainder in R10
				mov.w	R9,&ramVoltCal				; Save calibration value
			_ENDOF

			_OFb	#'t',Rtos			; 't': temperature
;
; Temperature offset calibration
; M = 4096/1.5 * (.00355 T + typ0.986)
;	= 9.694*T + typ2692
; M/9.694	= T + typ277.7
; Per the MSP430F2012 datasheet, typ277.7 aims at 273, so the reading is proportional
; to the absolute temperature, with an offset of +- 100 mV.
			; We use offsetByte = (M/9.694 - T) >> 1
; So we use offsetByte = (M/9.694 - T) - 273
; and T = M/9.694 - 273 - offsetByte
;
				mov		#TempChan<<12,R8			; ADC channel for temperature sensor
				call	#measAndScale

; To divide by 9.694, multiply by 65536/9.694 = 6760
				mov		R10,R8
				mov		#6760,R9
				call	#UMStar
				sub		#273,R10
				sub		Rsec,R10					; Subtract 273 and the calibration temperature
				mov.b	R10,&ramTempCal				; Save temperature offset calibration value
			_ENDOF

			_OFb		#'l',Rtos				; 'l': link voltage
				mov		#LinkVChan<<12,R8
				call	#measAndScale
				sub		#2048,R10					; Zero volts for link voltage is a 2048 reading
				;sub		Rsec,R10				; Subtract required reading (usually 0)
				; Actually require 1.3653*Rsec to be subtracted. Too much code. So `lc will always
				;	calibrate to zero millivolts (calibrate with no significant charge or discharge).
				cmp		#$FF81,R10					; -$7F
				jl		nonCal						; If <s -$7F, use the $80 non-calibrated value
				cmp		#$80,R10
				jl		realCal						; If >s -$7F and <s $80, use as real calibration value
nonCal			mov		#$80,R10
realCal
				mov.b	R10,&ramLinkCal				; Save the link calibration value
			_ENDOF
;
; Default case
				jmp		emitQmark					; Unknown calibration type character

			_ENDCASE

			;jmp		_readCalValue			; Display the value just calibrated and return
												;	(by falling through)
			;
			; Keep 'c' command (above) and 'r' command (below) together
			; That is, don't insert a new command here
			;
;
; Read calibration value ( ch --- )
; Calibration type (e.g. 'v' for cell Voltage) in ch
			xCODE	'r',readCalValue,_readCalValue ; Note: 'r' prints Rx state in monitor
			call 	#TranslateToCalAddr
			mov.b	Rtos,Rsec				; Convert to RAM address in Rsec
			bic.b	#$80,Rsec
			bis		#$200,Rsec
			tst.b	Rtos
			_IF		_NZ						; If not zero (zero means "unrecognised")
				_IF		_NN						; If high bit set
					mov		#3,Rtos					; Display 3 digits
					mov.b	@Rsec,Rsec				; Get byte sized cal value
				_ELSE							; Else high bit clear so
					mov		#5,Rtos					; Display 5 digits
					mov.w	@Rsec,Rsec				; Get word sized cal value
				_ENDIF							; Endif high bit
			_ELSE 							; Else is zero for "unrecognised"
emitQmark:		mov		#'?',Rtos				; Question mark should be ignored by downstream CMUs
				call	#_EMIT					; Call EMIT
				mov		#$0D,Rtos				; Carriage return
				jmp		_EMIT					; Tail-call EMIT and return
			_ENDIF							; Endif unrecognised
			mov.b		#' ',Rthd			; Trailing char (space)
			br	 	#_prettyPrint			; Tail-call prettyPrint and return

;
; Write calibration value ( n ch --- )
;
; n is value to write. ch is calibration type (e.g. 'v for cell Voltage).
;
; Note: The 'fw command can affect the CPU clock in such a way that the processor
; is no longer capable of receiving commands, and needs physical access to recover.
; So take great care. If the worst happens, use a JTAG programmer to load a version of TestICal
; having an INIT_CMD_STRING that sets a typical frequency calibration value, such as '$AD90\'fw'.

			xCODE	'w',writeCalValue,_writeCalValue
			call 	#TranslateToCalAddr
			mov.b	Rtos,R9					; Convert to RAM address in R9
			bic.b	#$80,R9
			bis		#$200,R9
			tst.b	Rtos
			_IF		_NZ						; If not zero for "unrecognised"
				_IF		_NN						; If high bit set
					mov.b	Rsec,0(R9)				; Set byte sized cal value
				_ELSE							; Else high bit clear so
					mov.w	Rsec,0(R9)				; Set word sized cal value
				_ENDIF							; Endif high bit
				cmp	#ram8MHzCalD,R9
				_IF		_EQ
					mov.b	@R9+,&DCOCTL
					mov.b	@R9,&BCSCTL1
				_ENDIF
			_ELSE 							; Else is zero for "unrecognised"
				jmp		emitQmark
			_ENDIF							; Endif unrecognised
			ret


;
; setIDs ( first-ID -- )
;
			xCODE	'i',setIDs,_setIDs
			; When preceded by XOFF (ctrl-S) and the desired first ID in decimal,
			; and followed by <cr> XON (ctrl-Q), it sets consecutive IDs in consecutive CMUs
			; and responds with the ID _after_ the last ID.
			bit.b	#bDontEcho,&interpFlags
			_IF		_NZ					; If the dont-echo flag is set
				; Save our new ID to RAM
				mov.b	Rtos,&ramID

				; Send another setIDs command with its parameter incremented by one.
				inc		Rtos				; Increment the parameter
				DPUSH	#3					; Use a 3 digit field width
				call	#_emitNum			; Transmit the number as text in the current number base

				mov		#'i',R8				; Transmit an "i"
				call	#TxByteCk
				call	#TxEndOfPacket
			_ELSE						; Else dont-echo flag is clear
				; Send '?' to remind user that Ctrl-S needs to be sent before an 'i' command.
				mov		#'?',R8				; Transmit a question mark (a no-op to downstream CMUs)
				call	#TxByte
				mov		#'\r',R8			; Transmit a carriage return. Checksum is deliberately bad.
				call	#TxByte
			_ENDIF
			ret

;
; Update info-flash ( -- )
;
			xCODE	'u',updateInfoFlash,_updateInfoFlash
; Prepare to flash-program
; Assumes ACCVIE = NMIIE = OFIE = 0.
; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz
			mov		#FWKEY+FSSEL_1+FN0*(12-1),&FCTL2 ; For 4 MHz MCLK
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Hold Watchdog Timer

; Erase appropriate info flash segment.
			mov		#FWKEY,&FCTL3			; Clear LOCK
			mov		#FWKEY+ERASE,&FCTL1		; Enable single segment erase
			mov		#0,&infoDataStart		; Dummy write: Start of cal data in info-flash

			mov		#FWKEY+WRT,&FCTL1		; Enable write (can leave on; only write block that can't)

			clr		R12						; Loop counter
			_BEGIN
				mov.b	ramDataStart(R12),infoDataStart(R12)	; Write a byte to info-flash
				inc		R12
				cmp		#ramDataEnd-ramDataStart,R12
			_UNTIL	_EQ						; Loop until ramDataEnd

			mov		#FWKEY,&FCTL1			; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3		; Set LOCK
			;
			; Check that the flash programming worked
			;
			call	#compareInfoFlash		; Compare RAM cal data with what's in infoflash
			_IF    _NE
				mov		#b'01010000,rERR		; 2 flashes
				call	#ErrorFlash				; Infinite loop, never returns
			_ENDIF
			ret

;
; update Bootstrap loader ( -- )
;
			xCODE	'b',updateBSL2,_updateBSL2
			push	SR
			dint
; Prepare to flash-program
; Assumes ACCVIE = NMIIE = OFIE = 0.
; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz
			mov		#FWKEY+FSSEL_1+FN0*(12-1),&FCTL2 ; For 4 MHz MCLK
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Hold the Watchdog Timer

			; Erase last segment of main flash (usually contains BSL2).
			mov		#jBSL,R12				; Start of BSL2 image, $FE00 or $FC00 or ...
			mov		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			_BEGIN
				mov		#FWKEY+ERASE,&FCTL1		; Enable single segment erase
				rra		@R12					; Dummy write: erase segment
				add		#512,R12				; Next block
			_UNTIL	_NN

			mov		#FWKEY+WRT,&FCTL1		; Enable write (can leave on; only write block that can't)
			mov		#jBSL,R12				; Start of BSL2 image
			_BEGIN
				mov		jBSLb-jBSL(R12),0(R12)		; Program word
				incd	R12
			_UNTIL	_NN						; Will wrap to 0 after writing last word

			mov		#FWKEY,&FCTL1			; Done. Clear WRT
			mov		#FWKEY+LOCK,&FCTL3 		; Set LOCK
			;
			; Check that the flash programming worked
			;
			call	#compareBSL2			; Compare the payload copy with what's at $FE00
			jnz		failCompareB

			ClearWatchdog					; Clear and restart Watchdog Timer
			pop		SR
			ret

failCompareB mov	#b'01010100,rERR		; 3 flashes
			br		#ErrorFlash


;
; PeeQWord - get a word (NOT to stack) and display it ( addr -- )
;
			xCODE	'q',PeeQWord,_PeeQWord
			mov.b	#' ',Rthd
			mov.w	@Rtos,Rsec
			mov		#5,Rtos
			br		#_prettyPrint

;
; stOreWord - store a word (a la Store) ( n addr -- )
;
			xCODE	'O',stOreWord,_stOreWord
			mov.w	Rsec,0(Rtos)
			ret

;
; Change Octave of piezo alarm.
;
			xCODE	'o',octave,_octave
			mov.b	&ram8MHzCalD+1,R8
			mov.b	R8,R9
			bic		#$30,R9					; Clear the octave bits (bits 5 and 4)
			add		#$10,R8					; Next octave
			and		#$30,R8					; Just the octave bits
			bis		R8,R9					; New value in R9
			mov.b	R9,&ram8MHzCalD+1		; Update RAM
			mov.b	R9,&BCSCTL1				; Make it "live"
			ret

;
; JumpTo - Call the code at addr ( addr -- )
;
			xCODE	'j',JumpTo,_JumpTo
			mov		Rtos,R8		; Save the jump address in a trashable non-stack reg
			DROP				; Drop stack in case the code at addr uses stack arguments
			br		R8			; Tail-call the code at addr and return


;
; f command ( -- )
; This outputs a fixed frequency to TxPl for 5 seconds.
; Used for checking clock calibration.
; NOTE: this command can only be used (in conjunction with `fw) to make small adjustments to
;	CPU speed, since communications will be affected!

			xCODE	'f',frequencyBurst,_frequencyBurst
			bic.b	#TxPl,&P1SEL			; Change from UART function to general IO
			bic.b	#TxPl,&P1SEL2			; Both SEL bits must be cleared
			bis.b	#TxPl,&P1DIR			; Set as output in case it isn't already
			mov		#28,R11					; To give 5 seconds with 4 Mhz MCLK
											; Must be even so things toggle back to what they were
			call	#doBurst
			bis.b	#TxPl,&P1SEL			; Back to UART function
			bis.b	#TxPl,&P1SEL2			; No need to change P1DIR
			ret

;
; EMIT ( c -- )	; Emit the character on top of stack
;
		xCODE	'm',EMIT,_EMIT
		mov.b	Rtos,R8
		call	#TxByte
;		pop		Rtos
;		DROP
		ret


;
; Toggle TxPl with a 10 cycle loop,
; This timing depends on TxPl or TxMi being in the low 4 bits of its output register.
; If we were trying to achieve an exact 4 MHz MCLK, we'd want 4000/2/10 = 200.0 kHz.
; If we were trying to achieve exact 9600 baud comms we'd want 9600*416/2/10 = 199.7 kHz.
; But we've gone with minimising the number of controllers whose default DCO calibration
; we need to change. For that we have settled on the acceptable range being
; 199.5 to 200.5 kHz at 20 degC and
; 200.5 to 201.5 kHz at 30 degC.
; When changing the cal value with e.g. $8D80'fw, a change of one lsbit changes the
; output frequency by about 0.5 kHz in the same direction.

doBurst
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Hold the Watchdog Timer
			push	SR						; Interrupts like the
			dint							;	FFL will spoil results
			clr		R10
burstLp		xor.b	#TxPl,&P1OUT 			; (4) Toggle the TxPl bit. Must give 10 cycle loop.
			; We used to toggle both Tx lines in phase but this caused problems with IFO outputs.
			; Leaving one of them as a high output caused problems due to C4 (100n) on the next board.
			; We used to toggle TxMi, but the BMU has it on P3.7.
			; We rely on an even number of toggles to restore TxPl.
			dec		R10						; (1)
			jnz		jBurstLp				; (2) Jump to a 3-cycle delay to burstLp
			dec		R11						;	(alt1 1)
			jnz		burstLp					;	(alt1 2)
			pop		SR
			ClearWatchdog					; Clear and restart Watchdog Timer

			ret
jBurstLp	br		#burstLp				;	(alt2 3)


;
; send Nulls ( n -- )	; n is the number of nulls to send without a gap
;			Only low byte of n is used. Max of 256 nulls when n is zero.
;			This is to test for false positives on the break-to-reset circuitry of the following CMU.
;
			xCODE	'z',sendNulls,_sendNulls ; 'z' for send Zeros
			mov		#100,R11					; Ensure a proper stop bit
bitDelay	dec		R11
			jnz		bitDelay				; Also clears R11 which is required by BSL WriteByte to save space

			mov.b	#$00,R8					; Null to be sent
			call	#jWriteByte				; Send the null

			ClearWatchdog

			dec.b 	Rtos					; Do it n times, max 256 when n is zero
			jnz		_sendNulls
			ret


;
; Measure Vcc ( M -- )	; Emit the Vcc voltage
;
		xCODE	'M',MeasVcc,_MeasVcc
		mov		#0xB<<12,R8				; FIXME: I need a pretty definition
		call	#measAndScale			; Gives us 0-4092 for 0-1.25
		mov			#'M',Rthd			; Type is Vcc Measurement
		mov			R10,Rsec			; Result in millivolts
		mov			#4,Rtos				; Print 4 digits
		br			#_prettyPrint		; Tail-call pretty-print and return


; Turn off echoing of command characters. Used with the ID setting command when used in an INITCMDSTRING.
		xCODE	'[',ExOff,_ExOff
		bit.b	#bDontInterpret,&interpFlags
		_IF		_Z				; If the dont-interpret flag is clear
			bis.b	#bDontEcho,&interpFlags ; Set the don't-echo flag
		_ENDIF
		ret

; Turn on echoing of command characters. Used with the ID setting command when used in an INITCMDSTRING.
		xCODE	']',ExOn,_ExOn
		bic.b	#bDontEcho,&interpFlags ; Clear the don't-echo flag
		ret
