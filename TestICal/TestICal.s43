			COL		154				; Wide listings
; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve calibration data.
;
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Output options to:
;  Allow C-SPY-specific extra output file
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	TestICal.bin
;	Output format: raw-binary
;
; This software has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; "TestICal" is a TESTer, Id-setter, CALibrator and bootstrap-loader updater for our cell-top
; Cell Monitoring Unit (CMU) based on an MSP430 microcontroller.
;
; TestICal should be the first program written to main-flash.
; This initial programming must be done using a flash programmer connected to the JTAG port.
;
; TestICal contains two copies of a bootstrap loader (BSL), one active, the other inactive.
; The initial JTAG programming of TestICal will place this BSL in its active position
; in the last 512 bytes of main-flash.
; From then on, programming may be done via serial communications using this BSL.
; Use the Windows program CMUsend or the Linux program sendprog to send the file
; TestICal.bin or monitor.bin.
;
; When loading TestICal via BSL, only the inactive copy of the BSL is sent with it.
; But this copy can be written to the active location, to update the BSL, by using the 'b' command.
; TestICal can also perform voltage and temperature calibrations and store this calibration data
; in info-flash using the 'u' command.
;
; The BSL consists of a software UART providing RS422-style serial communications,
; and a password-recognising state-machine. The state-machine normally passes incoming
; serial data to a command interpreter in main-flash. But when the password is recognised,
; the state-machine instead writes incoming serial data to main-flash.
; This allows it to overwrite TestICal with the normal command interpreter or monitor,
; sent via the serial input. And because the BSL transmits all data received on its serial
; input, to its serial output, a cascaded series of these MSP430 boards can all be updated
; simultaneously. You only need to send a new version of the monitor to the first board
; in the chain.
;
; But what if you want to update the BSL itself? In that case, instead of sending a new
; monitor, you send TestICal carrying the new version of the BSL.
; This time you send TestICal via the serial input not the JTAG port.
; That way a 'b' command will update the BSLs of all the boards in the chain simultaneously.
;
; The BSL code is located in the last 512 bytes of main-flash because this flash segment contains
; the reset vector and can be left alone when the rest of main-flash is erased.
;
; The following is true of both TestICal and the BSL:
;	They use no interrupts, since the interrupt vectors will be reprogrammed.
;	They use no timer; timer use requires too many 6-byte instructions.

#define REV61	1				// For CMU board rev 61 or later, and IMU and BMU. 0 for MX-5.
#define	G2553	1				// MSP430 model. False for older devices that used the MSP430G2452.

; Init Command String
; A string of commands that will be interpreted after all other initialisation is complete.
; Its most common use is to restore a sensible DCO clock frequency calibration value when this has
; been erased or corrupted, thereby rendering communications impossible or unreliable.
; In that case, it must of course be loaded using a JTAG programmer as the BSL will not work.

#define INIT_CMD_STRING ''	 			// No initial command
; #define INIT_CMD_STRING '$AD90\'fwf'	// Write a new frequency cal value then let us measure it.
									// Note that an update command 'u' is required to make it stick.

; Conditional assembly parameters which may be changed for special purposes
#include "../common/common.h"		// Definitions common to monitor, TestICal and BSL
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer
#define		INSULATION_MONITORING 1	// Can leave out the insulation monitoring code if not needed.

#if G2553
; Timer registers
PizTAR		EQU			TA0R		; Charger/inverter timer register
PizTAIV		EQU			TA0IV		; Charger/inverter timer interrupt subvector
PizCCTLp	EQU			TA0CCTL1	; Piezo 4.2 kHz square wave capture/compare control register
PizCCR0		EQU			TA0CCR0		; Capture/compare register zero on the same timer as piezo
PizCCRp		EQU			TA0CCR1		; Piezo 4.2 kHz square wave capture/compare register

; ADC channel numbers
TouchVChan	EQU		$0				; Touch (insulation test) voltage (BMU only)
VRefPChan	EQU		$4				; Vref+ out
ArrayV_BoltVPl_Chan	EQU	$5			; PV Array voltage (BMU) Bolt+ voltage (CMU)
ShuntV_BoltVMi_Chan	EQU	$6			; Current shunt voltage (BMU), Bolt- voltage (CMU)
BatV_StrapVPl_Chan 	EQU	$7			; Battery voltage (BMU), Strap+ (cell) voltage (CMU)
TempChan	EQU		$A				; Temperature
LinkVChan	EQU		ShuntV_BoltVMi_Chan	; Aliases for code that's common to newer and older devices
CellVChan	EQU		BatV_StrapVPl_Chan
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)

#else

; ADC channel numbers
TouchVChan	EQU		$3				; Touch (insulation test) voltage (IMU only)
VRefPChan	EQU		$4				; Vref+ out
LinkVChan	EQU		$6				; Link voltage
CellVChan	EQU		$7				; Cell voltage
TempChan	EQU		$A				; Temperature
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)

#endif

; To get n more bits of ADC resolution, add up 4^n samples and shift the result right by n bits.
; i.e. By adding up 4^n samples you get 2n more bits in the result,
; but half of them are noise and should be thrown away,
; leaving us with n bits of additional information.


ID				EQU		ramID			; We use the ram copy of the ID for s, x, prettyPrint
										; commands. Monitor uses the info-flash copy

; Locations in info-flash, of calibration data in previous versions of the BSL
; to allow us to update them to the current version without losing their calibration data.

infN8MHzCalD	EQU		$10FC		; Address of 8 MHz DCO frequency calibration
infN8MHzCalB	EQU		$10FD		; Address of 8 MHz DCO range calibration

; Interpreter Register Usage
;	Registers 0 thru 3 are dedicated machine registers (PC SP SR CG).
#define 	Rip		R5				// Virtual machine instruction pointer
#define 	Rlit	R6				// Holds partial literals
#define 	Rw		R8				// Working register - temporary - anyone can use

			LSTOUT-
#include "msp430.h"
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Macros for obscure instruction sequences
			LSTOUT+

; Error register. 0 means no error
#define		rERR	r14					// Overlaps with Rcksum in the BSL, but that is OK

; The LOCKA bit in FCTL3 was made a *toggle*, for backwards compatibility.
; Use these macros to safely clear and set it.
CLRLOCKA	MACRO
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			_IF		_NZ					; Currently locked?
				MOV		#FWKEY+LOCKA,&FCTL3 ; Yes, unlock
			_ENDIF
			ENDM

SETLOCKA	MACRO
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			_IF		_Z					; Currently unlocked?
				MOV		#FWKEY+LOCKA,&FCTL3 ; Yes, lock
			_ENDIF
			ENDM


				ORG		$200		; Start of RAM

BatCapacity		EQU		1800		; Battery capacity in tenths of an amp-hour

; This area is common to both Monitor and TestICal and is not erased on a reset
bsl2state		DS		2			; Password recogniser state for BSL2
resetCounter	DS		2			; Number of resets since the last "^" command
resetBuffer		DS		16			; Circular buffer recording the reason for the last 16 resets
discharge		DS		4			; Accumulator for depth of discharge determination.
									; Unit is 1/5 A for 1/15 s = 1/75 coulomb = 1/270 milliamphour.
									; So 32 bits allows 15,900 Ah, but 24 bits would only allow 62 Ah.
comNoEraseEnd

#if	ADCBUF
			ALIGNRAM 1
sampleBuf	DS		2*NumSamples	; ADC sample buffer; 4 or 16 samples
#endif

; RAM copies of various calibration settings
; Same order as stored in info-flash
			ALIGNRAM 1				; So these can be copied with word moves
ramDataStart
ramVoltCal	DS		2				; Voltage scale calibration word; may be written by BSL writer
ramTempCal	DS		1				; Temperature offset calibration; may be written by BSL writer
ramLinkCal	DS		1				; Link voltage offset calibration data; may be written by BSL writer
ram8MHzCalD DS		1				; 8 MHz DCO frequency calibration byte
ram8MHzCalB DS		1				; 8 MHz DCO range calibration byte
ramID		DS		1				; Cell/CMU identifier byte; first cell is 0; written by 'i' cmd
ramDataVers	DS		1				; Data version
ramDataEnd

; Miscellaneous variables

txCksum		DS		1				; Transmit checksum

; Command Character Interpreter variables

rxCksum		DS		1				; Received packet xor checksum
interpFlags	DS		1				; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1<<0		; Should numeric output be in hexadecimal, not decimal?
bChecksumming	EQU		1<<1		; Are we sending checksums and checking received checksums?
bDontInterpret	EQU		1<<2		; Are we interpreting?
bDontEcho		EQU		1<<3		; Are we echoing? (not yet implemented in TestICal)

ALIGNRAM 1
ToIN		DS		2				; Pointer to present character being stored in Text Input Buffer
TIB			DS		48				; Text Input Buffer (packet buffer)
TIBEnd
; Must leave room for stack (about 36 bytes minimum)
STACKSPACE		EQU		InitSP-$	; Look at listing to see what this is

;-------------------------------------------------------------------------------
				ORG		PROG_START	; In main-flash
;-------------------------------------------------------------------------------

			; Assemble any initialisation command string
initCmdString
			DB		INIT_CMD_STRING
			DB		EXIT					; Must end with an EXIT command
			ALIGN	1

InterpretByte:
; The BSL will call this when any bytes are received by the serial port, including "password" bytes.
; The BSL will also call this with a null that was not received by the serial port
; but is intended to initialise the monitor or TestICal or other main-flash program.
; It will do this on any normal reset (not a watchdog timeout or key violation or SFR instruction fetch)
; and after successfully bootstrap-loading a new monitor or TestICal or other main-flash program.
			ClearWatchdog					; Clear and restart Watchdog Timer

			cmp		#initRetAddr2,0(SP)
			_IF		_EQ						; If the call is merely for initialisation
				jmp		initialise				; Tail-call initialise, and return
			_ELSE
				; The following test allows us to upgrade from the old BSL2 that was called from BSL1
				; in infoFlash, to the new BSL2 that stands alone. The address from which InterpretByte
				; was called has changed, so we need to check for calls from the old location
				; and run the updateBSL command and return to the new location.
				cmp		#$FE44,0(SP)			; Is the call for initialisation from the old BSL2
				_IF		_EQ
					call	#_updateBSL2			; Update BSL2 (flash erase and copy)
					mov		#initRetAddr2,0(SP)		; Change the return address on the stack
					jmp		initialise				; Tail-call initialise, and return
				_ELSE
					call	#ACCEPT					; Process R8 as part of a command to be interpreted
					ClearWatchdog
				_ENDIF
			_ENDIF

			ret								; Return to the BSL

;-------------------------------------------------------------------------------
; Initialisation
;-------------------------------------------------------------------------------
;
; This intialises everything including the RAM calibration values, but excluding the stack pointer.
; The stack pointer is initialised before this is called.
; Called due to the initialisation call of InterpretByte from the BSL.
;
initialise:
#if !WATCHDOG
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (bad idea, except while debugging)
#endif
			; Clear all variables in RAM except resetBuffer and BMU's fuel gauge discharge accumulator
			_DO		#TIB-comNoEraseEnd,R8
				clr		comNoEraseEnd-2(R8)
			_mLOOP	#2,R8

			; Initialise the Timer to run the piezo
			; TASSEL: 1 = ACLK clock source, 2 = SMCLK (sub master clock)
			; ID: 3 = /8; 2 = /4; 1 = /2; 0 = /1
			; MC: 2 = continuous mode 1 = up mode
			mov		#TASSEL_2 + ID_0 + MC_2 + TAIE, &TA0CTL
			mov.w	#OUTMOD_4|CCIE,&PizCCTLp	; Piezo CCR in Compare mode, "toggle" output mode, interrupts

;
; Copy calibration data into RAM
;
			_CASE
			;_OFb	#DATAVERS-1,&infoDataVers
				; Copy/translate stuff from previous version to RAM
			;_ENDOF
			_OFb	#DATAVERS,&infoDataVers
				; The RAM image has the same layout as current version data, so we use a block move
				_DO		#infoDataEnd-infoDataStart,R8 ; Prepare to move ~8 bytes
					mov.b		infoDataStart-1(R8),ramDataStart-1(R8) ; Move 1 byte
				_LOOP	R8							; Decrement loop counter by 1, loop if non zero
			_ENDOF
			_OFb	#$FF,&infoDataVers
				; If we find $FF at infoDataVers (an area of info-flash that we assume will be erased
				; in new chips), then assume it's a new chip. If not a new chip, it will have the data
				; version number (way < $80).
				; A new chip. We want to preserve some of the existing DCO calibration data.
				; Set the ID, voltage, temperature and link calibration.
newChip:
				mov.w	#$8000,&ramVoltCal			; !!!FIXME. G series chip has manuf's ADC cal data
				mov.b	#$00,&ramTempCal
				mov.b	#$00,&ramLinkCal			; Want link to be active for initial test
				mov.w	&infN8MHzCalD,&ram8MHzCalD	; Copy 8 MHz calibration data
				bis.b	#DIVA_2,&ram8MHzCalD+1		; Set ACLK = VLOCLK/4 = 3 kHz
				mov.b	#$FF,&ramID					; ID 255 (erased or BMU)
				mov.b	#DATAVERS,&ramDataVers		; The current data version
			_ENDOF
			; default case
#if !G2553
				; We could have an unprogrammed non G2553 chip; in that case infoDataVers is actually
				; one of the 1 MHz frequency calibration values. We know that it will be >= $80 to
				; disable XT2
				tst.b	infoDataVers
				jn		newChip
#endif
				; Data version number is higher or lower than can be handled by this version of TestICal
				; so we should leave it alone and raise an error.
				mov		#b'01010101,rERR			; 4 flashes
				call	ErrorFlash					; Infinite loop, never returns
			_ENDCASE


#if G2553
			; Initialise port 1
			; Default settings of P1SEL are OK. No UART comms in TestICal. Analog settings done later.
			mov.b	#TxPl,&P1OUT			; Set TxPl high (idle), all other outputs low.
			cmp.b	#255,&ID				; If we're not a BMU
			_IF		_NE
				mov.b	#VrefP|TxPl|TxMi|TouchV_Byp,&P1DIR ; Set VrefP, Tx bits, bypass as outputs
			_ELSE							; Else
				mov.b	#VrefP|TxPl|TxMi,&P1DIR ; Set VrefP, Tx bits as outputs
			_ENDIF

			; Initialise port 2
			mov.b	#0,&P2SEL				; Set bits 6, 7 not as xtal pins. No timer comms in TestICal
			mov.b	#0,&P2OUT				; Set all outputs low.
			mov.b	#RelayM|RelayP|TxMiScu|Piezo|ErrLed,&P2DIR ; Set Relays,Tx, Piezo, ErrLed as outputs

			; Initialise port 3
			; Default settings of P3SEL are OK. No timer comms in TestICal.
			mov.b	#0,&P3OUT
			mov.b	#PreCont|BatCont|ChgCont|TxMiChg|DisCont|NrmCont|TxMi,&P3DIR ; Set Tx, conts as outs
											; Also need TxMi because need comparator to invert output
			bis.b	#TxMi,&P3SEL			; Select the comparator output function of P3.7

			; Use the Analog Comparator to get an inverted version of TxPlIn (P1.3/CA3)
			; (which is the UART TxPl looped back) to appear on TxMi (P3.7/CAOUT).
			mov.b	#CAON|CAREF_2,&CACTL1		; Half-supply to the comparator pos input and turn it on
			mov.b	#P2CA2|P2CA1,&CACTL2		; Feed CA3 to the comparator neg input
			mov.b	#TxPlIn,&CAPD				; Disable the digital input buffer of P1.3
#else
	#if REV61
			mov.b	#TxPl,&P1OUT			; Set TxPl. Short the piezo.
			mov.b	#VrefP|TxPl|TxMi|Piezo,&P1DIR ; Set VrefP, Tx bits and piezo as outputs
	#else
			mov.b	#ActLed+TxPl,&P1OUT		; Turn off (inverted) ActLed and set TxPl. Short the piezo.
			cmp.b	#0,&ID					; If we're not an IMU
			_IF		_NE
				mov.b	#ActLed+VrefP+TxPl+TxMi+Piezo,&P1DIR ; Set ActLed, VrefP, Txs, Piezo as outputs
			_ELSE
				mov.b	#VrefP+TxPl+TxMi+Piezo,&P1DIR ; Set VrefP, Tx bits and piezo as outputs
			_ENDIF
	#endif // REV61
			mov.b	#0,&P2SEL				; Set Bypass and ErrLed to not be crystal osc pins
			mov.b	#0,&P2OUT				; Set Bypass and ErrLed off (RLY- and RLY+ if we're an IMU)
			mov.b	#$FF,&P2DIR				; Set Bypass and ErrLed as outputs
#endif // G2553

			; Reinitialise clocks using RAM calibration values. These should have sorted out any data
			; version issues, new chip, etc.
			mov.b	#DIVM_1+DIVS_3,&BCSCTL2	; Set MCLK = DCOCLK/2, SMCLK = DCOCLK/8
			mov.b	&ram8MHzCalB,&BCSCTL1
			mov.b	&ram8MHzCalD,&DCOCTL
#if !G2553
			; Prepare ACLK for piezo drive -- 3 kHz square wave
			bis.b	#LFXT1S_2,&BCSCTL3		; Select VLOCLK (~12 kHz) as source for ACLK divider
#endif
			clr		rERR					; Clear the error register

;
; Initialise the ADC10
;
#if G2553
			cmp.b	#255,&ID					; If we're not a BMU (BMS Master Unit)
			_IF		_NE
				; Enable analog inputs and Vref+ out, but not TouchV
				mov.b		#(1<<VRefPChan)|(1<<ArrayV_BoltVPl_Chan)|(1<<ShuntV_BoltVMi_Chan)|(1<<BatV_StrapVPl_Chan),&ADC10AE0
			_ELSE
				; Enable analog inputs and Vref+ out
				mov.b		#(1<<VRefPChan)|(1<<ArrayV_BoltVPl_Chan)|(1<<ShuntV_BoltVMi_Chan)|(1<<BatV_StrapVPl_Chan)|(1<<TouchVChan),&ADC10AE0
			_ENDIF
#else
			cmp.b	#0,&ID					; If we're not an IMU (Insulation Monitoring Unit)
			_IF		_NE
				; Enable cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				mov.b		#(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ELSE
				; Enable touchV, cellV and linkV analog inputs. Enable ADC function of P1.4 (Vref+ out)
				mov.b		#(1<<TouchVChan)|(1<<CellVChan)|(1<<LinkVChan)|(1<<4),&ADC10AE0
			_ENDIF
#endif // G2553

			; Initialise ADC10
			; SREF_1    = +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temperature)
			; REFOUT    = connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			; No MSC	= single sample and conversion
			mov			#SREF_1+ADC10SHT_3+REFOUT+REFON,&ADC10CTL0
			; Other ADC10 initialisation is done every time "measure" is called, to save code

;
; Miscellaneous initialisation
;
;			clr.b	TXCksum						; Clear transmit checksum

;
; Initialise the command character interpreter
;
;			clr.b	&RXCksum					; Clear the receive checksum
;			bic.b	#bHexOutput,&interpFlags		; Decimal output mode by default
;			bic.b	#bChecksumming,&interpFlags	; Checksumming of packets, off by default
;			bic.b	#bDontInterpret,&interpFlags	; Interpret
			mov		#TIB,&ToIN				; Packet pointer

			mov		#initCmdString,Rip			; Interpret the init string as commands
			call	#_ENTER

			ret									; Return from initialise

; End of initialise


DELAY_IF_NEEDED MACRO
			_DO		#1390,R11			; Delay for approx ...
			_LOOP	R11					;	... 1.04 ms
			ENDM						; Allows downstream CMU to echo a byte


; Some definitions so the common code will work
WaitTxComplete:	ret						; Empty routine: transmit is always complete
TxByteCk:	xor.b	R8,&txCksum			; Alternative entry which accumulates checksum
TxByte:		call	#WriteByte

			ClearWatchdog

			DELAY_IF_NEEDED
			ret


; Some definitions so the measure.s43 code will work
; Monitor defines these as their inf-flash counterparts instead of ram
#define VoltCal ramVoltCal
#define TempCal	ramTempCal
#define LinkCal	ramLinkCal

#include "../common/comMisc.s43"			// Miscellaneous common functions, e.g. TxCksum
#include "../common/measure.s43"			// ADC Measurement
#include "../common/math.s43"				// Multiply and divide
#include "../common/CmdCharInterpreter.s43"


;
; Compare the 8 bytes of calibration data at ramDataStart with what's at $10F8.
; Returns with Z set if OK, Z clear if not.
; Relies on definitions like infoDataStart and mainDataEnd to sort out the boundaries
; Trashes R12
compareInfoFlash:
			clr		R12					; Loop counter
			_BEGIN
				cmp.b	infoDataStart(R12),ramDataStart(R12)
				_WHILE	_EQ ; _Z
					inc		R12
					cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	_EQ					; Loop until we get to infoDataEnd
				_ENDIF
			; The increment will have set Z if all compares well. The cmp will have cleared Z otherwise.
			ret

;
; Compare the 512 bytes at BSL2b with what's at BSL2 ($FE00). Returns with Z set if OK, Z clear if not.
; Trashes R12
compareBSL2:
			mov		#BSL2,R12
			_BEGIN
				cmp.w	@R12,BSL2b-BSL2(R12)
				_WHILE	_EQ ; _Z
					incd	R12
			_UNTIL	_Z					; Loop until R12 wraps from $FFFE to 0
				_ENDIF
			; The increment will have set Z if all compares well. The cmp will have cleared Z otherwise.
			ret

; ----------------------------------------------------------------------------
; errorFlash
; Takes a 16 bit pattern in rERR and repeatedly flashes the error LED in that pattern
; at 0.4 seconds per bit, LSbit first. It never returns -- infinite loop.
; This error processing code should be near the middle of the image to allow jmps to it instead of brs.
ErrorFlash:
			mov.w	#WDTPW+WDTHOLD,&WDTCTL		; Hold the Watchdog Timer (ReadByte may have reset it)
			; We could end up here after the DCO calibration has been set to $FFFF,
			;	so the processor could be running very fast.
			mov.b	#$8D,&BCSCTL1				; Typical 8 MHz DCO calibration value
			mov.b	#$81,&DCOCTL				;	so we can count the flashes
			mov		rERR,R9
			mov		#16,R10						; Bit loop counter
			_BEGIN
				rra		R9						; LSB into carry
				_IF		_C
					ErrLedOn
				_ELSE
					ErrLedOff
				_ENDIF
				_DO		#8,R11					; 8 * 49 = 392 ms delay
					_DO		#0,R12				; 65536 * 3 / 4 MHz = 49 ms delay
					_LOOP	R12
				_LOOP	R11
				dec		R10
			_UNTIL	_Z							; Until 16 bits sent
			jmp		ErrorFlash					; Infinite loop

;-------------------------------------------------------------------------------
PizTiovIsr:
; Combined timer capture/compare 1 or 2 and timer overflow interrupt service routine
;-------------------------------------------------------------------------------
			; Warning: Do not be tempted to replace the two instructions below: mov &TAIV,R9 ; cmp #2,R9
			; with the single instruction cmp #2,&TAIV. This caused rare dropped bits on receive and
			; it took a lot of effort to trace the problem to this instruction.
			; It appears that despite only reading and not writing to its "destination" operand, the
			; compare instruction is still treated as making _two_ accesses to TAIV, in the sense that
			; it clears not only the interrupt flag being serviced but also any other TAIV interrupt
			; that might be pending, causing it to never be serviced.

											; (6) cycles for interrupt accepted
			push	R9						; (3) Save R9 (needed for queue use on last data bit anyway)
			mov		&PizTAIV,R9				; (3) Read the Timer-A interrupt sub-vector (one access only!)
			cmp		#PizCCRp-PizCCR0,R9		; (1) Was it a PWM interrupt
			jeq		PwmSubIsr
			jmp		ExitIsr					; Restore R9 and return from interrupt

PwmSubIsr	; Compare match for PWM
			; We want the piezo to run at 4.2 kHz, or 1000/4.2 = 238 us period, or
			; 238/2 = 119 us per half period. The timer runs at 1 MHz, so that's 119 counts
			add		#119,&PizCCRp			; Advance the counter by half a period
ExitIsr
			pop		R9						; Restore R9
			reti							; Return from interrupt


#include "TesDefinitions.s43"	// Include command character definitions
#include "../common/BSL2.s43"	// Include macro for bootstrap-loader and interrupt vectors


; ----------------------------------------------------------------------------
; Inactive copy of bootstrap loader (BSL2b)
;---------------------------------------------------------------------------------
; This copy will be relocated to the end of main-flash at $FE00-$FFFF by the 'b' command (updateBSL2).
; Instantiate this copy of the BSL2 macro with different external labels from the main copy at $FE00.
BSL2b			BSL2MACRO	initRetAddr2b, BSLErase2b, ReadByteb, WriteByteb
				ORG		BSL2b+$1FE			; The copy of the reset vector
				DW		BSL2				; Points to BSL2 in last main-flash segment, $FE00

; Some calculations so we can see how much space we have left, by reading the listing.
freespace		EQU		_CMDCHRTBL-$	; From here to the start of the command character table
#define BCD(x) 			( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent	EQU		BCD( (100*freespace)/(_CMDCHRTBL-PROG_START))

;---------------------------------------------------------------------------------
; Interrupt and entry-point jump table at the end of the second-last main-flash segment
;---------------------------------------------------------------------------------
				ORG		$FDE2
CMDCHRTBLEND	EQU		$				; Command character table ends immediately below lowest used
										;  interrupt vector
jUCA0TxIsr		reti					; UART transmit not used
				nop
jUCA0RxIsr		reti					; UART receive not used
				nop

jTA1RxTiovIsr	reti					; TA1 CC1&2 & TAI not used
				nop
jTA1TxIsr		reti					; TA1 CC0 not used
				nop

jInterpretByte	br		#InterpretByte	; A branch to InterpretByte, independent of PROG_START

jTA0RxTiovIsr	br		#PizTiovIsr		; Combined TA0 CC1&2IFG & TAIFG (ovf) used for Piezo 4.2 kHz
jTA0TxIsr		reti					; Timer A0 CC0IFG (transmit compare) not used
				nop

				ORG		$FDFE
ProgPresence	DB		$AA				; For BSL2 to check before calling main program (InterpretByte)
ProgChecksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg

;---------------------------------------------------------------------------------
; Bootstrap loader (BSL2), active copy
;---------------------------------------------------------------------------------
; Active copy of BSL2 in the last main-flash segment, not sent when bootstrap loaded, only when JTAGed.
; Updated by TestICal 'b' command, or by JTAGing.
				ORG			$FE00		; Start of last main-flash segment
main:									; For IAR Embedded Workbench IDE debugger
; Instantiate the BSL2 macro with the standard external labels
BSL2:			BSL2MACRO	initRetAddr2, BSLErase2, ReadByte, WriteByte
				ORG		$FFFE			; The reset vector
				DW		BSL2
				END
