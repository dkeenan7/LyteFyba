			COL		154			; Wide listings
; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve calibration data.
;
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Output options to:
;  Allow C-SPY-specific extra output file
; Set the IAR Embedded Workbench IDE Project/Options/Linker/Extra Output options to:
; Generate Extra Output File
;	Override default
;	TestICal.bin
;	Output format: raw-binary
;
; This software has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; "TestICal" is a TESTer, Id-setter, CALibrator and bootstrap-loader updater for our
; Cell Management Unit (CMU) and Battery Management Unit (BMU) based on an MSP430 microcontroller.
;
; TestICal should be the first program written to main-flash.
; This initial programming must be done using a flash programmer connected to the JTAG port.
;
; TestICal contains two copies of a bootstrap loader (BSL), one active, the other inactive.
; The initial JTAG programming of TestICal will place this BSL in its active position
; in the last 512 bytes of main-flash.
; From then on, programming may be done via serial communications using this BSL.
; Use the Windows program CMUsend or the Linux program sendprog to send the file
; TestICal.bin or monitor.bin.
;
; When loading TestICal via BSL, only the inactive copy of the BSL is sent with it.
; But this copy can be written to the active location, to update the BSL, by using the 'b' command.
; TestICal can also perform voltage and temperature calibrations and store this calibration data
; in info-flash using the 'u' command.
;
; The BSL consists of a software UART providing RS422-style serial communications,
; and a password-recognising state-machine. The state-machine normally passes incoming
; serial data to a command interpreter in main-flash. But when the password is recognised,
; the state-machine instead writes incoming serial data to main-flash.
; This allows it to overwrite TestICal with the normal command interpreter or monitor,
; sent via the serial input. And because the BSL transmits all data received on its serial
; input, to its serial output, a cascaded series of these MSP430 boards can all be updated
; simultaneously. You only need to send a new version of the monitor to the first board
; in the chain.
;
; But what if you want to update the BSL itself? In that case, instead of sending a new
; monitor, you send TestICal carrying the new version of the BSL.
; This time you send TestICal via the serial input not the JTAG port.
; That way a 'b' command will update the BSLs of all the boards in the chain simultaneously.
;
; The BSL code is located in the last 512 bytes of main-flash because this flash segment contains
; the reset vector and can be left alone when the rest of main-flash is erased.
;
; The following is true of both TestICal and the BSL:
;	They use no interrupts, since the interrupt vectors will be reprogrammed.
;	They use no timer; timer use requires too many 6-byte instructions.


; Init Command String
; A string of commands that will be interpreted after all other initialisation is complete.
; Its most common use is to restore a sensible DCO clock frequency calibration value when this has
; been erased or corrupted, thereby rendering communications impossible or unreliable.
; In that case, it must of course be loaded using a JTAG programmer as the BSL will not work.

#define INIT_CMD_STRING ''	 			// No initial command
; #define INIT_CMD_STRING 'ub'			// Move old cal data to new location and update BSL
; #define INIT_CMD_STRING '$AD90\'fwf'	// Write a new frequency cal value then let us measure it.
;										// Note that an update command 'u' is required to make it stick.

; Conditional assembly parameters which may be changed for special purposes
#define		ADCBUF		0			// 0 for no ADC sample buffer; 1 for buffer
#define		INSULATION_MONITORING 1	// Can leave out the insulation monitoring code if not needed.
#define		FAKE_NEW_CHIP	0		// 1 to force recalculation of our voltage and temperature
									// calibration constants from the manufacturer's constants

ProductCode	EQU		'T'				; T for TestICal, R for monitoR, L for monolith, W for wmonolith

ID			EQU		ramID			; We use the ram copy of the ID for s, x, prettyPrint
									; commands. Monitor uses the info-flash copy

; Some definitions so the measure.s43 code will work
; Monitor defines these as their info-flash counterparts instead of ram
VoltCal 	EQU	ramVoltCal
VoltOff		EQU ramVoltOff
BoltPlCal 	EQU	ramBoltPlCal
BoltPlOff	EQU ramBoltPlOff
TempCal		EQU	ramTempCal
LinkCal		EQU	ramLinkCal
			LSTOUT-
#include "msp430.h"							// MSP430 Special Function Register definitions
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
#include "../common/comMacros.h"			// Macros for obscure instruction sequences
#include "../common/common.h"				// Definitions common to monitor, TestICal and BSL

; The LOCKA bit in FCTL3 was made a *toggle*, for backwards compatibility.
; Use these macros to safely clear and set it.
CLRLOCKA	MACRO
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			_IF		_NZ					; Currently locked?
				MOV		#FWKEY+LOCKA,&FCTL3 ; Yes, unlock
			_ENDIF
			ENDM

SETLOCKA	MACRO
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			_IF		_Z					; Currently unlocked?
				MOV		#FWKEY+LOCKA,&FCTL3 ; Yes, lock
			_ENDIF
			ENDM


				ORG		$200		; Start of RAM. Ends at InitSP-1
; This area is common to all main programs and used by the BSL and is not block erased on a reset
bsl2state		DS		2			; Password recogniser state for BSL2
resetCounter	DS		2			; Number of resets since the last "^" command
resetBuffer		DS		16			; Circular buffer recording the reason for the last 16 resets
discharge		DS		4			; Accumulator for depth of discharge determination.
									; Unit is 1/5 A for 1/15 s = 1/75 coulomb = 1/270 milliamphour.
									; So 32 bits allows 15,900 Ah, but 24 bits would only allow 62 Ah.



oldFllTime		DS		2			; Used by Frequency Locked Loop
									;	Must be cleared before enabling or re-enabling interrupts
measureCount	DS		2			; Incremented by FLL interrupt routine, on ACLK rising edge, 4096 Hz
oldMeasureCount DS		2			; Value of measureCount at the last measure
oldRtcMeasCnt	DS		2			; Hi 4 bits of measureCount at the last advance of RTC seconds count

; Command Character Interpreter flags
interpFlags		DS		1			; Interpreter flags, bitmask definitions follow
bHexOutput		EQU		1<<0		; Should numeric output be in hexadecimal, not decimal?
bChecksumming	EQU		1<<1		; Are we sending checksums and checking received checksums?
bDontInterpret	EQU		1<<2		; Are we interpreting?
bDontEcho		EQU		1<<3		; Are we echoing characters? (not yet implemented in TestICal)
bModbusOutput	EQU		1<<4		; Should PrettyPrint output be formatted as a Modbus/ASCII response?
bEchoResponses	EQU		1<<5		; True to echo complete Modbus responses
bQuiet			EQU		1<<6		; True to silence piezo

				ALIGNRAM 1
comNoEraseEnd	; End of unerased variables; start of erased variables

#if	ADCBUF
				ALIGNRAM 1
sampleBuf	DS		2*NumSamples	; ADC sample buffer; 4 or 16 samples
#endif

; RAM copies of various calibration settings
; Same order as stored in info-flash
			ALIGNRAM 1				; So word values are word-aligned
ramDataStart
ramBoltPlOff	DS		1			; Voltage offset calibration word for bolt/array
ramVoltOff		DS		1			; Voltage offset calibration word for cell
ramCapacity		DS		2			; Battery capacity in tenths of an amp-hour
ramCellRes		DS		2			; High temp cell internal resistance in micro-ohms
ramBoltPlCal	DS		2			; Voltage scale calibration word for bolt/array
ramVoltCal		DS		2			; Voltage scale calibration word for cell
ramTempCal		DS		1			; Temperature offset calibration for internal sensor
ramLinkCal		DS		1			; Link voltage offset calibration data
ram8MHzCalD 	DS		1			; 8 MHz DCO frequency calibration byte
ram8MHzCalB 	DS		1			; 8 MHz DCO range calibration byte
ramID			DS		1			; Cell/CMU identifier byte; first cell is 1; written by 'i' cmd
ramDataVers		DS		1			; Data version
ramDataEnd

; Miscellaneous variables

txCksum		DS		1				; Transmit checksum

; Command Character Interpreter variables

rxCksum		DS		1				; Received packet xor checksum

			ALIGNRAM 1
eraseEnd	EQU		$				; End of the erased variables

ToIN		DS		2				; Pointer to present character being stored in Text Input Buffer
TIB			DS		48				; Text Input Buffer (packet buffer)
TIBEnd
; Must leave room for stack (about 36 bytes minimum)
STACKSPACE		EQU		InitSP-$	; Look at listing to see what this is

;-------------------------------------------------------------------------------
				ORG		PROG_START	; In main-flash
;-------------------------------------------------------------------------------

#include "../common/CmdCharInterpreter.s43" // RPN interpreter with one-or-two-character commands
#include "NonIntComms.s43"					// TxByte etc for non-interrupt TestICal
#include "../common/ComComms.s43"			// Common comms functions, e.g. TxCksum
#include "../common/measure.s43"			// ADC measurement functions
#include "../common/math.s43"				// Multiply and divide routines
#include "TesDefinitions.s43"				// Include command character definitions

			; Assemble any initialisation command string
InitCmdString
			DB		INIT_CMD_STRING
			DB		EXIT					; Must end with an EXIT command
			ALIGN	1


;-------------------------------------------------------------------------------
; InterpretByte
;-------------------------------------------------------------------------------
;
; The BSL calls this with any byte that is received by the serial port, including password bytes.
;
InterpretByte:
main:										; For IAR Embedded Workbench IDE debugger
			ClearWatchdog					; Clear and restart Watchdog Timer 32k cyc. BSL sets 64 cyc.
			call	#ACCEPT					; Process R8 as part of a command to be interpreted
			ClearWatchdog
			ret								; Return to the BSL

;-------------------------------------------------------------------------------
; InterpretInit
;-------------------------------------------------------------------------------
;
; The BSL will call this on any normal reset (not a watchdog timeout or key violation or SFR instruction fetch)
; and after successfully bootstrap-loading a new monitor or TestICal or other main-flash program.
; This intialises the RAM calibration values, and anything else that hasn't already been initialised
; by the BSL before this is called.
;
InterpretInit:
			ClearWatchdog					; Clear and enable Watchdog Timer 32k cyc. BSL sets 64 cyc.
			; Clear all variables in RAM except resetBuffer and BMU's fuel gauge discharge accumulator
			_DO		#eraseEnd-comNoEraseEnd,R8
				clr		comNoEraseEnd-2(R8)
			_mLOOP	#2,R8

;
; Copy calibration data into RAM
;
#if !FAKE_NEW_CHIP
			_CASE
			;_OFb	#DATAVERS-1,&infoDataVers
				; Copy/translate stuff from previous version to RAM
			;_ENDOF
			_OFb	#DATAVERS,&infoDataVers		; Check at the present address
				; The RAM image has the same layout as current version data, so we use a block move
				_DO		#infoDataEnd-infoDataStart,R8 ; Prepare to move ~16 bytes
					mov.b	infoDataStart-1(R8),ramDataStart-1(R8) ; Move 1 byte
				_LOOP	R8							; Decrement loop counter by 1, loop if non zero
			_ENDOF
			_OFb	#DATAVERS,&oldInfoDataVers	; Check at the old address ($10FF)
				; The RAM image has the same layout as current version data, so we use a block move
				_DO		#infoDataEnd-infoDataStart,R8 ; Prepare to move ~16 bytes
					mov.b	oldInfoDataStart-1(R8),ramDataStart-1(R8) ; Move 1 byte
				_LOOP	R8							; Decrement loop counter by 1, loop if non zero
			_ENDOF
			_OFb	#$FF,&infoDataVers
#endif
				; If we find $FF at infoDataVers (an area of info-flash that we assume will be erased
				; in new chips), then assume it's a new chip. If not a new chip, it will have the data
				; version number (way < $80).
				; A new chip. We want to preserve some of the existing DCO calibration data.
				; Set the ID, voltage, temperature and link calibration.

// Convert unfriendly TI provided indices to the addresses of the relevant constants
// Their index names start with CAL_ADC, our pointer names start with CALADC (one less underscore)
CALADC_15VREF_FACTOR EQU TLV_ADC10_1_TAG_ + 2 + (CAL_ADC_15VREF_FACTOR * 2) ; Index vref cal off tag adr
CALADC_OFFSET		 EQU TLV_ADC10_1_TAG_ + 2 + (CAL_ADC_OFFSET		   * 2) ; Index off. cal off tag adr
CALADC_GAIN_FACTOR	 EQU TLV_ADC10_1_TAG_ + 2 + (CAL_ADC_GAIN_FACTOR   * 2) ; Index gain cal off tag adr
CALADC_15T30		 EQU TLV_ADC10_1_TAG_ + 2 + (CAL_ADC_15T30 * 2) 		; Index temp cal off tag adr

newChip:
				mov.w	#1800,&ramCapacity			; 180 amp-hours
				mov.w	#740,&ramCellRes			; 740 micro-ohms
				; Use the manufacturer's correction factors and offset.
				; Despite what the Family User Guide and Datasheets suggest, three correction values
				; are needed: a reference voltage factor, an ADC gain factor, and an ADC offset.
				; We combine the two factors into our default voltage factors, and add two new
				; calibration values for bolt and cell offsets.
				; We want a calibraton factor in 1.15 FixedPoint that is the product of two TI given
				; 1.15 FP values. These are all 2^15 times a real number, so we end up with 2^30 times
				; a real number, so we have to divide by 2^15. Do this by doubling (32-bit shift left)
				; and taking the top half
				mov.w	&CALADC_15VREF_FACTOR,R8	; Get 1.5 V reference correction factor
				mov.w	&CALADC_GAIN_FACTOR,R9		; Get ADC gain correction factor
				call	#UMStar						; R10:R9 = R8 * R9
				add		#$4000,R9					; For rounding
				adc		R10
				rla		R9							; Get MSB to carry (actually a shift)
				rlc		R10							; Double R10:R9, carry to LSB
				mov.w	R10,&ramBoltPlCal			; Use this as the default bolt voltage factor
				mov.w	R10,&ramVoltCal				; and the default cell voltage factor
				mov.w	&CALADC_OFFSET,R8			; Use the TI provided offset for default bolt
				mov.w	R8,&ramBoltPlOff			; offset and
				mov.w	R8,&ramVoltOff				; cell offset
				; Call the manufacturer's temp cal N30, the raw ADC count at 30degC with 1.5V ref.
				; Convert it to Toff, our kind of offset calibration in degrees C.
				; i.e. an offset from the typical T = (V - 0.986)/0.00355
				; where V = Vcal/32768 * N/1023 * 1.5
				; So Tcal = N30 * Vcal/32768 * 1.5 / 1023 / 0.00355 - 0.986 / 0.00355 - 30
				; = N30 * Vcal/32768 * 0.413035 - 307.75
				; = N30 * Vcal/32768 * 27069/65536 - 1231/4
				; = (N30 * Vcal/32768 * 4 * 27069/65536 - 1231) / 4
				; = (N30 * Vcal/65536 * 8 * 27069/65536 - 1231) / 4
				mov		&CALADC_15T30,R8			; Get N30, the raw ADC count at 30degC with 1.5V ref
				mov		&ramVoltCal,R9				; Get voltage calibration word as multiplicand in R9
				call	#UMStar						; R10:R9 = R8 * R9
				rla3	R10							; Multiply by 8
				mov		R10,R8
				mov		#27069,R9
				call 	#UMStar						; R10:R9 = R8 * R9
				sub		#1231,R10
				add		#7,R10						; Compensate for systematic error
				add		#2,R10						; Add half the divisor for rounding
				rra2	R10							; Divide by 4
				mov.b	R10,&ramTempCal				; Will fit into a signed byte
				mov.b	#$00,&ramLinkCal			; Really the BatV- or Shunt offset calibration now.

				; These are not actually used any more. We run an FLL off a watch crystal instead.
				mov.b	&CALDCO_8MHZ,&ram8MHzCalD	; Copy manufacturer's 8 MHz DCO calibration data
				mov.b	&CALBC1_8MHZ,&ram8MHzCalB
				bis.b	#XT2OFF | DIVA_3,&ram8MHzCalB ; Set ACLK = watch crystal / 8

#if !FAKE_NEW_CHIP
				; Set ID to 0 (CMU) if we're in a 20 pin package (Port 3 not connected)
				mov.b	#0,&P3DIR					; Set Port 3 as all inputs
				mov.b	#$FF,&P3REN					; Enable all pullup/pulldown resistors
				_COND								; Begin a short-circuit conditional
					mov.b	#0,&P3OUT					; Pull them all down with resistors
					cmp.b	#0,&P3IN					; Check if all inputs are low
				_AND_IF	_EQ							; If they all got pulled low
					mov.b	#$FF,&P3OUT					; Pull them all up with resistors
					cmp.b	#$FF,&P3IN					; Check if they are all low
				_AND_IF _EQ							; And if they all got pulled high
					mov.b	#0,&ramID					; Set ID = 0 (un-IDed CMU)
				_ELSES
					mov.b	#$FF,&ramID					; Set ID = 255 (BMU)
				_ENDIF
				mov.b	#$00,&P3REN					; Disable all pullup/pulldown resistors
													; Leaving them on causes problems for outputs
#else
				mov.b	&infoID,&ramID				; Preserve the existing ID
#endif
				mov.b	#DATAVERS,&ramDataVers		; The present data version
				call	#_updateInfoFlash			; If we're a CMU, this is the only way to tell the
													; BSL to assume CMU hardware (e.g. ReadByte)
#if !FAKE_NEW_CHIP
			_ENDOF
			; default action if none of the above apply
				; Data version number is higher or lower than can be handled by this version of TestICal
				; so we should leave it alone and raise an error.
				mov		#b'1010101000000000,R8	; 4 flashes
				br		#jErrorFlash			; Infinite loop, never returns
			_ENDCASE
#endif

			; Initialise port 1
			; BSL settings of Port1 are OK. No interrupt comms in TestICal. Analog settings done later.

			; Initialise port 2
			mov.b	#0,&P2OUT					; Set all outputs low.
			bis.b	#ErrLed,&P2DIR				; Set ErrLed as output
			bis.b	#TxMiChg_57k6B|TxMiChg2_RlyP_57k6A,&ChgPortDIR ; Set Txs as outputs
												; Do not disturb bits 6, 7 (XIN, XOUT)
			cmp.b	#255,&ID
			_IF		_NE							; If we're not a BMU
				bis.b	#Bypass,&BypPortDIR 		; Set Bypass as output
			_ENDIF

			; Initialise port 3. CMUs don't use this port, but no harm in setting it up.
			; Don't change the state or direction of any BMU contactor outputs or you might cut off
			; power to the BMU.
			cmp.b	#255,&ID
			_IF		_NE						; If we're a CMU
				mov.b	#$FF,&P3REN				; Enable pullup/pulldown resistors to save power, for
												;   any pin which may remain a floating input in a CMU.
			_ENDIF
			; Don't change the state of contactor outputs unless this is a power-on reset
			; or you might cut off your own power.
			mov		&resetCounter,R8
			dec		R8
			and		#$0F,R8
			mov.b	resetBuffer(R8),R8
			and.b	#PORIFG|RSTIFG,R8		; Extract the two bits that indicate power-on, reset-pin or,
											; in combination, a bootstrap-load.
			cmp.b	#PORIFG,R8				; Compare with power-on only
			_IF		_EQ						; If it was a power-on
				mov.b	#0,&P3OUT				; Turn off all contactors
			_ENDIF
			; Set contactor outputs as outputs in case they aren't already.
			mov.b	#PreCtor|BatPosCtor|BatNegCtor|AcLfPvCtor|RtPvCtor,&P3DIR
			bic.b	#TxMiScu,&ScuPortOUT		; Set Tx low
			bis.b	#TxMiScu,&ScuPortDIR		; Set Tx as output
			; Default settings of P3SEL are OK. No timer comms in TestICal.


;
; Initialise the ADC10
;
			cmp.b	#255,&ID					; If we're not a BMU (BMS Master Unit)
			_IF		_NE
				; Enable analog inputs and Vref+ out, but not TouchV
				; Don't set P1.5 as analog input; it's not BoltVPl
				mov.b		#(1<<VRefPChan)|(1<<ShuntV_BoltVMi_Chan)|(1<<BatV_StrapVPl_Chan),&ADC10AE0
			_ELSE
				; Enable analog inputs and Vref+ out
				mov.b		#(1<<VRefPChan)|(1<<ArrayV_BoltVPl_Chan)|(1<<ShuntV_BoltVMi_Chan)|(1<<BatV_StrapVPl_Chan)|(1<<TouchVChan),&ADC10AE0
			_ENDIF

			; Initialise ADC10
			; SREF_1    = +-refs are Vref+ and AVSS
			; ADC10SHT_3 = sample time is 64 ADC10CLKs (32 us required for temperature)
			; REFOUT    = connect Vref+ to pin P1.4
			; REFON		= turn on the voltage reference and reference buffer
			; No MSC	= single sample and conversion
			mov			#SREF_1+ADC10SHT_3+REFOUT+REFON,&ADC10CTL0
			; Other ADC10 initialisation is done every time "measure" is called, to save code

;
; Miscellaneous initialisation
;
;			clr.b	TXCksum						; Clear transmit checksum

;
; Initialise the command character interpreter
;
;			clr.b	&RXCksum					; Clear the receive checksum
			clr.b	&interpFlags
			mov		#TIB,&ToIN				; Packet pointer

			mov		#InitCmdString,Rip			; Interpret the init string as commands
			call	#_ENTER

			ret									; Return to the BSL

; End of InterpInit
;-----------------------------------------------------------------------------------------------------


;
; Compare the ~16 bytes of calibration data at ramDataStart with what's at infoDataStart (in info-flash).
; Returns with Z set if OK, Z clear if not.
; Trashes R12
compareInfoFlash:
			clr		R12					; Loop counter
			_BEGIN
				cmp.b	infoDataStart(R12),ramDataStart(R12)
				_WHILE	_EQ ; _Z
					inc		R12
					cmp		#infoDataEnd-infoDataStart,R12
			_UNTIL	_EQ					; Loop until we get to infoDataEnd
				_ENDIF
			; The increment will have set Z if all compares well. The cmp will have cleared Z otherwise.
			ret

;
; Compare the 1024 bytes at jBSLb (inactive copy) with what's at jBSL (active copy at $FC00).
; Returns with Z set if OK, Z clear if not.
; Trashes R12
compareBSL2:
			mov		#jBSL,R12
			_BEGIN
				cmp.w	@R12,jBSLb-jBSL(R12)
				_WHILE	_EQ ; _Z
					incd	R12
			_UNTIL	_Z					; Loop until R12 wraps from $FFFE to 0
				_ENDIF
			; The increment will have set Z if all compares well. The cmp will have cleared Z otherwise.
			ret

; ----------------------------------------------------------------------------
; Inactive copy of bootstrap loader (BSL2b)
;---------------------------------------------------------------------------------
#include "BSL2Macro.s43"					// Include macro for bootstrap-loader and interrupt vectors

; This copy will be relocated to the end of main-flash at $FE00-$FFFF by the 'b' command (updateBSL2).
; Instantiate this copy of the BSL with different external labels from the main copy at $FE00.
		BSL2MACRO	jBSLb, jBSLEraseb, jReadByteb, jWriteByteb, jBslRevisionb, jWriteBreakb, jErrorFlashb
		ORG		$FFFE-(jBSL-jBSLb)	; The copy of the reset vector
		DW		jBSL				; Points to BSL2 in last main-flash segments

; Some calculations so we can see how much space we have left, by reading the listing.
freespace		EQU		_CMDCHRTBL-$	; From here to the start of the command character table
#define BCD(x) 			( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent	EQU		BCD( (100*freespace)/(_CMDCHRTBL-PROG_START))

;---------------------------------------------------------------------------------
; Interrupt and entry-point jump table at the end of the third-last main-flash segment
;---------------------------------------------------------------------------------
				ORG		BSL2_START-$22	; FBDE for now
CMDCHRTBLEND	EQU		$				; Command character table ends immediately below lowest
										;  main-program entry point
jInterpretByte	br		#InterpretByte	; A branch to InterpretByte, independent of PROG_START

jUCA0TxIsr		reti					; UART transmit not used
				nop
jUCA0RxIsr		reti					; UART receive not used
				nop

jTA1TxRxIsr		reti					; Combined TA1 CCR1 & CCR2 (transmit & receive capture/compare)
				nop
jTA1PwmIsr		reti					; Timer A1 CCR0 (SoC PWM compare)
				nop

jInterpretInit	br		#InterpretInit	; A branch to InterpretInit, independent of PROG_START

jTA0TxRxIsr		reti					; Combined TA0 CCR1 & CCR2 (transmit & receive capture/compare)
				nop
jTA0FllIsr		reti					; Timer A0 CCR0 (frequency locked loop capture).
				nop						;   This is handled directly by the BSL.

				ORG		BSL2_START-2	; FBFE for now
ProgPresence	DB		$AA				; For BSL2 to check before calling main program (InterpretByte)
ProgChecksum	DB		$FF				; Placeholder for checksum added by CMUsend or SendProg

;---------------------------------------------------------------------------------
; Bootstrap loader (BSL2), active copy
;---------------------------------------------------------------------------------
; Active copy of BSL2 in the last main-flash segment, not sent when bootstrap loaded, only when JTAGed.
; Updated by TestICal 'b' command, or by JTAGing.
				ORG			BSL2_START		; Start of last main-flash segment
; Instantiate the BSL with the standard external labels
#include "../common/BSL2.s43"			// Include bootstrap-loader and interrupt vectors
				ORG		$FFFE			; The reset vector
				DW		jBSL			; Reset to BSL main entry
				END
