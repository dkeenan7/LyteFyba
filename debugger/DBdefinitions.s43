;
; Bytecode definitions for the BSLwriter
;


#include "../common/comDefinitions.s43"				; Include the definitions common to monitor and BSLW

; Some definitions so the common code will work

; changeSign ( n -- -n )
		xCODE	'~',changeSign,_changeSign
		inv.b	Rtos
		inc.b	Rtos
		ret
		
;
; setIds ( -- )
;
			xCODE	'i',setIDs,_setIDs
; It just doesn't seem to work out to use the delay between BMUs to determine the correct ID, so
; we simply read the ID from the serial port, and echo the next ID downstream.

			call	#ReadByte				; Read the byte into R8, don't echo it, trashes R9 R10 R11
											; Not echoed because of logic in dummyInterpretByte
waitingIDAddr								; This address will be on the stack in dummyInterpretByte
			mov		R8,R12					; Save our ID
			inc		R8
			call	#WriteByte				; Send downstream BMU's ID
			bic.b	#LED,&P1OUT				; Clear LED set by WriteByte
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (ReadByte has re-set)
			mov.b	R12,&ramID				; Save our ID to RAM
			ret

;
; Calibrate ( n ch --- )
; Perform a calibration whose type is ch ('v' for voltage etc) and value is n
;
			xCODE	'c',calibrate,_calibrate
			_CASE
			_OFb	#'v',Rtos			; 'v': cell Voltage
				mov		#CellVChan<<12,R8		; ADC channel for scaled cell voltage input
				call	#measure
; The calibration scale factor will be the expected value divided by the reading.
; The expected value is an unsigned 12 bit integer of millivolts and
; the reading is an unsigned 12.2 bit fixed-point number of millivolts.
; We want the calibration scale factor to be represented as an unsigned 1.15 fixed-point number
; i.e. a number with 1 integer bit and 15 fractional bits.
; So we shift the expected value 17 places left before the division.
CalVoltDividend	SET	CALVOLTS<<17	
				mov		#LWRD CalVoltDividend,R9	; Dividend lo word into R9
				mov		#HWRD CalVoltDividend,R10	; Dividend hi word into R10
				mov		R8,R11						; The divisor is the voltage reading in R8
				rra		R11							; Add half the divisor to the dividend for rounding
				add		R11,R9
				adc		R10
				call	#UMSlashMod					; Gives quotient in R9, remainder in R10
				
				mov.b	R9,&ramVoltCalL				; Save calibration value lo byte
				swpb	R9
				mov.b	R9,&ramVoltCalH				; Save calibration value hi byte
			_ENDOF
			
			_OFb	#'t',Rtos			; 't': temperature
;
; Temperature offset calibration
; M = 4096/1.5 * (.00355 T + typ0.986)
;	= 9.694*T + typ2692
; M/9.694	= T + typ277.7
; Per the MSP430F2012 datasheet, typ277.7 aims at 273, so the reading is proportional
; to the absolute temperature, with an offset of +- 100 mV.
			; We use offsetByte = (M/9.694 - T) >> 1
; So we use offsetByte = (M/9.694 - T) - 273
; and T = M/9.694 - 273 - offsetByte
;
				mov		#TempChan<<12,R8			; ADC channel for temperature sensor
				call	#measure
			
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor
; in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
				mov.b		&ramVoltCalL,R9			; Get voltage calibration lo byte
				mov.b		&ramVoltCalH,R10		; Get voltage calibration hi byte
				swpb		R10						; Assemble the two bytes into a word
				bis			R10,R9					; as multiplicand in R9
													; Multiplier is sum-of-samples, already in R8
				call		#UMStar					; Gives unsigned product in R10 (hi word) & R9 (lo word)
													; Note: calls assembler code that ends in ret
				inc			R10						; For correct rounding
				rra			R10						; Shift product hi word right one bit

; To divide by 9.694, multiply by 65536/9.694 = 6760
				mov		R10,R8
				mov		#6760,R9
				call	#UMStar
				sub		#CALTEMP+273,R10
;				rra		R10							; Temp offset now fits in a byte
				mov.b	R10,&ramTempCal				; Save temperature offset calibration value
			_ENDOF
			
			_OFb		'l',Rtos				; 'l': link voltage
				// FIXME: TO BE COMPLETED
				mov		#LinkVChan<<12,Rtos
				call	#measure
				sub		#2048,R8					; Zero volts for link voltage is a 2048 reading
				cmp		#$FF81,R8					; -$7F
				jl		nonCal						; If <s -$7F, use the $80 non-calibrated value
				cmp		#$80,R8
				jl		realCal						; If >s -$7F and <s $80, use as real calibration value
nonCal			mov		#$80,R8
realCal
				mov.b	R8,&ramLinkCal				; Save the link calibration value
			_ENDOF
;
; Default case
				mov		#2,rERR					; Unknown calibration type character
				jmp		errorFlash

			_ENDCASE

			jmp		_readCalValue			; Display the value just calibrated and return

;
; Read calibration value (ch --- )
; Calibration type (e.g. 'v' for cell Voltage) in ch
			xCODE	'r',readCalValue,_readCalValue
			// FIXME: TO BE COMPLETED
			ret

; Update info-flash ( -- )
			xCODE	'u',updateInfoFlash,_updateInfoFlash
; Prepare to flash-program
; Assumes ACCVIE = NMIIE = OFIE = 0.
; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz
#if MClock4
			MOV		#FWKEY+FSSEL_1+FN0*(12-1),&FCTL2 ; For 4 MHz MCLK
#else
			MOV		#FWKEY+FSSEL_1+FN0*(3-1),&FCTL2 ; For 1 MHz MCLK
#endif
			MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write-block cant be)
StopWDT		mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer

;
;	FIXME: NOT FINISHED!
;

; Erase info flash including segment A.
startErase
			mov		#$1000,R12				; Start of info-flash
eraseInfo	MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase (doesn't seem to "stick")
			rra		@R12					; Dummy write: erase segment
			add		#64,R12					; Next segment
			cmp		#$10C0,R12
			jnz		eraseInfo				; Loop until at start of segment A
			CLRLOCKA						; Clear segment A lock (so we can erase and write it also)
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase
			rra		@R12					; Dummy write: erase segment A

			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave on; only write block that can't)
			clr		R12						; $1000 is start of info flash
			mov		#for1000,R9				; Start of code to write there
pifLoop		mov.w	@R9+,$1000(R12)			; Program word
			incd	R12
			cmp		#256,R12				; Test index
			jnz		pifLoop					; Repeat until done
			

			MOV		#FWKEY,&FCTL1			; Done. Clear WRT
			MOV		#FWKEY+LOCK+LOCKA,&FCTL3 ; Set LOCKs
			SETLOCKA						; Ensure segment A is locked
			;
			; Check that the flash programming worked
			;
			call	#compareImage			; Compare the for1000 image with what's at 1000
			jnz		failCompare
			
			tst		rERR
			jnz		errorFlash
			;
			; Compares successfully. Point reset vector to new code.
			; NOTE: this will erase all other interrupt vectors, and the last 512 bytes (quarter) of
			; main-flash!
			;
			bis.b	#LED,&P1OUT				; Turn on LED briefly (BSL will revert) to indicate success
			MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase
			rra.b	&$FFFF					; Dummy write: erase segment
			MOV		#FWKEY+WRT,&FCTL1		; Enable write
			mov		#$1000,&$FFFE			; Re-point reset vector
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming

			bic.b	#WDTIFG,&IFG1			; Clear the watchdog timer interrupt flag
			mov		#$55AA,R15				; Set R15 (= Rstate) to pattern to prevent infinite loops
			; FIXME: DO WE WANT THIS?
			br		#$1000					; Start the new BSL

failCompare mov		#3,rERR
			jmp		errorFlash

#if 0
;-------------------------------------------------------------------------------
; Flash programming macros

; The LOCKA bit in FCTL3 was made a *toggle*, for backward compatibility.
; Use these macros to clear and set safely.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm


flashCStore:
			; Assembly language flash writer
			; Byte  in R8, address in R9. Trashes Rtrash
			;
			; Check if it is possible to flash-program this ID
			;
			call	#waitTxCmpl				; Wait for any byte to transmit (likely CR echo)
			mov.b	R8,Rtrash				; Need to check for 1 bits in new ID
			bic.b	@R9,Rtrash				;	that are already 0s in the existing byte
			tst.b	Rtrash					; Set Z flag if result is 0; bic doesn't
			jnz		cantFlsh				; Impossible flash-write; can't do it
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3
			MOV 	#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV 	#FWKEY,&FCTL3       	; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write block that can't be)
			CLRLOCKA
			mov.b	R8,0(R9)				; Flash-write it
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming
			SETLOCKA
			MOV		#FWKEY,&FCTL1			; Disable flash write
			bic.b	#LED,&P1OUT				; Clear the error LED: done!
			ret
cantFlsh	bis.b	#LED,&P1OUT				; Set the error LED to indicate failure
			ret
#endif

