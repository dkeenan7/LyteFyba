;
; Bytecode definitions for the BSLwriter
;


#include "../common/comDefinitions.s43"				; Include the definitions common to monitor and BSLW

; Some definitions so the common code will work

; changeSign ( n -- -n )
		xCODE	'~',changeSign,_changeSign
		inv.b	Rtos
		inc.b	Rtos
		ret
		
;
; setIds ( -- )
;
			xCODE	'i',setIDs,_setIDs
; It just doesn't seem to work out to use the delay between BMUs to determine the correct ID, so
; we simply read the ID from the serial port, and echo the next ID downstream.

			call	#ReadByte				; Read the byte into R8, don't echo it, trashes R9 R10 R11
											; Not echoed because of logic in dummyInterpretByte
waitingIDAddr								; This address will be on the stack in dummyInterpretByte
			mov		R8,R12					; Save our ID
			inc		R8
			call	#WriteByte				; Send downstream BMU's ID
			bic.b	#LED,&P1OUT				; Clear LED set by WriteByte
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (ReadByte has re-set)
			mov.b	R12,&ramID				; Save our ID to RAM
			ret

		
; Update info-flash ( -- )
		xCODE	'u',updateInfoFlash,_updateInfoFlash
; Prepare to flash-program
; Assumes ACCVIE = NMIIE = OFIE = 0.
; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz
#if MClock4
			MOV		#FWKEY+FSSEL_1+FN0*(12-1),&FCTL2 ; For 4 MHz MCLK
#else
			MOV		#FWKEY+FSSEL_1+FN0*(3-1),&FCTL2 ; For 1 MHz MCLK
#endif
			MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write-block cant be)

;
;	FIXME: NOT FINISHED!
;
			ret
		

#if 0
; Link voltage offset Calibration (--)
; Assumes zero link voltage due to zero link current
;
		xCODE	'c',calLink,_calLink
		mov		#LinkVChan<<12,Rtos
		call	#_llVolt
		sub		#2048,Rtos				; Zero volts for link voltage is a 2048 reading
		cmp		#$FF81,Rtos				; -$7F
		jl		nonCal					; If <s -$7F, use the $80 non-calibrated value
		cmp		#$80,Rtos
		jl		realCal					; If >s -$7F and <s $80, use as real calibration value
nonCal	mov		#$80,Rtos
realCal
		mov		#LinkCal,R9				; Address of byte to flash
		mov		Rtos,R8					; Value to flash
		jmp		flashCStore				; Write the calibration value and exit


;-------------------------------------------------------------------------------
; Flash programming macros

; The LOCKA bit in FCTL3 was made a *toggle*, for backward compatibility.
; Use these macros to clear and set safely.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm


flashCStore:
			; Assembly language flash writer
			; Byte  in R8, address in R9. Trashes Rtrash
			;
			; Check if it is possible to flash-program this ID
			;
			call	#waitTxCmpl				; Wait for any byte to transmit (likely CR echo)
			mov.b	R8,Rtrash				; Need to check for 1 bits in new ID
			bic.b	@R9,Rtrash				;	that are already 0s in the existing byte
			tst.b	Rtrash					; Set Z flag if result is 0; bic doesn't
			jnz		cantFlsh				; Impossible flash-write; can't do it
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3
			MOV 	#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV 	#FWKEY,&FCTL3       	; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write block that can't be)
			CLRLOCKA
			mov.b	R8,0(R9)				; Flash-write it
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming
			SETLOCKA
			MOV		#FWKEY,&FCTL1			; Disable flash write
			bic.b	#LED,&P1OUT				; Clear the error LED: done!
			ret
cantFlsh	bis.b	#LED,&P1OUT				; Set the error LED to indicate failure
			ret
#endif

