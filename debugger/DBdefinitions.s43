;
; Bytecode definitions for the BSLwriter
;


#include "../common/comDefinitions.s43"				; Include the definitions common to monitor and BSLW

; Some definitions so the common code will work

; changeSign ( n -- -n )
		xCODE	'~',changeSign,_changeSign
		inv.b	Rtos
		inc.b	Rtos
		ret
		

#if 0
; Link voltage offset Calibration (--)
; Assumes zero link voltage due to zero link current
;
		xCODE	'c',calLink,_calLink
		mov		#LinkVChan<<12,Rtos
		call	#_llVolt
		sub		#2048,Rtos				; Zero volts for link voltage is a 2048 reading
		cmp		#$FF81,Rtos				; -$7F
		jl		nonCal					; If <s -$7F, use the $80 non-calibrated value
		cmp		#$80,Rtos
		jl		realCal					; If >s -$7F and <s $80, use as real calibration value
nonCal	mov		#$80,Rtos
realCal
		mov		#LinkCal,R9				; Address of byte to flash
		mov		Rtos,R8					; Value to flash
		jmp		flashCStore				; Write the calibration value and exit


;-------------------------------------------------------------------------------
; Flash programming macros

; The LOCKA bit in FCTL3 was made a *toggle*, for backward compatibility.
; Use these macros to clear and set safely.
CLRLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT 	#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm


flashCStore:
			; Assembly language flash writer
			; Byte  in R8, address in R9. Trashes Rtrash
			;
			; Check if it is possible to flash-program this ID
			;
			call	#waitTxCmpl				; Wait for any byte to transmit (likely CR echo)
			mov.b	R8,Rtrash				; Need to check for 1 bits in new ID
			bic.b	@R9,Rtrash				;	that are already 0s in the existing byte
			tst.b	Rtrash					; Set Z flag if result is 0; bic doesn't
			jnz		cantFlsh				; Impossible flash-write; can't do it
			; Assumes ACCVIE = NMIIE = OFIE = 0.
			; FSSEL: 1=MCLK FN: 2=divide by 3
			MOV 	#FWKEY+FSSEL_1+FN1,&FCTL2 ; MCLK/3 (FN1=2^1; divides by FN+1)
			MOV 	#FWKEY,&FCTL3       	; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave enabled; only write block that can't be)
			CLRLOCKA
			mov.b	R8,0(R9)				; Flash-write it
			MOV		#FWKEY+LOCK,&FCTL3		; Set LOCK; no accidental flash programming
			SETLOCKA
			MOV		#FWKEY,&FCTL1			; Disable flash write
			bic.b	#LED,&P1OUT				; Clear the error LED: done!
			ret
cantFlsh	bis.b	#LED,&P1OUT				; Set the error LED to indicate failure
			ret
#endif

