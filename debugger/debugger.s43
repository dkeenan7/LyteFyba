; Ensure you set the FET Debugger download options to erase main memory _only_,
; _not_ information memory. This is to preserve the Bootstrap Loader and calibration data.
			COL		132				; Nice wide listings
; This is a Debugger / Bootstrap-loader writer (BSL-writer version 2) for a MSP430F2012 microcontroller.
; This version is interactive; there is still the original BSLwriter that requires reassembly to
;	perform various actions
;
; It has been developed by Mike Van Emmerik and Dave Keenan for their
; lithium battery monitoring system for high voltage electric vehicles.
;
; This debugger should be the first program written to the 2kB of main-flash on the MSP430F2012 of a
;	cell-top Battery Management Unit (BMU).
; This must be done using a flash programmer connected to the chip's JTAG port.
; The debugger contains a copy of a bootstrap loader (BSL).
; It writes this BSL to the 256 bytes of info-flash, while preserving some of the
; digitally controlled oscillator (DCO) calibration bytes that are stored there
; by the chip manufacturer.
; It can also perform voltage and temperature calibrations
; and store this calibration data in info-flash as well.
; It then passes control to the BSL.

; The BSL consists of a software UART providing RS422-style serial communications,
; and a password-recognising state-machine.
; The state-machine normally passes incoming serial data to a command interpreter
; in main-flash.
; But when the password is recognised, the state-machine instead writes incoming serial data
; to main-flash.
; This allows it to overwrite the BSL-writer with the initial command interpreter, sent
; via the serial input.
; And because the BSL transmits all data received on its serial input, to its serial output,
; a cascaded series of these MSP boards can all be updated simultaneously.
; You only need to send a new version of the command interpreter to the first board
; in the chain.
;
; But what if you want to update the BSL itself?
; In that case, instead of sending a new interpreter, you send this debugger/BSL-writer2
; carrying the new version of the BSL.
; This time you send the debugger/BSL-writer2 via the serial input not the JTAG port.
; That way you will update the BSLs of all the MSP boards in the chain simultaneously.
;
; The existing BSL will dutifully load the BSL-writer into main flash,
; completely unaware that it has just loaded the instrument of its own demise.
; When the old BSL calls the debugger/BSL-writer2, thinking it is initialising a new interpreter,
; the BSL-writer2 will write the new BSL to info-flash and pass control to it.
; Then the interpreter must be sent again, to replace the BSL-writer.
; The BSL-writer2 still preserves the calibration data, which may now include
; voltage and temperature calibration data in addition to the DCO calibration data
; from the manufacturer.
;
; The BSL code is made to fit in the tiny 256 bytes of info-flash because
; this segment can be protected when the rest of the flash is erased,
; and all other flash segments are 512 bytes and contiguous with each other,
; but not with info-flash.
;
; For this reason, the BSL code is highly hand-optimised for space and
; uses some tricks that may make it hard to follow and hard to modify.
;
; The following is true of this debugger/BSL-writer2, and the BSL itself
;	They use no interrupts, since the interrupt vectors will be reprogrammed.
;	They use no timer; timer use requires too many 6-byte instructions!
; The BSL serial input code no longer checks for false start bits or does majority voting on data bits.

; Conditional assembly parameters which may be changed for special purposes

MClock4		EQU		1				; Non zero if MCLK is 4MHz
LEDWITHTX	EQU		1				; Set to 1 for LED flashing with each TX byte
CALIBRATE	EQU		0				; Set to 1 to perform volts and temperature calibration
									;	(all BMUs) in addition to BSL-programming
CALONLYONE	EQU		0				; Set to 1 to calibrate volts and temp on only 1 BMU
									;	(NOTE: IDs must be set)
									; CALIBRATE and CALONLYONE are mutually exclusive
CALTHIS		EQU		4				; The cell with this ID is used when CALONLYONE is on
CALVOLTS	EQU		3600			; Put the exact test voltage (in millivolts) here
CALTEMP		EQU		19				; Ambient temperature in degrees Celsius
DEBUG		EQU		0				; 1 for debug, e.g. copy voltage reading to $FFF0
RESETIDS	EQU		0				; 1 to generate new IDs starting from byte read serially
FORCEFCAL1	EQU		0				; 1 to force 1 MHz calibration frequency
FREQCAL1	EQU		$86C0			; Value to force 1 MHz frequency calibration to
FORCEFCAL4	EQU		0				; 1 to force 4 MHz calibration frequency
FREQCAL4	EQU		$8ABC			; Value to force 4 MHz frequency calibration to
FD4MHz		EQU		1				; Use 4 MHz clock for $FD00 frequency check, otherwise use 1 MHz


; ADC channel numbers
CellVChan	EQU		$7				; ADC channel number for cell voltage
TempChan	EQU		$A				; ADC channel number for temperature
LinkVChan	EQU		$3				; ADC channel number for link voltage
NumSamples	EQU		16				; Number of ADC over-samples (typ. 4 or 16)
NOBUF		EQU		1				; 1 for no buffer; 0 for buffer

; To get n more bits of resolution, add up 4^n samples and shift the result right by n bits.
; i.e. By adding up 4^n samples you get 2n more bits in the result,
; but half of them are noise and should be thrown away,
; leaving us with n bits of additional information.

; Locations in info-flash, of routines and calibration data
; These addresses must be manually exported to the interpreter.
; Assemble this file with listing-generation enabled, then look at the listing file
; to determine the absolute addresses to put into the interpreter.

infoInitRetAddr	EQU		mainInitRetAddr-for1000+$1000	; Return address when interpretByte
														; is called for initialisation
infoReadByte	EQU		ReadByte	-for1000+$1000		; Where to call ReadByte
infoWriteByte	EQU		WriteByte	-for1000+$1000		; Where to call WriteByte
infoBSLErase	EQU		mainBSLErase-for1000+$1000		; Where to jump in to erase main flash
infoID			EQU		mainID		-for1000+$1000		; Address of BMU ID byte
info1MHzCalD	EQU		main1MHzCalD-for1000+$1000		; Address of 1 MHz DCO frequency calibration
info1MHzCalB	EQU		main1MHzCalB-for1000+$1000		; Address of 1 MHz DCO range calibration
info4MHzCalD	EQU		main4MHzCalD-for1000+$1000		; Address of 4 MHz DCO frequency calibration
info4MHzCalB	EQU		main4MHzCalB-for1000+$1000		; Address of 4 MHz DCO range calibration
infoVoltCalL	EQU		mainVoltCalL-for1000+$1000		; Address of voltage scale calibration lo byte
infoVoltCalH	EQU		mainVoltCalH-for1000+$1000		; Address of voltage scale calibration hi byte
infoTempCal		EQU		mainTempCal	-for1000+$1000		; Address of temperature offset calibration byte
infoLinkCal		EQU		mainLinkCal	-for1000+$1000		; Address of link voltage offset cal byte
infoPWtable		EQU		mainPWtable	-for1000+$1000		; Address of BSL password in reverse-order
infoDataVers	EQU		mainDataVers-for1000+$1000		; Address of Data Version byte
DATAVERS		EQU		5						; This is version 5 of the BMU info-flash data structure

; Locations in info-flash, of calibration data in previous versions of the BSL
; to allow us to update them to the current version without losing their calibration data.

; New chip (has $FFFF at $10C0)
infN4MHzCalD	EQU		$10F6		; Address of 4 MHz DCO frequency calibration
									; (presumed to be for 4 MHz, not documented by manufacturer)
infN4MHzCalB	EQU		$10F7		; Address of 4 MHz DCO range calibration
									; (presumed to be for 4 MHz, not documented by manufacturer)
infN1MHzCalD	EQU		$10FE		; Address of 1 MHz DCO frequency calibration
infN1MHzCalB	EQU		$10FF		; Address of 1 MHz DCO range calibration

; Interpreter Register Usage
;	Registers 0 thru 3 are dedicated machine registers (PC SP SR CG).
#define 	Rip		R5				// Virtual machine instruction pointer
#define 	Rlit	R6				// Holds partial literals
#define 	Rw		R8				// Working register - temporary - anyone can use

			LSTOUT-
#include "msp430.h"
#include "../common/ControlFlowMacros.h"	// Provides structured control-flow for assembly language
			LSTOUT+

; Error register. 0 means no error
#define		rERR	r14					// Overlaps with Rcksum in the BSL, but that is OK

; The LOCKA bit in FCTL3 was made a *toggle*, for backwards compatibility.
; Use these macros to safely clear and set it.
CLRLOCKA	macro
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			JZ		$+2+6				; Already unlocked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, unlock
			endm

SETLOCKA	macro
			BIT		#LOCKA,&FCTL3		; Test LOCKA
			JNZ		$+2+6				; Already locked?
			MOV		#FWKEY+LOCKA,&FCTL3 ; No, lock
			endm


			ORG		$200			; Start of RAM
#if !NOBUF
sampleBuf	ds		NumSamples*2	; Room for 4 or 16, 10-bit samples
#endif
; ByteCodeInterpreter2 variables

base			DS	1				; Number base, 10 or 16
CHKSUM			DS	1				; Packet xor checksum
Checksumming 	DS	1				; Boolean
dontInterpret	DS	1				; Boolean; for 'x' command
TXCksum			DS	1				; Transmit checksum
passWordState	DS	1				; State of the password detection logic; 3 = start

; RAM copies of various calibration settings
; Same order as stored in the BSL with the latest data layout
			ALIGNRAM 1				; So these can be copied with word moves
ramID		ds		1				; Cell/BMU identifier byte; first cell is 0; written by 'i' cmd
ramSpare	ds		1				; Padding so 4MHz cal data ends up at same address as in new chip
ram1MHzCalD ds		1				; 1 MHz DCO frequency calibration byte; written by BSL writer
ram1MHzCalB ds		1				; 1 MHz DCO range calibration byte; written by BSL writer
ram4MHzCalD ds		1				; 4 MHz DCO frequency calibration byte
ram4MHzCalB ds		1				; 4 MHz DCO range calibration byte
ramVoltCalL ds		1				; Voltage scale calibration lo byte; may be written by BSL writer
ramVoltCalH ds		1				; Voltage scale calibration hi byte; may be written by BSL writer
ramTempCal	ds		1				; Temperature offset calibration; may be written by BSL writer
ramLinkCal	ds		1				; Link voltage offset calibration data; may be written by BSL writer


			ALIGNRAM 1
ToIN		DS		2				; Pointer to current character being stored in Text Input Buffer
TIB			DS		1				; Start of Text Input Buffer, grows towards stack


			ORG		$FFFE			; The reset vector
			dw		JTAGstart		; If this BSL-writer is JTAGged then the reset vector must point
									;	to it directly. For example, a new chip has no BSL at all.
;
; BSL-writer code in main-flash.
; This code copies any existing calibration data from info-flash to the image of the new BSL
; in main-flash, then erases info-flash and copies the new BSL there from its main-flash image.
			ORG		$F800
;
; We need an interpret-byte function here; the BSL (either the real BSL, or the BSL-image in bsl.s43)
; will call this when any bytes are received by the serial port, including "password" bytes.
; The BSL will also call this with a null that was not received by the serial port
; but is intended to initialise the interpreter or other main-flash program.
; It will do this on any reset and after successfully bootstrap-loading a new monitor or debugger or
; BSL-writer.
interpretByte:
			cmp		#infoInitRetAddr,0(SP)	; Is the call merely for initialisation?
			jeq		initialise				; If yes, don't echo the byte, initialise, and return
			cmp		#waitingIDAddr,0(SP)	; Is the call from the waitingID call to ReadByte?
			jnz		noWaitID				; If not, echo as usual
			ret								; Yes, so return to ReadByte's caller (debugger below),
											;	without calling WriteByte (don't echo wrong ID)
noWaitID
			call	#WriteByte				; No, not initialise call, echo the byte, as the BSL has not
			bic.b	#LED,&P1OUT				; Turn off the error LED to show successful download
			call	#ACCEPT					; Process the byte
			ret								; Return to the BSL


;
; The intitialise routine. This intialises everything except the stack pointer, including the
; ram calibration values. It could be called by main, or by the initialise call from the BSL
; If called by the BSL, the BSL's ReadByte loop is called, so that password detection and downloads
; are handled. If started by a cold start (reset or JTAG), it is assumed that the BSL may not be
; present, so a simple ReadByte loop is used that doesn't check for password bytes.
;
initialise:
#if MClock4
			cmp.b	#4,&infoDataVers
			jeq		unknownVersBSL					; Can't handle version 4 data layout; use BSLwriter
#if 0			// It turns out, I guess by design, that info4MHzCALB/D and $10F7/6 are the same addr!
			_IF			_L							; If < 4, assume a new chip (e.g. has $86 there)
				mov.b	&$10F7,&BCSCTL1					; 4 MHz calibration
				mov.b	&$10F6,&DCOCTL					;	in a new chip (undocumented)
			_ELSE
#endif
				// Assume version 5 layout
				mov.b	&info4MHzCalB,&BCSCTL1			; 4MHz from info-flash
				mov.b	&info4MHzCalD,&DCOCTL
#if 0
			_ENDIF
#endif
#else										; Else frequency is 1 MHz
			cmp.b	#4,&infoDataVers
			_IF			_L
				mov.b	&CALBC1_1MHZ,&BSCTL1
				mov.b	&CALDC0_1MHZ,&DCOCTL
			_ELSE
				mov.b	&info1MHzCalB,&BCSCTL1	; Set range for 0.54 to 1.06 MHz
				mov.b	&info1MHzCalD,&DCOCTL	; Set DCO step + modulation for 1.00 MHz
			_ENDIF
#endif

#if 0		// This should be set up by the BSL if present, and does not matter if it is not present
			; Set P1.4 as an output as well as the LED. This will put 0V at the bottom of the link
			; voltage divider, so we can test with paralleled boards, and not have > Vcc on any
			; analogue input (trust me, you get meaningless conversions)
			mov.b	#LED+(1<<4)+TXDp+TXDm,&P1DIR ; Set LED, P1.4, and TX bits to output
			mov.b	#TXDp,&P1OUT			; Turn off LED and bypass; set TXDp
#endif
			clr		rERR					; Clear error register

;
; Initialise the stripped-down bytecode interpreter
;
			mov.b	#10,&base				; Decimal output mode by default
			clr.b	&CHKSUM					; Clear checksum
			mov.b	#0,&Checksumming		; Checksumming of packets, off by default
			mov.b	#0,&dontInterpret		; Interpret
			mov		#TIB,&ToIN				; Packet pointer

;
; Copy calibration data into RAM
;

;
; If we find $FFFF (erased flash) at $10C0 (start of info-flash protected segment A),
; then assume it's a new chip.
			cmp		#$FFFF,&$10C0	; Don't look at $1000 in case JTAG debugger is set to erase it
			jeq		newChip			;	before downloading
			
; It's not a new chip so check the data version number at the end of info-flash.
			cmp.b	#DATAVERS,&infoDataVers
			jeq		currVersBSL
;			jge		unknownVersBSL
;			jl		unknownVersBSL
unknownVersBSL
; Version number is higher or lower than this BSL-writer knows about,
; so we should leave it alone and raise an error.
			mov		#4,rERR
			jmp		errorFlash
			

newChip
; A new chip. We want to preserve some of the existing DCO calibration data

			; Set the ID, voltage, temperature and link calibration to $FF
			mov		#$FFFF,&ramID
			mov		#$FFFF,&ramVoltCalL
			mov		#$FFFF,&ramTempCal
			mov.w	&infN4MHzCalD,&ram4MHzCalD	; Copy 4 MHz calibration data
			mov.w	&infN1MHzCalD,&ram1MHzCalD	; Copy 1 MHz calibration data
			ret
			
			
currVersBSL
			; The RAM image has the same layout as current version data, so we use a block move
			_DO		#10,R15							; Prepare to move 10 bytes by 2s
				mov		infoID-2(R15),ramID-2(R15)	; Move 2 bytes
			_mLOOP	#2,R15							; Decrement loop counter by 2, loop if non zero
			ret

;
; Start of the actual debugger / BSL-writer2, when not started from the BSL
; This initialises, then runs a ReadByte loop
;
main:										; For debugger
JTAGstart:	mov		#$280,SP
			call	initialise				; Do most of the initialisation
			br		#_updateInfoFlash		; Update info flash and establish a BSL
			

; Some definitions so the common code will work
#define ID	infoID
waitTxCmpl	ret							; Empty routine: transmit is always complete
TX_ByteCk	xor.b	R8,&TXCksum			; Alternative entry which accumulates checksum
TX_Byte		clr		R11					; Needed for BSL's WriteByte
			call	#WriteByte
			mov.w	#WDTPW+WDTCNTCL,&WDTCTL ; Clear watchdog timer
			_DO		#1350,R11			; Delay for approx
			_LOOP	R11					;	1.04 ms
			ret


#include "../common/comMisc.s43"			// Miscellaneous common functions, e.g. TX_Cksum
#include "../common/measure.s43"			// ADC Measurement
#include "../common/math.s43"				// Multiply and divide
#include "../common/comMacros.h"			// Macros for obscure instruction sequences
#include "../common/BytecodeInterpreter2.s43"

;
; The below is slightly different to the one in monitor.s43, so we don't share them.
; This one uses the calibration value in RAM, and doesn't have to load them byte at a time
measAndCal:
			call		#measure				; Defined in ../common/measure.s43
;
; Calibrate the value by multiplying the sum-of-samples by the voltage calibration scale factor in infoFlash.
; The sum-of-samples, when considered as a single oversampled-and-decimated reading,
; is an unsigned 12.2 bit fixed-point number of millivolts.
; The calibration factor is an unsigned 1.15 bit fixed-point number.
; We want a 12 bit integer result in millivolts.
; That means we have to shift the product 17 bits to the right, which is equivalent to
; throwing away the lo word and shifting the high word one bit to the right.
			mov.w		&ramVoltCalL,R9			; Get voltage calibration word
												; Multiplier is sum-of-samples, already in R8
			call		#UMStar					; Gives unsigned product in R10 (hi word) and R9 (lo word)
												; Note: calls assembler code that ends in ret
			inc			R10						; For correct rounding
			rra			R10						; Shift product hi word right one bit
			ret									; Finished



;
; Compare the 256 bytes at for1000 with what's at $1000. Returns with Z set if OK, Z clear if not
compareImage:
			clr		R12
cmpLoop1	cmp		$1000(R12),for1000(R12)
			jnz		justRet
			incd	R12
			cmp		#mainID-for1000,R12
			jnz		cmpLoop1
			; Just as with flash writing from RAM, R12 is too big by $F2 (mainID-for1000):
cmpLoop2	cmp		$1000(R12),ramID-(mainID-for1000)(R12)
			jnz		justRet
			incd	R12
			cmp		#mainPWtable-for1000,R12
			jnz		cmpLoop1
cmpLoop3	cmp		$1000(R12),for1000(R12)
			jnz		justRet
			incd.b	R12
			jnz		cmpLoop1					; Branch if 8-bit increment has not overflowed to 0

justRet		ret


; ----------------------------------------------------------------------------
; The bootstrap loader (BSL)
;
; This will be relocated to info-flash which starts at $1000.
#include "../common/bsl.s43"


; This error processing code should be near the middle of the image
errorFlash:	mov		rERR,R11
			add		R11,R11					; Double
#if MClock4
				rla		R11
				rla		R11						; And quadruple for 4 MHz
#endif
			mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer (ReadByte may have reset)
errFlashLp	xor.b	#LED,&P1OUT				; The best we can do is freeze and flash LED
delay		dec		R12
			jnz		delay
count		dec		R11
#if	MClock4
				bit		#3,R11
				jnz		delay					; Extra delays for 4 MHz
				tst		R11
#endif
			jnz		errFlashLp
			;
			; Pause between rErr flashes
#if	MClock4
pause			mov		#5*4,R11
#else
pause			mov		#5,R11
#endif
pauseL		dec		R12
			jnz		pauseL
			dec		R11
			jnz		pauseL
			jmp		errorFlash



; ----------------------------------------------------------------------------
; Bytecode definitions
#include "DBdefinitions.s43"

; The end of the bootstrap loader (BSL)
; -----------------------------------------------------------------------------


freespace		EQU		_OPCODETBL-$
#define BCD(x) 			( x / 100 * $100 + x % 100 / 10 * $10 + x % 10 )
spaceaspercent	EQU		BCD( (100*freespace)/2048)


			END
