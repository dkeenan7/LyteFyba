;
; Command character definitions for the debugger
;

#include "../common/comDefinitions.s43"			; Include the definitions common to monitor
												; and debugger
;
; Calibrate ( n ch --- )
; Perform a calibration whose type is ch ('v' for voltage etc) and value is n
;
			xCODE	'c',calibrate,_calibrate
			_CASE
			_OFb	#'v',Rtos			; 'v': cell Voltage
				mov		#CellVChan<<12,R8		; ADC channel for scaled cell voltage input
				call	#measure
; The calibration scale factor will be the expected value divided by the reading.
; The expected value is an unsigned 12 bit integer of millivolts and
; the reading is an unsigned 12.2 bit fixed-point number of millivolts.
; We want the calibration scale factor to be represented as an unsigned 1.15 fixed-point number
; i.e. a number with 1 integer bit and 15 fractional bits.
; So we shift the expected value 17 places left before the division.
				clr		R9							; 16 bits of zeroes
				mov		Rsec,R10
				rla		R10							; 17 zeroes; we have value << 17 in R10:R9
				mov		R8,R11						; The divisor is the voltage reading in R8
				rra		R11							; Add half the divisor to the dividend for rounding
				add		R11,R9
				adc		R10
				call	#UMSlashMod					; Gives quotient in R9, remainder in R10
				mov.w	R9,&ramVoltCalL				; Save calibration value
			_ENDOF
			
			_OFb	#'t',Rtos			; 't': temperature
;
; Temperature offset calibration
; M = 4096/1.5 * (.00355 T + typ0.986)
;	= 9.694*T + typ2692
; M/9.694	= T + typ277.7
; Per the MSP430F2012 datasheet, typ277.7 aims at 273, so the reading is proportional
; to the absolute temperature, with an offset of +- 100 mV.
			; We use offsetByte = (M/9.694 - T) >> 1
; So we use offsetByte = (M/9.694 - T) - 273
; and T = M/9.694 - 273 - offsetByte
;
				mov		#TempChan<<12,R8			; ADC channel for temperature sensor
				call	#measAndScale

; To divide by 9.694, multiply by 65536/9.694 = 6760
				mov		R10,R8
				mov		#6760,R9
				call	#UMStar
				sub		#273,R10
				sub		Rsec,R10					; Subtract 273 and the calibration temperature
				mov.b	R10,&ramTempCal				; Save temperature offset calibration value
			_ENDOF
			
			_OFb		#'l',Rtos				; 'l': link voltage
				mov		#LinkVChan<<12,R8
				call	#measAndScale
				sub		#2048,R10					; Zero volts for link voltage is a 2048 reading
				;sub		Rsec,R10				; Subtract required reading (usually 0)
				; Actually require 1.3653*Rsec to be subtracted. Too much code. So `lc will always
				;	calibrate to zero millivolts (calibrate with no significant charge or discharge).
				cmp		#$FF81,R10					; -$7F
				jl		nonCal						; If <s -$7F, use the $80 non-calibrated value
				cmp		#$80,R10
				jl		realCal						; If >s -$7F and <s $80, use as real calibration value
nonCal			mov		#$80,R10
realCal
				mov.b	R10,&ramLinkCal				; Save the link calibration value
			_ENDOF
;
; Default case
				jmp		emitQmark					; Unknown calibration type character

			_ENDCASE

			;jmp		_readCalValue			; Display the value just calibrated and return
												;	(by falling through)
			;
			; Keep 'c' command (above) and 'r' command (below) together
			; That is, don't insert a new command here
			;
;
; Read calibration value ( ch --- )
; Calibration type (e.g. 'v' for cell Voltage) in ch
			xCODE	'r',readCalValue,_readCalValue ; Note: 'r' prints Rx state in monitor
			_CASE
			_OFb		#'v',Rtos				; 'v': cell Voltage
				mov			#5,Rtos					; 5 digits
				mov.w		&ramVoltCalL,Rsec		; Get the cal value
			_ENDOF
			_OFb		#'t',Rtos				; 't': temperature
				mov			#3,Rtos
				mov.b		&ramTempCal,Rsec
			_ENDOF
			_OFb		#'l',Rtos				; 'l': link voltage
				mov			#3,Rtos
				mov.b		&ramLinkCal,Rsec
			_ENDOF
			_OFb		#'f',Rtos				; 'f': 4 MHz cal
				mov			#5,Rtos
				mov.w		&ram4MHzCalD,Rsec
			_ENDOF
			_OFb		#'o',Rtos				; 'o': 1 MHz cal
				mov			#5,Rtos
				mov.w		&ram1MHzCalD,Rsec
			_ENDOF
			_OFb		#'i',Rtos				; 'i': ID
				mov			#3,Rtos
				mov.b		&ramID,Rsec
			_ENDOF
emitQmark:	mov		#'?',Rtos				; This should be ignored by downstream BMUs
			call	#_EMIT
			mov		#$0D,Rtos				; Carriage return
			jmp		_EMIT
			_ENDCASE
			mov.b		#' ',Rthd			; Trailing char (space)
			jmp 	_prettyPrint			; Print and return


;
; Write calibration value ( n ch --- )
; Calibration type (e.g. 'v' for cell Voltage) in ch; n has value to write
			xCODE	'w',writeCalValue,_writeCalValue
			_CASE
			_OFb		#'v',Rtos				; 'v': cell Voltage
				mov.w		Rsec,&ramVoltCalL		; Set the cal value
			_ENDOF
			_OFb		#'t',Rtos				; 't': temperature
				mov.b		Rsec,&ramTempCal
			_ENDOF
			_OFb		#'l',Rtos				; 'l': link voltage
				mov.b		Rsec,&ramLinkCal
			_ENDOF
#if 0		// These commands can affect the CPU clock, in such a way that the processor is no longer
			// capable of receiving commands, and needs physical access to recover.
			// So we deem them too dangerous. Use the old BSLwriter to change frequency calibration
			_OFb		#'f',Rtos				; 'f': 4 MHz cal
				mov.w		Rsec,&ram4MHzCalD
				; Also set the CPU clock, if appropriate
#if MClock4
				mov.b	&ram4MHzCalB,&BCSCTL1
				mov.b	Rsec,&DCOCTL
#endif
			_ENDOF
			_OFb		#'o',Rtos				; 'o': 1 MHz cal
				mov.w		Rsec,&ram1MHzCalD
#if !MClock4
				mov.b	&ram1MHzCalB,&BCSCTL1
				mov.b	Rsec,&DCOCTL
#endif
			_ENDOF
#endif		// #if 0

			_OFb		#'i',Rtos				; 'i': ID
				mov.b		Rsec,&ramID
			_ENDOF
			jmp		emitQmark
			_ENDCASE
			ret


;
; setIDs ( -- )
;
			xCODE	'i',setIDs,_setIDs
; It just doesn't seem to work out to use the delay between BMUs to determine the correct ID, so
; we simply read the ID from the serial port, and echo the next ID downstream.

			call	#ReadByte				; Read the byte into R8, don't echo it, trashes R9 R10 R11
											; Not echoed because of logic in dummyInterpretByte
waitingIDAddr								; This address will be on the stack in dummyInterpretByte
			mov		R8,R12					; Save our ID
			inc		R8
			call	#WriteByte				; Send downstream BMU's ID
			bic.b	#LED,&P1OUT				; Clear LED set by WriteByte
			mov.b	R12,&ramID				; Save our ID to RAM
			ret

; Update info-flash ( -- )
			xCODE	'u',updateInfoFlash,_updateInfoFlash
; Prepare to flash-program
; Assumes ACCVIE = NMIIE = OFIE = 0.
; FSSEL: 1=MCLK FN: 2=divide by 3, 11=divide by 12. Must end up in the range 257-476 kHz
#if MClock4
			MOV		#FWKEY+FSSEL_1+FN0*(12-1),&FCTL2 ; For 4 MHz MCLK
#else
			MOV		#FWKEY+FSSEL_1+FN0*(3-1),&FCTL2 ; For 1 MHz MCLK
#endif
StopWDT		mov.w	#WDTPW+WDTHOLD,&WDTCTL	; Stop Watchdog Timer


; Erase info flash including segment A.
			mov		#$1000,R12				; Start of info-flash
eraseInfo	MOV		#FWKEY,&FCTL3			; Clear LOCK, don't toggle LOCKA
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase (doesn't seem to "stick")
			rra		@R12					; Dummy write: erase segment
			add		#64,R12					; Next segment
			cmp		#$10C0,R12
			jnz		eraseInfo				; Loop until at start of segment A
			CLRLOCKA						; Clear segment A lock (so we can erase and write it also)
			MOV		#FWKEY+ERASE,&FCTL1		; Enable single segment erase
			rra		@R12					; Dummy write: erase segment A

			MOV		#FWKEY+WRT,&FCTL1		; Enable write (can leave on; only write block that can't)
			clr		R12						; Index register
pifLoop1	mov.w	for1000(R12),$1000(R12)	; Program word
			incd	R12
			cmp		#mainID-for1000,R12		; Check for start of calibration data
			jnz		pifLoop1				; Repeat until done this part

; In the source operand of the move instruction below, R12 is larger by $F2 (mainID-for1000) than we
; want, hence the subtraction
pifLoop2	mov.w	ramID-(mainID-for1000)(R12),$1000(R12)
			incd	R12
			cmp		#mainPWtable-for1000,R12	; Check for end of calibration data
			jnz		pifLoop2

; Now move the last 4 bytes. It's actually more bytes to do two moves, and this looks more consistent
pifLoop3	mov.w	for1000(R12),$1000(R12)
			incd.b	R12
			jnz		pifLoop3				; Loop till the end of info flash (8-bit index wraps to 0)

			MOV		#FWKEY,&FCTL1			; Done. Clear WRT
			MOV		#FWKEY+LOCK+LOCKA,&FCTL3 ; Set LOCKs
			SETLOCKA						; Ensure segment A is locked
			;
			; Check that the flash programming worked
			;
			call	#compareImage			; Compare the for1000 image with what's at 1000
			jnz		failCompare
			
			;
			; Compares successfully.
			bic.b	#WDTIFG,&IFG1			; Clear the watchdog timer interrupt flag
			; FIXME: DO WE WANT THIS?
			br		#$1000					; Start the new BSL

failCompare mov		#3,rERR
			jmp		errorFlash
			
;
; GetByte - get a byte (NOT to stack) and display it ( addr -- )
;
			xCODE	'g',GetByte,_GetByte
			mov.b	#' ',Rthd
			mov.b	@Rtos,Rsec
;			mov		#3,Rtos
			jmp		_prettyPrint3			; Tail-call pretty-print of 3 digits
			
;
; ZtoreByte - store a byte (a la CStore) ( ch addr -- )
;
			xCODE	'z',ZtoreByte,_ZtoreByte
			mov.b	Rsec,0(Rtos)
			ret
;
; FetchWord - fetch a word (NOT to stack) and display it ( addr -- )
;
			xCODE	'f',FetchWord,_FetchWord
			mov.b	#' ',Rthd
			mov.w	@Rtos,Rsec
			mov		#5,Rtos
			jmp		_prettyPrint
			
;
; stOreWord - store a word (a la Store) ( n addr -- )
;
			xCODE	'o',stOreWord,_stOreWord
			mov.w	Rsec,0(Rtos)
			ret
;
; JumpTo - Call the code at addr ( addr -- )
;
			xCODE	'j',JumpTo,_JumpTo
			mov		Rtos,R8		; Save the jump address in a trashable non-stack reg
			DROP				; Drop stack in case the code at addr uses stack arguments
			br		R8			; Tail-call the code at addr and return
			
;
; Turn on or off bypass resistors ( bool -- )
;
		xCODE	'y',bypass,_bypass
		allBitsIfNZ	Rtos,Rtos		; IF Rtos is nonzero THEN $FF to Rtos ELSE $00 to Rtos
		movBits_B	Rtos,#BYPASS,&P1OUT ; Move only the #BYPASS bit from Rtos to &P1OUT. Trashes Rtos.
;		pop		Rtos				; Remove operand
		ret

#if 0		// These commands are deemed pointess, since changing the CPU frequency will almost
			// certainly render serial communications inoperative
;
; f and o commands ( -- )
; These output a fixed frequency to the LED and two outputs (in phase, so it doesn't send the
; downstream BMU crazy) for 5 seconds
; NOTE: this command can only be used (in conjunction with `fw or `ow) to make small adjustments to
;	CPU speed, since communications will be affected!

			xCODE	'o',oneMhzBurst,_oneMhzBurst
#if			MClock4
			mov.b	&ram1MHzCalB,&BCSCTL1
			mov.b	&ram1MHzCalD,&DCOCTL
#endif
			mov		#28/4,R11
			call	#doBurst
#if			MClock4
			mov.b	&ram4MHzCalB,&BCSCTL1
			mov.b	&ram4MHzCalD,&DCOCTL
#endif
			ret

			xCODE	'f',fourMhzBurst,_fourMhzBurst
#if			!MClock4
			mov.b	&ram4MHzCalB,&BCSCTL1
			mov.b	&ram4MHzCalD,&DCOCTL
#endif
			mov		#28,R11
			call	#doBurst
#if			!MClock4
			mov.b	&ram1MHzCalB,&BCSCTL1
			mov.b	&ram1MHzCalD,&DCOCTL
#endif
			ret

;
; Toggle LED, TXDm, and TXDp with an 11 cycle loop, or 4000/2/11 = 181.8 kHz (@ 4 MHz)
; or 1000/2/11 = 45.45 kHz (@ 1 MHz)
; or 2000/2/11 = 90.9  kHz (@ 2 MHz)

doBurst		clr		R10
			clr.b	&P1OUT					; LED off, transmit outputs at same low level
burstLp		xor.b	#LED+TXDp+TXDm,&P1OUT	; (5) Toggle all 3 bits
			dec		R10						; (1)
			jnz		jBurstLp				; (2) Jump to a 3-cycle delay to burstLp
			dec		R11						;	(alt1 1)
			jnz		burstLp					;	(alt1 2)
			mov.b	#TXDp,&P1OUT			; Restore TXDp
			ret
jBurstLp	br		#burstLp				;	(alt2 3)
#endif